{"version":3,"sources":["useDynamicPagination.js"],"sourcesContent":["import * as React from 'react';\nimport { useRef } from 'react';\n/**\n * Optional hook that will enable pagination on the virtualizer so that it 'autoscrolls' to an items exact position\n * Sizes are dynamic so we require a progressive sizing array (passed in from Dynamic virtualizer hooks)\n * On short scrolls, we will go at minimum to the next/previous item so that arrow pagination works\n * All VirtualizerDynamicPaginationProps can be grabbed from dynamic Virtualizer hooks externally and passed in\n */ export const useDynamicVirtualizerPagination = (virtualizerProps, paginationEnabled = true)=>{\n    const { axis = 'vertical', currentIndex, progressiveItemSizes, virtualizerLength } = virtualizerProps;\n    const timeoutRef = useRef(null);\n    const lastScrollPos = useRef(-1);\n    const lastIndexScrolled = useRef(-1);\n    const scrollContainer = React.useRef(null);\n    const clearListeners = ()=>{\n        if (scrollContainer.current) {\n            scrollContainer.current.removeEventListener('scroll', onScroll);\n            scrollContainer.current = null;\n            if (timeoutRef.current) {\n                clearTimeout(timeoutRef.current);\n            }\n        }\n    };\n    React.useEffect(()=>{\n        return ()=>{\n            clearListeners();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    /**\n   * Handle scroll stop event and paginate to the closest item\n   * If the closest item is the same as the previous scroll end\n   * we paginate to the next/previous one based on direction\n   *\n   * Users/Virtualizer-Hooks must pass in a cumulative array of sizes\n   * This prevents the need to recalculate and ensures size arrays are synced externally\n   */ const onScrollEnd = React.useCallback(()=>{\n        if (!scrollContainer.current || !paginationEnabled || !(progressiveItemSizes === null || progressiveItemSizes === void 0 ? void 0 : progressiveItemSizes.current)) {\n            // No container found\n            return;\n        }\n        const currentScrollPos = Math.round(axis === 'vertical' ? scrollContainer.current.scrollTop : scrollContainer.current.scrollLeft);\n        let closestItemPos = 0;\n        let closestItem = 0;\n        const endItem = Math.min(currentIndex + virtualizerLength, progressiveItemSizes.current.length);\n        for(let i = currentIndex; i < endItem - 1; i++){\n            if (currentScrollPos <= progressiveItemSizes.current[i + 1] && currentScrollPos >= progressiveItemSizes.current[i]) {\n                // Found our in between position\n                const distanceToPrev = Math.abs(currentScrollPos - progressiveItemSizes.current[i]);\n                const distanceToNext = Math.abs(progressiveItemSizes.current[i + 1] - currentScrollPos);\n                if (distanceToPrev < distanceToNext) {\n                    closestItem = i;\n                } else {\n                    closestItem = i + 1;\n                }\n                break;\n            }\n        }\n        let nextItem;\n        if (Math.round(closestItem - lastIndexScrolled.current) === 0) {\n            // Special case for go to next/previous with minimum amount of scroll needed\n            const nextTarget = lastScrollPos.current < currentScrollPos ? 1 : -1;\n            // This will also handle a case where we scrolled to the exact correct position (noop)\n            const isSecondaryScroll = Math.round(lastScrollPos.current - currentScrollPos) === 0;\n            const posMod = isSecondaryScroll ? 0 : nextTarget;\n            nextItem = closestItem + posMod;\n        } else {\n            // Pagination for anything else can just jump to the closest!\n            nextItem = closestItem;\n        }\n        // Safeguard nextItem\n        nextItem = Math.min(Math.max(0, nextItem), progressiveItemSizes.current.length);\n        closestItemPos = progressiveItemSizes.current[nextItem];\n        if (axis === 'vertical') {\n            scrollContainer.current.scrollTo({\n                top: closestItemPos,\n                behavior: 'smooth'\n            });\n        } else {\n            scrollContainer.current.scrollTo({\n                left: closestItemPos,\n                behavior: 'smooth'\n            });\n        }\n        lastScrollPos.current = progressiveItemSizes.current[nextItem];\n        lastIndexScrolled.current = nextItem;\n    }, [\n        paginationEnabled,\n        currentIndex,\n        scrollContainer,\n        virtualizerLength,\n        axis,\n        progressiveItemSizes\n    ]);\n    /**\n   * On scroll timer that will continuously delay callback until scrolling stops\n   */ const onScroll = React.useCallback((event)=>{\n        if (timeoutRef.current) {\n            clearTimeout(timeoutRef.current);\n        }\n        timeoutRef.current = setTimeout(onScrollEnd, 100);\n    }, [\n        onScrollEnd\n    ]);\n    /**\n   * Pagination ref will ensure we attach listeners to containers on change\n   * It is returned from hook and merged into the scroll container externally\n   */ const paginationRef = React.useCallback((instance)=>{\n        if (!paginationEnabled) {\n            clearListeners();\n            scrollContainer.current = null;\n            return;\n        }\n        if (scrollContainer.current !== instance) {\n            clearListeners();\n            scrollContainer.current = instance;\n            if (scrollContainer.current) {\n                scrollContainer.current.addEventListener('scroll', onScroll);\n            }\n        }\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        onScroll,\n        onScrollEnd,\n        paginationEnabled\n    ]);\n    return paginationRef;\n};\n"],"names":["useDynamicVirtualizerPagination","virtualizerProps","paginationEnabled","axis","currentIndex","progressiveItemSizes","virtualizerLength","timeoutRef","useRef","lastScrollPos","lastIndexScrolled","scrollContainer","React","clearListeners","current","removeEventListener","onScroll","clearTimeout","useEffect","onScrollEnd","useCallback","currentScrollPos","Math","round","scrollTop","scrollLeft","closestItemPos","closestItem","endItem","min","length","i","distanceToPrev","abs","distanceToNext","nextItem","nextTarget","isSecondaryScroll","posMod","max","scrollTo","top","behavior","left","event","setTimeout","paginationRef","instance","addEventListener"],"mappings":"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"}