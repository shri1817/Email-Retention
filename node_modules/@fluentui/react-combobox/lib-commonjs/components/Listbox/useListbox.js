"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useListbox_unstable", {
    enumerable: true,
    get: function() {
        return useListbox_unstable;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reactutilities = require("@fluentui/react-utilities");
const _reactcontextselector = require("@fluentui/react-context-selector");
const _reactaria = require("@fluentui/react-aria");
const _dropdownKeyActions = require("../../utils/dropdownKeyActions");
const _useOptionCollection = require("../../utils/useOptionCollection");
const _useSelection = require("../../utils/useSelection");
const _useOptionStylesstyles = require("../Option/useOptionStyles.styles");
const _ListboxContext = require("../../contexts/ListboxContext");
// eslint-disable-next-line @typescript-eslint/naming-convention
const UNSAFE_noLongerUsed = {
    activeOption: undefined,
    focusVisible: false,
    setActiveOption: ()=>null
};
const useListbox_unstable = (props, ref)=>{
    const { multiselect } = props;
    const optionCollection = (0, _useOptionCollection.useOptionCollection)();
    const { getOptionById } = optionCollection;
    const { listboxRef: activeDescendantListboxRef, activeParentRef, controller } = (0, _reactaria.useActiveDescendant)({
        matchOption: (el)=>el.classList.contains(_useOptionStylesstyles.optionClassNames.root)
    });
    const activeDescendantContext = (0, _reactaria.useActiveDescendantContext)();
    const activeDescendantController = (0, _reactaria.useHasParentActiveDescendantContext)() ? activeDescendantContext.controller : controller;
    const { clearSelection, selectedOptions, selectOption } = (0, _useSelection.useSelection)(props);
    const onKeyDown = (event)=>{
        const action = (0, _dropdownKeyActions.getDropdownActionFromKey)(event, {
            open: true
        });
        const activeOptionId = activeDescendantController.active();
        const activeOption = activeOptionId ? getOptionById(activeOptionId) : null;
        switch(action){
            case 'Next':
                if (activeOption) {
                    activeDescendantController.next();
                } else {
                    activeDescendantController.first();
                }
                break;
            case 'Previous':
                if (activeOption) {
                    activeDescendantController.prev();
                } else {
                    activeDescendantController.first();
                }
                break;
            case 'PageUp':
            case 'First':
                activeDescendantController.first();
                break;
            case 'PageDown':
            case 'Last':
                activeDescendantController.last();
                break;
            case 'Select':
            case 'CloseSelect':
                activeOption && selectOption(event, activeOption);
                break;
        }
    };
    // get state from parent combobox, if it exists
    const hasListboxContext = (0, _reactcontextselector.useHasParentContext)(_ListboxContext.ListboxContext);
    const contextSelectedOptions = (0, _ListboxContext.useListboxContext_unstable)((ctx)=>ctx.selectedOptions);
    const contextSelectOption = (0, _ListboxContext.useListboxContext_unstable)((ctx)=>ctx.selectOption);
    // without a parent combobox context, provide values directly from Listbox
    const optionContextValues = hasListboxContext ? {
        selectedOptions: contextSelectedOptions,
        selectOption: contextSelectOption,
        ...UNSAFE_noLongerUsed
    } : {
        selectedOptions,
        selectOption,
        ...UNSAFE_noLongerUsed
    };
    const state = {
        components: {
            root: 'div'
        },
        root: _reactutilities.slot.always((0, _reactutilities.getIntrinsicElementProps)('div', {
            // FIXME:
            // `ref` is wrongly assigned to be `HTMLElement` instead of `HTMLDivElement`
            // but since it would be a breaking change to fix it, we are casting ref to it's proper type
            ref: (0, _reactutilities.useMergedRefs)(ref, activeParentRef, activeDescendantListboxRef),
            role: multiselect ? 'menu' : 'listbox',
            tabIndex: 0,
            ...props
        }), {
            elementType: 'div'
        }),
        multiselect,
        clearSelection,
        activeDescendantController,
        ...optionCollection,
        ...optionContextValues
    };
    state.root.onKeyDown = (0, _reactutilities.useEventCallback)((0, _reactutilities.mergeCallbacks)(state.root.onKeyDown, onKeyDown));
    return state;
};
