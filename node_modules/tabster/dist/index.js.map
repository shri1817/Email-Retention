{"version":3,"file":"index.js","sources":["../src/Types.ts","../src/Instance.ts","../src/Events.ts","../src/DOMAPI.ts","../src/Utils.ts","../src/AttributeHelpers.ts","../src/Root.ts","../src/Deloser.ts","../src/State/Subscribable.ts","../src/CrossOrigin.ts","../src/Focusable.ts","../src/Keys.ts","../src/State/FocusedElement.ts","../src/Groupper.ts","../src/State/KeyboardNavigation.ts","../src/Modalizer.ts","../src/Mover.ts","../src/MutationEvent.ts","../src/State/ObservedElement.ts","../src/Outline.ts","../src/Uncontrolled.ts","../src/Restorer.ts","../src/Shadowdomize/DOMFunctions.ts","../src/Shadowdomize/ShadowTreeWalker.ts","../src/Shadowdomize/ShadowMutationObserver.ts","../src/Shadowdomize/querySelector.ts","../src/Shadowdomize/index.ts","../src/Tabster.ts","../src/Deprecated.ts"],"sourcesContent":["/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const TabsterAttributeName = \"data-tabster\";\nexport const TabsterDummyInputAttributeName = \"data-tabster-dummy\";\n\nexport const FocusableSelector = [\n    \"a[href]\",\n    \"button:not([disabled])\",\n    \"input:not([disabled])\",\n    \"select:not([disabled])\",\n    \"textarea:not([disabled])\",\n    \"*[tabindex]\",\n    \"*[contenteditable]\",\n    \"details > summary\",\n    \"audio[controls]\",\n    \"video[controls]\",\n].join(\", \");\n\nexport interface TabsterDOMAttribute {\n    [TabsterAttributeName]: string | undefined;\n}\n\nexport interface TabsterCoreProps {\n    autoRoot?: RootProps;\n    /**\n     * Allows all tab key presses under the tabster root to be controlled by tabster\n     * @default true\n     */\n    controlTab?: boolean;\n    /**\n     * When controlTab is false, Root doesn't have dummy inputs by default.\n     * This option allows to enable dummy inputs on Root.\n     */\n    rootDummyInputs?: boolean;\n    /**\n     * A callback that will be called for the uncontrolled areas when Tabster wants\n     * to know is the uncontrolled element wants complete control (for example it\n     * is trapping focus) and Tabster should not interfere with handling Tab.\n     * If the callback returns undefined, then the default behaviour is to return\n     * the uncontrolled.completely value from the element. If the callback returns\n     * non-undefined value, the callback's value will dominate the element's\n     * uncontrolled.completely value.\n     */\n    checkUncontrolledCompletely?: (\n        element: HTMLElement,\n        completely: boolean // A uncontrolled.completely value from the element.\n    ) => boolean | undefined;\n    /**\n     * @deprecated use checkUncontrolledCompletely.\n     */\n    checkUncontrolledTrappingFocus?: (element: HTMLElement) => boolean;\n    /**\n     * Custom getter for parent elements. Defaults to the default .parentElement call\n     * Currently only used to detect tabster contexts\n     */\n    getParent?(el: Node): Node | null;\n    /**\n     * Ability to redefine all DOM API calls used by Tabster. For example, for\n     * ShadowDOM support.\n     */\n    DOMAPI?: Partial<DOMAPI>;\n}\n\nexport interface DOMAPI {\n    createMutationObserver: (callback: MutationCallback) => MutationObserver;\n    createTreeWalker(\n        doc: Document,\n        root: Node,\n        whatToShow?: number,\n        filter?: NodeFilter | null\n    ): TreeWalker;\n    getParentNode(node: Node | null | undefined): ParentNode | null;\n    getParentElement(\n        element: HTMLElement | null | undefined\n    ): HTMLElement | null;\n    nodeContains(\n        parent: Node | null | undefined,\n        child: Node | null | undefined\n    ): boolean;\n    getActiveElement(doc: Document): Element | null;\n    querySelector(element: ParentNode, selector: string): Element | null;\n    querySelectorAll(element: ParentNode, selector: string): Element[];\n    getElementById(doc: Document, id: string): HTMLElement | null;\n    getFirstChild(node: Node | null | undefined): ChildNode | null;\n    getLastChild(node: Node | null | undefined): ChildNode | null;\n    getNextSibling(node: Node | null | undefined): ChildNode | null;\n    getPreviousSibling(node: Node | null | undefined): ChildNode | null;\n    getFirstElementChild(element: Element | null | undefined): Element | null;\n    getLastElementChild(element: Element | null | undefined): Element | null;\n    getNextElementSibling(element: Element | null | undefined): Element | null;\n    getPreviousElementSibling(\n        element: Element | null | undefined\n    ): Element | null;\n    appendChild(parent: Node, child: Node): Node;\n    insertBefore(parent: Node, child: Node, referenceChild: Node | null): Node;\n    getSelection(ref: Node): Selection | null;\n}\n\nexport type GetTabster = () => TabsterCore;\nexport type GetWindow = () => Window;\n\nexport type SubscribableCallback<A, B = undefined> = (\n    val: A,\n    detail: B\n) => void;\n\nexport interface Disposable {\n    /** @internal */\n    dispose(): void;\n}\n\nexport interface Subscribable<A, B = undefined> {\n    subscribe(callback: SubscribableCallback<A, B>): void;\n    /** @internal */\n    subscribeFirst(callback: SubscribableCallback<A, B>): void;\n    unsubscribe(callback: SubscribableCallback<A, B>): void;\n}\n\nexport interface KeyboardNavigationState\n    extends Subscribable<boolean>,\n        Disposable {\n    isNavigatingWithKeyboard(): boolean;\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void;\n}\n\nexport interface FocusedElementDetail {\n    relatedTarget?: HTMLElement;\n    isFocusedProgrammatically?: boolean;\n    modalizerId?: string;\n}\n\nexport const AsyncFocusSources = {\n    EscapeGroupper: 1,\n    Restorer: 2,\n    Deloser: 3,\n} as const;\n\nexport type AsyncFocusSource =\n    typeof AsyncFocusSources[keyof typeof AsyncFocusSources];\n\nexport interface FocusedElementState\n    extends Subscribable<HTMLElement | undefined, FocusedElementDetail>,\n        Disposable {\n    getFocusedElement(): HTMLElement | undefined;\n    getLastFocusedElement(): HTMLElement | undefined;\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    focusDefault(container: HTMLElement): boolean;\n    /** @internal */\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<FindFocusableProps, \"container\" | \"ignoreAccessibility\">\n    ): HTMLElement | undefined;\n    focusFirst(props: FindFirstProps): boolean;\n    focusLast(props: FindFirstProps): boolean;\n    resetFocus(container: HTMLElement): boolean;\n    /**\n     * When Tabster wants to move focus asynchronously, it it should call this method to register its intent.\n     * This is a way to avoid conflicts between different parts that might want to move focus asynchronously\n     * at the same moment (for example when both Deloser and Restorer want to move focus when the focused element\n     * is removed from DOM).\n     */\n    /** @internal */\n    requestAsyncFocus(\n        source: AsyncFocusSource,\n        callback: () => void,\n        delay: number\n    ): void;\n    /** @internal */\n    cancelAsyncFocus(source: AsyncFocusSource): void;\n}\n\nexport interface WeakHTMLElement<D = undefined> {\n    get(): HTMLElement | undefined;\n    getData(): D | undefined;\n}\n\nexport interface TabsterPart<P> {\n    readonly id: string;\n    getElement(): HTMLElement | undefined;\n    getProps(): P;\n    setProps(props: P): void;\n}\n\nexport interface TabsterPartWithFindNextTabbable {\n    findNextTabbable(\n        current?: HTMLElement,\n        reference?: HTMLElement,\n        isBackward?: boolean,\n        ignoreAccessibility?: boolean\n    ): NextTabbable | null;\n}\n\nexport interface TabsterPartWithAcceptElement {\n    acceptElement(\n        element: HTMLElement,\n        state: FocusableAcceptElementState\n    ): number | undefined;\n}\n\nexport interface ObservedElementProps {\n    names: string[];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    details?: any;\n}\n\nexport interface ObservedElementDetails extends ObservedElementProps {\n    accessibility?: ObservedElementAccesibility;\n}\n\nexport const ObservedElementAccesibilities = {\n    Any: 0,\n    Accessible: 1,\n    Focusable: 2,\n} as const;\n\nexport type ObservedElementAccesibility =\n    typeof ObservedElementAccesibilities[keyof typeof ObservedElementAccesibilities];\n\nexport interface ObservedElementAsyncRequest<T> {\n    result: Promise<T>;\n    cancel(): void;\n}\n\ninterface ObservedElementAPIInternal {\n    /** @internal */\n    onObservedElementUpdate(element: HTMLElement): void;\n}\n\nexport interface ObservedElementAPI\n    extends Subscribable<HTMLElement, ObservedElementDetails>,\n        Disposable,\n        ObservedElementAPIInternal {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): HTMLElement | null;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): ObservedElementAsyncRequest<HTMLElement | null>;\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): ObservedElementAsyncRequest<boolean>;\n}\n\nexport interface CrossOriginElement {\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginSentTo {\n    [id: string]: true;\n}\n\nexport interface CrossOriginTransactionTypes {\n    Bootstrap: 1;\n    FocusElement: 2;\n    State: 3;\n    GetElement: 4;\n    RestoreFocusInDeloser: 5;\n    Ping: 6;\n}\nexport type CrossOriginTransactionType =\n    CrossOriginTransactionTypes[keyof CrossOriginTransactionTypes];\n\nexport interface CrossOriginTransactionData<I, O> {\n    transaction: string;\n    type: CrossOriginTransactionType;\n    isResponse: boolean;\n    timestamp: number;\n    owner: string;\n    sentto: CrossOriginSentTo;\n    timeout?: number;\n    target?: string;\n    beginData?: I;\n    endData?: O;\n}\n\nexport type CrossOriginTransactionSend = (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>\n) => void;\n\nexport interface CrossOriginMessage {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: CrossOriginTransactionData<any, any>;\n    send: CrossOriginTransactionSend;\n}\n\nexport interface CrossOriginFocusedElementState\n    extends Subscribable<CrossOriginElement | undefined, FocusedElementDetail>,\n        Disposable {\n    focus(\n        element: CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n    focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean>;\n}\n\nexport interface CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, ObservedElementProps>,\n        Disposable {\n    getElement(\n        observedName: string,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null>;\n    requestFocus(observedName: string, timeout: number): Promise<boolean>;\n}\n\nexport interface CrossOriginAPI {\n    focusedElement: CrossOriginFocusedElementState;\n    observedElement: CrossOriginObservedElementState;\n\n    setup(\n        sendUp?: CrossOriginTransactionSend | null\n    ): (msg: CrossOriginMessage) => void;\n    isSetUp(): boolean;\n    dispose(): void;\n}\n\nexport interface OutlineProps {\n    areaClass: string;\n    outlineClass: string;\n    outlineColor: string;\n    outlineWidth: number;\n    zIndex: number;\n}\n\nexport interface OutlinedElementProps {\n    isIgnored?: boolean;\n}\n\nexport interface OutlineAPI extends Disposable {\n    setup(props?: Partial<OutlineProps>): void;\n}\n\nexport interface DeloserElementActions {\n    focusDefault: () => boolean;\n    focusFirst: () => boolean;\n    resetFocus: () => boolean;\n    clearHistory: (preserveExisting?: boolean) => void;\n    setSnapshot: (index: number) => void;\n    isActive: () => boolean;\n}\n\nexport const RestoreFocusOrders = {\n    History: 0,\n    DeloserDefault: 1,\n    RootDefault: 2,\n    DeloserFirst: 3,\n    RootFirst: 4,\n} as const;\n\nexport type RestoreFocusOrder =\n    typeof RestoreFocusOrders[keyof typeof RestoreFocusOrders];\n\nexport const DeloserStrategies = {\n    /**\n     * If the focus is lost, the focus will be restored automatically using all available focus history.\n     * This is the default strategy.\n     */\n    Auto: 0,\n    /**\n     * If the focus is lost from this Deloser instance, the focus will not be restored automatically.\n     * The application might listen to the event and restore the focus manually.\n     * But if it is lost from another Deloser instance, the history of this Deloser could be used finding\n     * the element to focus.\n     */\n    Manual: 1,\n} as const;\n\nexport type DeloserStrategy =\n    typeof DeloserStrategies[keyof typeof DeloserStrategies];\n\nexport interface DeloserProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n    noSelectorCheck?: boolean;\n    strategy?: DeloserStrategy;\n}\n\nexport interface Deloser extends TabsterPart<DeloserProps> {\n    readonly uid: string;\n    readonly strategy: DeloserStrategy;\n    dispose(): void;\n    isActive(): boolean;\n    setActive(active: boolean): void;\n    getActions(): DeloserElementActions;\n    setSnapshot(index: number): void;\n    focusFirst(): boolean;\n    unshift(element: HTMLElement): void;\n    focusDefault(): boolean;\n    resetFocus(): boolean;\n    findAvailable(): HTMLElement | null;\n    clearHistory(preserveExisting?: boolean): void;\n    customFocusLostHandler(element: HTMLElement): boolean;\n}\n\nexport type DeloserConstructor = (\n    element: HTMLElement,\n    props: DeloserProps\n) => Deloser;\n\ninterface DeloserInterfaceInternal {\n    /** @internal */\n    createDeloser(element: HTMLElement, props: DeloserProps): Deloser;\n}\n\nexport interface DeloserAPI extends DeloserInterfaceInternal, Disposable {\n    getActions(element: HTMLElement): DeloserElementActions | undefined;\n    pause(): void;\n    resume(restore?: boolean): void;\n}\n\nexport interface FocusableProps {\n    isDefault?: boolean;\n    isIgnored?: boolean;\n    /**\n     * Do not determine an element's focusability based on aria-disabled.\n     */\n    ignoreAriaDisabled?: boolean;\n    /**\n     * Exclude element (and all subelements) from Mover navigation.\n     */\n    excludeFromMover?: boolean;\n    /**\n     * Prevents tabster from handling the keydown event\n     */\n    ignoreKeydown?: {\n        Tab?: boolean;\n        Escape?: boolean;\n        Enter?: boolean;\n        ArrowUp?: boolean;\n        ArrowDown?: boolean;\n        ArrowLeft?: boolean;\n        ArrowRight?: boolean;\n        PageUp?: boolean;\n        PageDown?: boolean;\n        Home?: boolean;\n        End?: boolean;\n    };\n}\n\nexport interface FocusableAcceptElementState {\n    container: HTMLElement;\n    modalizerUserId?: string;\n    currentCtx?: TabsterContext;\n    from: HTMLElement;\n    fromCtx?: TabsterContext;\n    isBackward?: boolean;\n    found?: boolean;\n    foundElement?: HTMLElement;\n    foundBackward?: HTMLElement;\n    rejectElementsFrom?: HTMLElement;\n    uncontrolled?: HTMLElement;\n    acceptCondition: (el: HTMLElement) => boolean;\n    hasCustomCondition?: boolean;\n    includeProgrammaticallyFocusable?: boolean;\n    ignoreAccessibility?: boolean;\n    cachedGrouppers: {\n        [id: string]: {\n            isActive: boolean | undefined;\n            first?: HTMLElement | null;\n        };\n    };\n    isFindAll?: boolean;\n    /**\n     * A flag that indicates that some focusable elements were skipped\n     * during the search and the found element is not the one the browser\n     * would normally focus if the user pressed Tab.\n     */\n    skippedFocusable?: boolean;\n}\n\nexport interface FindFocusableProps {\n    /**\n     * The container used for the search.\n     */\n    container: HTMLElement;\n    /**\n     * The elemet to start from.\n     */\n    currentElement?: HTMLElement;\n    /**\n     * See `referenceElement` of GetTabsterContextOptions for description.\n     */\n    referenceElement?: HTMLElement;\n    /**\n     * Includes elements that can be focused programmatically.\n     */\n    includeProgrammaticallyFocusable?: boolean;\n    /**\n     * Ignore accessibility check.\n     */\n    ignoreAccessibility?: boolean;\n    /**\n     * Take active modalizer into account when searching for elements\n     * (the elements out of active modalizer will not be returned).\n     */\n    useActiveModalizer?: boolean;\n    /**\n     * Search withing the specified modality, null for everything outside of modalizers, string within\n     * a specific id, undefined for search within the current application state.\n     */\n    modalizerId?: string | null;\n    /**\n     * If true, find previous element instead of the next one.\n     */\n    isBackward?: boolean;\n    /**\n     * @param el element visited.\n     * @returns if an element should be accepted.\n     */\n    acceptCondition?(el: HTMLElement): boolean;\n    /**\n     * A callback that will be called for every focusable element found during findAll().\n     * If false is returned from this callback, the search will stop.\n     */\n    onElement?: FindElementCallback;\n}\n\nexport interface FindFocusableOutputProps {\n    /**\n     * An output parameter. Will be true after the findNext/findPrev() call if some focusable\n     * elements were skipped during the search and the result element not immediately next\n     * focusable after the currentElement.\n     */\n    outOfDOMOrder?: boolean;\n    /**\n     * An output parameter. Will be true if the found element is uncontrolled.\n     */\n    uncontrolled?: HTMLElement | null;\n}\n\nexport type FindFirstProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindNextProps = Pick<\n    FindFocusableProps,\n    | \"currentElement\"\n    | \"referenceElement\"\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindDefaultProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"ignoreAccessibility\"\n>;\n\nexport type FindAllProps = Pick<\n    FindFocusableProps,\n    | \"container\"\n    | \"modalizerId\"\n    | \"currentElement\"\n    | \"isBackward\"\n    | \"includeProgrammaticallyFocusable\"\n    | \"useActiveModalizer\"\n    | \"acceptCondition\"\n    | \"ignoreAccessibility\"\n    | \"onElement\"\n>;\n\n/**\n * A callback that is called for every found element during search. Returning false stops search.\n */\nexport type FindElementCallback = (element: HTMLElement) => boolean;\n\nexport interface FocusableAPI extends Disposable {\n    getProps(element: HTMLElement): FocusableProps;\n\n    isFocusable(\n        element: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean;\n    isVisible(element: HTMLElement): boolean;\n    isAccessible(element: HTMLElement): boolean;\n    // find* return null when there is no element and undefined when there is an uncontrolled area.\n    findFirst(\n        options: FindFirstProps,\n        out?: FindFocusableOutputProps\n    ): HTMLElement | null | undefined;\n    findLast(\n        options: FindFirstProps,\n        out?: FindFocusableOutputProps\n    ): HTMLElement | null | undefined;\n    findNext(\n        options: FindNextProps,\n        out?: FindFocusableOutputProps\n    ): HTMLElement | null | undefined;\n    findPrev(\n        options: FindNextProps,\n        out?: FindFocusableOutputProps\n    ): HTMLElement | null | undefined;\n    findDefault(\n        options: FindDefaultProps,\n        out?: FindFocusableOutputProps\n    ): HTMLElement | null;\n    /**\n     * @returns All focusables in a given context that satisfy an given condition\n     */\n    findAll(options: FindAllProps): HTMLElement[];\n    findElement(\n        options: FindFocusableProps,\n        out?: FindFocusableOutputProps\n    ): HTMLElement | null | undefined;\n}\n\nexport interface DummyInputManager {\n    moveOut: (backwards: boolean) => void;\n    moveOutWithDefaultAction: (\n        backwards: boolean,\n        relatedEvent: KeyboardEvent\n    ) => void;\n}\n\nexport const Visibilities = {\n    Invisible: 0,\n    PartiallyVisible: 1,\n    Visible: 2,\n} as const;\n\nexport type Visibility = typeof Visibilities[keyof typeof Visibilities];\n\nexport interface MoverElementState {\n    isCurrent: boolean | undefined; // Tri-state bool. Undefined when there is no current in the container.\n    visibility: Visibility;\n}\n\nexport interface MoverDirections {\n    Both: 0; // Default, both left/up keys move to the previous, right/down move to the next.\n    Vertical: 1; // Only up/down arrows move to the next/previous.\n    Horizontal: 2; // Only left/right arrows move to the next/previous.\n    Grid: 3; // Two-dimentional movement depending on the visual placement.\n    GridLinear: 4; // Two-dimentional movement depending on the visual placement. Allows linear movement.\n}\n\nexport const RestorerTypes = {\n    Source: 0,\n    Target: 1,\n} as const;\n\nexport type RestorerType = typeof RestorerTypes[keyof typeof RestorerTypes];\n\nexport const MoverDirections = {\n    Both: 0,\n    Vertical: 1,\n    Horizontal: 2,\n    Grid: 3,\n    GridLinear: 4,\n} as const;\n\nexport type MoverDirection =\n    typeof MoverDirections[keyof typeof MoverDirections];\n\nexport type NextTabbable = {\n    element: HTMLElement | null | undefined;\n    uncontrolled?: HTMLElement | null;\n    outOfDOMOrder?: boolean;\n};\n\nexport interface MoverProps {\n    direction?: MoverDirection;\n    memorizeCurrent?: boolean;\n    tabbable?: boolean;\n    /**\n     * Whether to allow cyclic navigation in the mover\n     * Can only be applied if navigationType is MoverKeys.Arrows\n     *\n     * @defaultValue false\n     */\n    cyclic?: boolean;\n    /**\n     * In case we need a rich state of the elements inside a Mover,\n     * we can track it. It takes extra resourses and might affect\n     * performance when a Mover has many elements inside, so make sure\n     * you use this prop when it is really needed.\n     */\n    trackState?: boolean;\n    /**\n     * When set to Visibility.Visible or Visibility.PartiallyVisible,\n     * uses the visibility part of the trackState prop to be able to\n     * go to first/last visible element (instead of first/last focusable\n     * element in DOM) when tabbing from outside of the mover.\n     */\n    visibilityAware?: Visibility;\n    /**\n     * When true, Mover will try to locate a focusable with Focusable.isDefault\n     * property as a prioritized element to focus. True by default.\n     */\n    hasDefault?: boolean;\n    /**\n     * A value between 0 and 1 that specifies the tolerance allowed\n     * when testing for visibility.\n     *\n     * @example\n     * an element of height 100px has 10px that are above the viewport\n     * hidden by scroll. This element is a valid visible element to focus.\n     *\n     * @default 0.8\n     */\n    visibilityTolerance?: number;\n}\n\nexport interface Mover\n    extends TabsterPart<MoverProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    readonly visibilityTolerance: NonNullable<\n        MoverProps[\"visibilityTolerance\"]\n    >;\n    dispose(): void;\n    setCurrent(element: HTMLElement | undefined): void;\n    getCurrent(): HTMLElement | null;\n    getState(element: HTMLElement): MoverElementState | undefined;\n}\n\nexport type MoverConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: MoverProps\n) => Mover;\n\ninterface MoverAPIInternal {\n    /** @internal */\n    createMover(\n        element: HTMLElement,\n        props: MoverProps,\n        sys: SysProps | undefined\n    ): Mover;\n}\n\nexport const MoverKeys = {\n    ArrowUp: 1,\n    ArrowDown: 2,\n    ArrowLeft: 3,\n    ArrowRight: 4,\n    PageUp: 5,\n    PageDown: 6,\n    Home: 7,\n    End: 8,\n} as const;\n\nexport type MoverKey = typeof MoverKeys[keyof typeof MoverKeys];\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface MoverAPI extends MoverAPIInternal, Disposable {\n    /** @internal (will likely be exposed once the API is fully stable) */\n    moveFocus(fromElement: HTMLElement, key: MoverKey): HTMLElement | null;\n}\n\nexport const GroupperTabbabilities = {\n    Unlimited: 0,\n    Limited: 1, // The tabbability is limited to the container and explicit Enter is needed to go inside.\n    LimitedTrapFocus: 2, // The focus is limited as above, plus trapped when inside.\n} as const;\n\nexport type GroupperTabbability =\n    typeof GroupperTabbabilities[keyof typeof GroupperTabbabilities];\n\nexport interface GroupperProps {\n    tabbability?: GroupperTabbability;\n    delegated?: boolean; // This allows to tweak the groupper behaviour for the cases when\n    // the groupper container is not focusable and groupper has Limited or LimitedTrapFocus\n    // tabbability. By default, the groupper will automatically become active once the focus\n    // goes to first focusable element inside the groupper during tabbing. When true, the\n    // groupper will become active only after Enter is pressed on first focusable element\n    // inside the groupper.\n}\n\nexport interface Groupper\n    extends TabsterPart<GroupperProps>,\n        TabsterPartWithFindNextTabbable,\n        TabsterPartWithAcceptElement {\n    readonly id: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    dispose(): void;\n    makeTabbable(isUnlimited: boolean): void;\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined; // Tri-state boolean, undefined when parent is not active, false when parent is active.\n    setFirst(element: HTMLElement | undefined): void;\n    getFirst(orContainer: boolean): HTMLElement | undefined;\n}\n\nexport type GroupperConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: GroupperProps\n) => Groupper;\n\nexport interface GroupperAPIInternal {\n    /** @internal */\n    createGroupper(\n        element: HTMLElement,\n        props: GroupperProps,\n        sys: SysProps | undefined\n    ): Groupper;\n    /** @internal */\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        fromModalizer?: boolean\n    ): void;\n}\n\nexport const GroupperMoveFocusActions = {\n    Enter: 1,\n    Escape: 2,\n} as const;\n\nexport type GroupperMoveFocusAction =\n    typeof GroupperMoveFocusActions[keyof typeof GroupperMoveFocusActions];\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface GroupperAPI extends GroupperAPIInternal, Disposable {\n    /** @internal (will likely be exposed once the API is fully stable) */\n    moveFocus(\n        element: HTMLElement,\n        action: GroupperMoveFocusAction\n    ): HTMLElement | null;\n}\n\nexport interface GroupperAPIInternal {\n    forgetCurrentGrouppers(): void;\n}\n\nexport interface ModalizerProps {\n    id: string;\n    isOthersAccessible?: boolean;\n    isAlwaysAccessible?: boolean;\n    isNoFocusFirst?: boolean;\n    isNoFocusDefault?: boolean;\n    /** A focus trap variant, keeps focus inside the modal when tabbing */\n    isTrapped?: boolean;\n}\n\nexport interface Modalizer\n    extends TabsterPart<ModalizerProps>,\n        TabsterPartWithFindNextTabbable {\n    readonly userId: string;\n    readonly dummyManager: DummyInputManager | undefined;\n    /**\n     * @returns - Whether the element is inside the modalizer\n     */\n    contains(element: HTMLElement): boolean;\n    dispose(): void;\n    isActive(): boolean;\n    makeActive(isActive: boolean): void;\n    focused(noIncrement?: boolean): number;\n}\n\nexport type ModalizerConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: ModalizerProps\n) => Modalizer;\n\nexport interface RootProps {\n    restoreFocusOrder?: RestoreFocusOrder;\n}\n\nexport interface Root extends TabsterPart<RootProps> {\n    /**@internal*/\n    addDummyInputs(): void;\n\n    readonly uid: string;\n    dispose(): void;\n    moveOutWithDefaultAction(\n        backwards: boolean,\n        relatedEvent: KeyboardEvent\n    ): void;\n}\n\nexport type RootConstructor = (\n    tabster: TabsterCore,\n    element: HTMLElement,\n    props: RootProps\n) => Root;\n\nexport const SysDummyInputsPositions = {\n    Auto: 0, // Tabster will place dummy inputs depending on the container tag name and on the default behaviour.\n    Inside: 1, // Tabster will always place dummy inputs inside the container.\n    Outside: 2, // Tabster will always place dummy inputs outside of the container.\n} as const;\n\nexport type SysDummyInputsPosition =\n    typeof SysDummyInputsPositions[keyof typeof SysDummyInputsPositions];\n\n/**\n * Ability to fine-tune Tabster internal behaviour in rare cases of need.\n * Normally, should not be used. A deep understanding of the intention and the effect\n * is required.\n */\nexport interface SysProps {\n    /**\n     * Force dummy input position outside or inside of the element.\n     * By default (when undefined), the position is determined dynamically\n     * (for example inside for <li> elements and outside for <table> elements,\n     * plus a default Groupper/Mover/Modalizer implementation position).\n     * Setting to true will force the dummy inputs to be always outside of the element,\n     * setting to false will force the dummy inputs to be always inside.\n     */\n    dummyInputsPosition?: SysDummyInputsPosition;\n}\n\nexport interface GetTabsterContextOptions {\n    /**\n     * Should visit **all** element ancestors to verify if `dir='rtl'` is set\n     */\n    checkRtl?: boolean;\n    /**\n     * The element to start computing the context from. Useful when dealing\n     * with nested structures. For example, if we have an element inside a groupper\n     * inside another groupper, the `groupper` prop in this element's contexts will\n     * be the inner groupper, but when we pass the inner groupper's parent element\n     * as `referenceElement`, the context groupper will be the outer one. Having\n     * this option simplifies searching for the next tabbable element in the\n     * environment of nested movers and grouppers.\n     */\n    referenceElement?: HTMLElement;\n}\n\nexport type TabsterContextMoverGroupper =\n    | { isMover: true; mover: Mover }\n    | { isMover: false; groupper: Groupper };\n\nexport interface TabsterContext {\n    root: Root;\n    modalizer?: Modalizer;\n    groupper?: Groupper;\n    mover?: Mover;\n    groupperBeforeMover?: boolean;\n    modalizerInGroupper?: Groupper;\n    /**\n     * Whether `dir='rtl'` is set on an ancestor\n     */\n    rtl?: boolean;\n    excludedFromMover?: boolean;\n    uncontrolled?: HTMLElement | null;\n    ignoreKeydown: (e: KeyboardEvent) => boolean;\n}\n\ninterface RootAPIInternal {\n    /**@internal*/\n    createRoot(\n        element: HTMLElement,\n        props: RootProps,\n        sys: SysProps | undefined\n    ): Root;\n    /**@internal*/\n    onRoot(root: Root, removed?: boolean): void;\n    /**@internal*/\n    addDummyInputs(): void;\n}\n\nexport interface RootAPI extends Disposable, RootAPIInternal {}\n\nexport interface UncontrolledAPI {\n    isUncontrolledCompletely(\n        element: HTMLElement,\n        completely: boolean\n    ): boolean;\n}\n\ninterface ModalizerAPIInternal extends TabsterPartWithAcceptElement {\n    /** @internal */\n    activeId: string | undefined; // currently active Modalizer user id.\n    /** @internal */\n    currentIsOthersAccessible: boolean | undefined; // isOthersAccessible value of the currently active Modalizer.\n    /** @internal */\n    activeElements: WeakHTMLElement<HTMLElement>[];\n    /** @internal */\n    createModalizer(\n        element: HTMLElement,\n        props: ModalizerProps,\n        sys: SysProps | undefined\n    ): Modalizer;\n    /**\n     * Sets active modalizers.\n     * When active, everything outside of the modalizers with the specific user\n     * defined id gets `aria-hidden`.\n     *\n     * @param userId user defined identifier or undefined (if nothing is modal).\n     */\n    /** @internal */\n    setActive(modalizer: Modalizer | undefined): void;\n    /** @internal */\n    hiddenUpdate(): void;\n    /** @internal */\n    isAugmented(element: HTMLElement): boolean;\n}\n\nexport interface ModalizerAPI extends ModalizerAPIInternal, Disposable {\n    /**\n     * Activates a Modalizer and focuses the first or default element within\n     *\n     * @param elementFromModalizer An element that belongs to a Modalizer\n     * @param noFocusFirst Do not focus on the first element in the Modalizer\n     * @param noFocusDefault Do not focus the default element in the Modalizre\n     */\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean;\n}\n\ninterface RestorerAPIInternal {\n    /** @internal */\n    createRestorer(element: HTMLElement, props: RestorerProps): Restorer;\n}\n\nexport interface RestorerAPI extends RestorerAPIInternal, Disposable {}\n\nexport interface Restorer extends Disposable, TabsterPart<RestorerProps> {}\n/**\n * A signature for the accessibleCheck callback from getModalizer().\n * It is called when active Modalizer sets aria-hidden on elements outsidef of it.\n *\n * @param element The element that is about to receive aria-hidden.\n * @param activeModalizerElements The container elements of the active modalizer.\n * @returns true if the element should remain accessible and should not receive\n * aria-hidden.\n */\nexport type ModalizerElementAccessibleCheck = (\n    element: HTMLElement,\n    activeModalizerElements?: HTMLElement[]\n) => boolean;\n\nexport interface UncontrolledProps {\n    // Normally, even uncontrolled areas should not be completely uncontrolled\n    // to be able to interact with the rest of the application properly.\n    // For example, if an uncontrolled area implements something like\n    // roving tabindex, it should be uncontrolled inside the area, but it\n    // still should be able to be an organic part of the application.\n    // However, in some cases, third party component might want to be able\n    // to gain full control of the area, for example, if it implements\n    // some custom trap focus logic.\n    // `completely` indicates that uncontrolled area must gain full control over\n    // Tab handling. If not set, Tabster might still handle Tab in the\n    // uncontrolled area, when, for example, there is an inactive Modalizer\n    // (that needs to be skipped) after the last focusable element of the\n    // uncontrolled area.\n    // WARNING: Use with caution, as it might break the normal keyboard navigation\n    // between the uncontrolled area and the rest of the application.\n    completely?: boolean;\n}\n\nexport interface DeloserOnElement {\n    deloser: Deloser;\n}\n\nexport interface RootOnElement {\n    root: Root;\n}\n\nexport interface ModalizerOnElement {\n    modalizer: Modalizer;\n}\n\nexport interface RestorerOnElement {\n    restorer: Restorer;\n}\n\nexport interface FocusableOnElement {\n    focusable: FocusableProps;\n}\n\nexport interface MoverOnElement {\n    mover: Mover;\n}\n\nexport interface GroupperOnElement {\n    groupper: Groupper;\n}\n\nexport interface UncontrolledOnElement {\n    uncontrolled: UncontrolledProps;\n}\n\nexport interface ObservedOnElement {\n    observed: ObservedElementProps;\n}\n\nexport interface OutlineOnElement {\n    outline: OutlinedElementProps;\n}\n\nexport interface SysOnElement {\n    sys: SysProps;\n}\n\nexport interface RestorerProps {\n    type: RestorerType;\n}\n\nexport type TabsterAttributeProps = Partial<{\n    deloser: DeloserProps;\n    root: RootProps;\n    uncontrolled: UncontrolledProps;\n    modalizer: ModalizerProps;\n    focusable: FocusableProps;\n    groupper: GroupperProps;\n    mover: MoverProps;\n    observed: ObservedElementProps;\n    outline: OutlinedElementProps;\n    sys: SysProps;\n    restorer: RestorerProps;\n}>;\n\nexport interface TabsterAttributeOnElement {\n    string: string;\n    object: TabsterAttributeProps;\n}\n\nexport interface TabsterAugmentedAttributes {\n    [name: string]: string | null;\n}\n\nexport type TabsterOnElement = Partial<\n    RootOnElement &\n        DeloserOnElement &\n        ModalizerOnElement &\n        FocusableOnElement &\n        MoverOnElement &\n        GroupperOnElement &\n        ObservedOnElement &\n        OutlineOnElement &\n        UncontrolledOnElement &\n        SysOnElement &\n        RestorerOnElement\n>;\n\nexport interface OutlineElements {\n    container: HTMLDivElement;\n    left: HTMLDivElement;\n    top: HTMLDivElement;\n    right: HTMLDivElement;\n    bottom: HTMLDivElement;\n}\n\nexport interface TabsterElementStorageEntry {\n    tabster?: TabsterOnElement;\n    attr?: TabsterAttributeOnElement;\n    aug?: TabsterAugmentedAttributes;\n}\n\nexport interface TabsterElementStorage {\n    [uid: string]: TabsterElementStorageEntry;\n}\n\nexport type DisposeFunc = () => void;\n\nexport interface InternalAPI {\n    stopObserver(): void;\n    resumeObserver(syncState: boolean): void;\n}\n\nexport interface DummyInputObserver {\n    add(dummy: HTMLElement, callback: () => void): void;\n    remove(dummy: HTMLElement): void;\n    dispose(): void;\n    domChanged?(parent: HTMLElement): void;\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void;\n}\n\ninterface TabsterCoreInternal {\n    /** @internal */\n    groupper?: GroupperAPI;\n    /** @internal */\n    mover?: MoverAPI;\n    /** @internal */\n    outline?: OutlineAPI;\n    /** @internal */\n    deloser?: DeloserAPI;\n    /** @internal */\n    modalizer?: ModalizerAPI;\n    /** @internal */\n    observedElement?: ObservedElementAPI;\n    /** @internal */\n    crossOrigin?: CrossOriginAPI;\n    /** @internal */\n    internal: InternalAPI;\n    /** @internal */\n    restorer?: RestorerAPI;\n\n    /** @internal */\n    _dummyObserver: DummyInputObserver;\n\n    // The version of the tabster package this instance is on\n    /** @internal */\n    _version: string;\n\n    // No operation flag for the debugging purposes\n    /** @internal */\n    _noop: boolean;\n\n    /** @internal */\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): TabsterElementStorageEntry | undefined;\n    /** @internal */\n    getWindow: GetWindow;\n\n    /** @internal */\n    createTabster(noRefCount?: boolean, props?: TabsterCoreProps): Tabster;\n    /** @internal */\n    disposeTabster(wrapper: Tabster, allInstances?: boolean): void;\n    /** @internal */\n    forceCleanup(): void;\n\n    /** @internal */\n    queueInit(callback: () => void): void;\n    /** @internal */\n    drainInitQueue(): void;\n    /** @internal */\n    getParent: (el: Node) => Node | null;\n}\n\nexport interface Tabster {\n    keyboardNavigation: KeyboardNavigationState;\n    focusedElement: FocusedElementState;\n    focusable: FocusableAPI;\n    root: RootAPI;\n    uncontrolled: UncontrolledAPI;\n\n    /** @internal */\n    core: TabsterCore;\n}\n\nexport interface TabsterCore\n    extends Pick<TabsterCoreProps, \"controlTab\" | \"rootDummyInputs\">,\n        Disposable,\n        TabsterCoreInternal,\n        Omit<Tabster, \"core\"> {}\n\nexport interface TabsterCompat {\n    attributeTransform?: <P>(old: P) => TabsterAttributeProps;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterOnElement(\n    tabster: Types.TabsterCore,\n    element: HTMLElement\n): Types.TabsterOnElement | undefined {\n    return tabster.storageEntry(element)?.tabster;\n}\n\nexport function updateTabsterByAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    dispose?: boolean\n): void {\n    const newAttrValue =\n        dispose || tabster._noop\n            ? undefined\n            : element.getAttribute(Types.TabsterAttributeName);\n\n    let entry = tabster.storageEntry(element);\n    let newAttr: Types.TabsterAttributeOnElement | undefined;\n\n    if (newAttrValue) {\n        if (newAttrValue !== entry?.attr?.string) {\n            try {\n                const newValue = JSON.parse(\n                    newAttrValue\n                ) as Types.TabsterAttributeProps;\n\n                if (typeof newValue !== \"object\") {\n                    throw new Error(\n                        `Value is not a JSON object, got '${newAttrValue}'.`\n                    );\n                }\n\n                newAttr = {\n                    string: newAttrValue,\n                    object: newValue,\n                };\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        } else {\n            return;\n        }\n    } else if (!entry) {\n        return;\n    }\n\n    if (!entry) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        entry = tabster.storageEntry(element, true)!;\n    }\n\n    if (!entry.tabster) {\n        entry.tabster = {};\n    }\n\n    const tabsterOnElement = entry.tabster || {};\n    const oldTabsterProps = entry.attr?.object || {};\n    const newTabsterProps = newAttr?.object || {};\n\n    for (const key of Object.keys(\n        oldTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        if (!newTabsterProps[key]) {\n            if (key === \"root\") {\n                const root = tabsterOnElement[key];\n\n                if (root) {\n                    tabster.root.onRoot(root, true);\n                }\n            }\n\n            switch (key) {\n                case \"deloser\":\n                case \"root\":\n                case \"groupper\":\n                case \"modalizer\":\n                case \"restorer\":\n                case \"mover\":\n                    // eslint-disable-next-line no-case-declarations\n                    const part = tabsterOnElement[key];\n                    if (part) {\n                        part.dispose();\n                        delete tabsterOnElement[key];\n                    }\n                    break;\n\n                case \"observed\":\n                    delete tabsterOnElement[key];\n                    if (tabster.observedElement) {\n                        tabster.observedElement.onObservedElementUpdate(\n                            element\n                        );\n                    }\n                    break;\n\n                case \"focusable\":\n                case \"outline\":\n                case \"uncontrolled\":\n                case \"sys\":\n                    delete tabsterOnElement[key];\n                    break;\n            }\n        }\n    }\n\n    for (const key of Object.keys(\n        newTabsterProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const sys = newTabsterProps.sys;\n\n        switch (key) {\n            case \"deloser\":\n                if (tabsterOnElement.deloser) {\n                    tabsterOnElement.deloser.setProps(\n                        newTabsterProps.deloser as Types.DeloserProps\n                    );\n                } else {\n                    if (tabster.deloser) {\n                        tabsterOnElement.deloser =\n                            tabster.deloser.createDeloser(\n                                element,\n                                newTabsterProps.deloser as Types.DeloserProps\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Deloser API used before initialization, please call `getDeloser()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"root\":\n                if (tabsterOnElement.root) {\n                    tabsterOnElement.root.setProps(\n                        newTabsterProps.root as Types.RootProps\n                    );\n                } else {\n                    tabsterOnElement.root = tabster.root.createRoot(\n                        element,\n                        newTabsterProps.root as Types.RootProps,\n                        sys\n                    );\n                }\n                tabster.root.onRoot(tabsterOnElement.root);\n                break;\n\n            case \"modalizer\":\n                if (tabsterOnElement.modalizer) {\n                    tabsterOnElement.modalizer.setProps(\n                        newTabsterProps.modalizer as Types.ModalizerProps\n                    );\n                } else {\n                    if (tabster.modalizer) {\n                        tabsterOnElement.modalizer =\n                            tabster.modalizer.createModalizer(\n                                element,\n                                newTabsterProps.modalizer as Types.ModalizerProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Modalizer API used before initialization, please call `getModalizer()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"restorer\":\n                if (tabsterOnElement.restorer) {\n                    tabsterOnElement.restorer.setProps(\n                        newTabsterProps.restorer as Types.RestorerProps\n                    );\n                } else {\n                    if (tabster.restorer) {\n                        if (newTabsterProps.restorer) {\n                            tabsterOnElement.restorer =\n                                tabster.restorer.createRestorer(\n                                    element,\n                                    newTabsterProps.restorer\n                                );\n                        }\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Restorer API used before initialization, please call `getRestorer()`\"\n                        );\n                    }\n                }\n\n                break;\n\n            case \"focusable\":\n                tabsterOnElement.focusable = newTabsterProps.focusable;\n                break;\n\n            case \"groupper\":\n                if (tabsterOnElement.groupper) {\n                    tabsterOnElement.groupper.setProps(\n                        newTabsterProps.groupper as Types.GroupperProps\n                    );\n                } else {\n                    if (tabster.groupper) {\n                        tabsterOnElement.groupper =\n                            tabster.groupper.createGroupper(\n                                element,\n                                newTabsterProps.groupper as Types.GroupperProps,\n                                sys\n                            );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Groupper API used before initialization, please call `getGroupper()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"mover\":\n                if (tabsterOnElement.mover) {\n                    tabsterOnElement.mover.setProps(\n                        newTabsterProps.mover as Types.MoverProps\n                    );\n                } else {\n                    if (tabster.mover) {\n                        tabsterOnElement.mover = tabster.mover.createMover(\n                            element,\n                            newTabsterProps.mover as Types.MoverProps,\n                            sys\n                        );\n                    } else if (__DEV__) {\n                        console.error(\n                            \"Mover API used before initialization, please call `getMover()`\"\n                        );\n                    }\n                }\n                break;\n\n            case \"observed\":\n                if (tabster.observedElement) {\n                    tabsterOnElement.observed = newTabsterProps.observed;\n                    tabster.observedElement.onObservedElementUpdate(element);\n                } else if (__DEV__) {\n                    console.error(\n                        \"ObservedElement API used before initialization, please call `getObservedElement()`\"\n                    );\n                }\n                break;\n\n            case \"uncontrolled\":\n                tabsterOnElement.uncontrolled = newTabsterProps.uncontrolled;\n                break;\n\n            case \"outline\":\n                if (tabster.outline) {\n                    tabsterOnElement.outline = newTabsterProps.outline;\n                } else if (__DEV__) {\n                    console.error(\n                        \"Outline API used before initialization, please call `getOutline()`\"\n                    );\n                }\n                break;\n\n            case \"sys\":\n                tabsterOnElement.sys = newTabsterProps.sys;\n                break;\n\n            default:\n                console.error(\n                    `Unknown key '${key}' in data-tabster attribute value.`\n                );\n        }\n    }\n\n    if (newAttr) {\n        entry.attr = newAttr;\n    } else {\n        if (Object.keys(tabsterOnElement).length === 0) {\n            delete entry.tabster;\n            delete entry.attr;\n        }\n        tabster.storageEntry(element, false);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\n/**\n * Events sent by Tabster.\n */\n\nexport const TabsterFocusInEventName = \"tabster:focusin\";\nexport const TabsterFocusOutEventName = \"tabster:focusout\";\n\n// Event is dispatched when Tabster wants to move focus as the result of\n// handling keyboard event. This allows to preventDefault() if you want to have\n// some custom logic.\nexport const TabsterMoveFocusEventName = \"tabster:movefocus\";\n\n/**\n * Events sent by Deloser.\n */\n\nexport const DeloserFocusLostEventName = \"tabster:deloser:focus-lost\";\n\n/**\n * Events to be sent to Deloser by the application.\n */\n\nexport const DeloserRestoreFocusEventName = \"tabster:deloser:restore-focus\";\n\n/**\n * Events sent by Modalizer.\n */\nexport const ModalizerActiveEventName = \"tabster:modalizer:active\";\nexport const ModalizerInactiveEventName = \"tabster:modalizer:inactive\";\nexport const ModalizerFocusInEventName = \"tabster:modalizer:focusin\";\nexport const ModalizerFocusOutEventName = \"tabster:modalizer:focusout\";\n\n/**\n * Events sent by Mover.\n */\nexport const MoverStateEventName = \"tabster:mover:state\";\n\n/**\n * Events to be sent to Mover by the application.\n */\n\n// Event that can be dispatched by the application to programmatically move\n// focus inside Mover.\nexport const MoverMoveFocusEventName = \"tabster:mover:movefocus\";\n// Event that can be dispatched by the application to forget or modify\n// memorized element in Mover with memorizeCurrent property.\nexport const MoverMemorizedElementEventName = \"tabster:mover:memorized-element\";\n\n/**\n * Events sent by Groupper.\n */\n\n/**\n * Events to be sent to Groupper by the application.\n */\n\n// Event that can be dispatched by the application to programmatically enter\n// or escape Groupper.\nexport const GroupperMoveFocusEventName = \"tabster:groupper:movefocus\";\n\n/**\n * Events sent by Restorer.\n */\n\nexport const RestorerRestoreFocusEventName = \"tabster:restorer:restore-focus\";\n\n/**\n * Events sent by Root.\n */\nexport const RootFocusEventName = \"tabster:root:focus\";\nexport const RootBlurEventName = \"tabster:root:blur\";\n\n// Node.js environments do not have CustomEvent and it is needed for the events to be\n// evaluated. It doesn't matter if it works or not in Node.js environment.\n// So, we just need to make sure that it doesn't throw undefined reference.\nconst CustomEvent_ =\n    typeof CustomEvent !== \"undefined\"\n        ? CustomEvent\n        : (function () {\n              /* no-op */\n          } as typeof CustomEvent);\n\nexport abstract class TabsterCustomEvent<D> extends CustomEvent_<D> {\n    /**\n     * @deprecated use `detail`.\n     */\n    details?: D;\n\n    constructor(type: string, detail?: D) {\n        super(type, {\n            bubbles: true,\n            cancelable: true,\n            composed: true,\n            detail,\n        });\n\n        this.details = detail;\n    }\n}\n\nexport interface TabsterMoveFocusEventDetail {\n    by: \"mover\" | \"groupper\" | \"modalizer\" | \"root\" | \"deloser\";\n    owner: HTMLElement; // Mover, Groupper, Modalizer or Root, the initiator.\n    next: HTMLElement | null; // Next element to focus or null if Tabster wants to go outside of Root (i.e. to the address bar of the browser).\n    relatedEvent?: KeyboardEvent; // The original keyboard event that triggered the move.\n}\n\nexport class TabsterFocusInEvent extends TabsterCustomEvent<Types.FocusedElementDetail> {\n    constructor(detail: Types.FocusedElementDetail) {\n        super(TabsterFocusInEventName, detail);\n    }\n}\n\nexport class TabsterFocusOutEvent extends TabsterCustomEvent<Types.FocusedElementDetail> {\n    constructor(detail: Types.FocusedElementDetail) {\n        super(TabsterFocusOutEventName, detail);\n    }\n}\n\nexport class TabsterMoveFocusEvent extends TabsterCustomEvent<TabsterMoveFocusEventDetail> {\n    constructor(detail: TabsterMoveFocusEventDetail) {\n        super(TabsterMoveFocusEventName, detail);\n    }\n}\n\nexport class MoverStateEvent extends TabsterCustomEvent<Types.MoverElementState> {\n    constructor(detail: Types.MoverElementState) {\n        super(MoverStateEventName, detail);\n    }\n}\n\nexport type MoverMoveFocusEventDetail = { key: Types.MoverKey };\n\nexport class MoverMoveFocusEvent extends TabsterCustomEvent<MoverMoveFocusEventDetail> {\n    constructor(detail: MoverMoveFocusEventDetail) {\n        super(MoverMoveFocusEventName, detail);\n    }\n}\n\nexport interface MoverMemorizedElementEventDetail {\n    memorizedElement: HTMLElement | undefined;\n}\n\nexport class MoverMemorizedElementEvent extends TabsterCustomEvent<MoverMemorizedElementEventDetail> {\n    constructor(detail: MoverMemorizedElementEventDetail) {\n        super(MoverMemorizedElementEventName, detail);\n    }\n}\n\nexport type GroupperMoveFocusEventDetail = {\n    action: Types.GroupperMoveFocusAction;\n};\n\nexport class GroupperMoveFocusEvent extends TabsterCustomEvent<GroupperMoveFocusEventDetail> {\n    constructor(detail: GroupperMoveFocusEventDetail) {\n        super(GroupperMoveFocusEventName, detail);\n    }\n}\n\nexport type ModalizerEventDetail = {\n    id: string;\n    element: HTMLElement;\n};\n\nexport class ModalizerActiveEvent extends TabsterCustomEvent<ModalizerEventDetail> {\n    constructor(detail: ModalizerEventDetail) {\n        super(ModalizerActiveEventName, detail);\n    }\n}\n\nexport class ModalizerInactiveEvent extends TabsterCustomEvent<ModalizerEventDetail> {\n    constructor(detail: ModalizerEventDetail) {\n        super(ModalizerInactiveEventName, detail);\n    }\n}\n\nexport class DeloserFocusLostEvent extends TabsterCustomEvent<Types.DeloserElementActions> {\n    constructor(detail: Types.DeloserElementActions) {\n        super(DeloserFocusLostEventName, detail);\n    }\n}\n\nexport class DeloserRestoreFocusEvent extends TabsterCustomEvent<undefined> {\n    constructor() {\n        super(DeloserRestoreFocusEventName);\n    }\n}\n\nexport class RestorerRestoreFocusEvent extends TabsterCustomEvent<undefined> {\n    constructor() {\n        super(RestorerRestoreFocusEventName);\n    }\n}\n\nexport interface RootFocusEventDetail {\n    element: HTMLElement;\n}\n\nexport class RootFocusEvent extends TabsterCustomEvent<RootFocusEventDetail> {\n    constructor(detail: RootFocusEventDetail) {\n        super(RootFocusEventName, detail);\n    }\n}\n\nexport class RootBlurEvent extends TabsterCustomEvent<RootFocusEventDetail> {\n    constructor(detail: RootFocusEventDetail) {\n        super(RootBlurEventName, detail);\n    }\n}\n\n// addEventListener() typings augmentation.\ndeclare global {\n    interface GlobalEventHandlersEventMap {\n        [TabsterFocusInEventName]: TabsterFocusInEvent;\n        [TabsterFocusOutEventName]: TabsterFocusOutEvent;\n        [TabsterMoveFocusEventName]: TabsterMoveFocusEvent;\n\n        [MoverStateEventName]: MoverStateEvent;\n        [MoverMoveFocusEventName]: MoverMoveFocusEvent;\n        [MoverMemorizedElementEventName]: MoverMemorizedElementEvent;\n\n        [GroupperMoveFocusEventName]: GroupperMoveFocusEvent;\n\n        [ModalizerActiveEventName]: ModalizerActiveEvent;\n        [ModalizerInactiveEventName]: ModalizerInactiveEvent;\n\n        [DeloserFocusLostEventName]: DeloserFocusLostEvent;\n        [DeloserRestoreFocusEventName]: DeloserRestoreFocusEvent;\n\n        [RestorerRestoreFocusEventName]: RestorerRestoreFocusEvent;\n\n        [RootFocusEventName]: RootFocusEvent;\n        [RootBlurEventName]: RootBlurEvent;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { DOMAPI } from \"./Types\";\n\nconst _createMutationObserver = (callback: MutationCallback) =>\n    new MutationObserver(callback);\nconst _createTreeWalker = (\n    doc: Document,\n    root: Node,\n    whatToShow?: number,\n    filter?: NodeFilter | null\n) => doc.createTreeWalker(root, whatToShow, filter);\nconst _getParentNode = (node: Node | null | undefined) =>\n    node ? node.parentNode : null;\nconst _getParentElement = (element: HTMLElement) =>\n    element ? element.parentElement : null;\nconst _nodeContains = (\n    parent: Node | null | undefined,\n    child: Node | null | undefined\n) => !!(child && parent?.contains(child));\nconst _getActiveElement = (doc: Document) => doc.activeElement;\nconst _querySelector = (element: Element, selector: string) =>\n    element.querySelector(selector);\nconst _querySelectorAll = (element: ParentNode, selector: string) =>\n    Array.prototype.slice.call(element.querySelectorAll(selector), 0);\nconst _getElementById = (doc: Document, id: string): HTMLElement | null =>\n    doc.getElementById(id);\nconst _getFirstChild = (node: Node | null | undefined): ChildNode | null =>\n    node?.firstChild || null;\nconst _getLastChild = (node: Node | null | undefined): ChildNode | null =>\n    node?.lastChild || null;\nconst _getNextSibling = (node: Node | null | undefined): ChildNode | null =>\n    node?.nextSibling || null;\nconst _getPreviousSibling = (node: Node | null | undefined): ChildNode | null =>\n    node?.previousSibling || null;\nconst _getFirstElementChild = (\n    element: Element | null | undefined\n): Element | null => element?.firstElementChild || null;\nconst _getLastElementChild = (\n    element: Element | null | undefined\n): Element | null => element?.lastElementChild || null;\nconst _getNextElementSibling = (\n    element: Element | null | undefined\n): Element | null => element?.nextElementSibling || null;\nconst _getPreviousElementSibling = (\n    element: Element | null | undefined\n): Element | null => element?.previousElementSibling || null;\nconst _appendChild = (parent: Node, child: Node): Node =>\n    parent.appendChild(child);\nconst _insertBefore = (\n    parent: Node,\n    child: Node,\n    referenceChild: Node | null\n): Node => parent.insertBefore(child, referenceChild);\nconst _getSelection = (ref: Node): Selection | null =>\n    ref.ownerDocument?.getSelection() || null;\n\nexport const dom: DOMAPI = {\n    createMutationObserver: _createMutationObserver,\n    createTreeWalker: _createTreeWalker,\n    getParentNode: _getParentNode,\n    getParentElement: _getParentElement,\n    nodeContains: _nodeContains,\n    getActiveElement: _getActiveElement,\n    querySelector: _querySelector,\n    querySelectorAll: _querySelectorAll,\n    getElementById: _getElementById,\n    getFirstChild: _getFirstChild,\n    getLastChild: _getLastChild,\n    getNextSibling: _getNextSibling,\n    getPreviousSibling: _getPreviousSibling,\n    getFirstElementChild: _getFirstElementChild,\n    getLastElementChild: _getLastElementChild,\n    getNextElementSibling: _getNextElementSibling,\n    getPreviousElementSibling: _getPreviousElementSibling,\n    appendChild: _appendChild,\n    insertBefore: _insertBefore,\n    getSelection: _getSelection,\n};\n\nexport function setDOMAPI(domapi: Partial<DOMAPI>) {\n    for (const key of Object.keys(domapi) as (keyof DOMAPI)[]) {\n        (dom[key] as typeof domapi[typeof key]) = domapi[key];\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport * as Types from \"./Types\";\nimport { GetWindow, Visibilities, Visibility } from \"./Types\";\nimport { TabsterMoveFocusEvent } from \"./Events\";\nimport { dom } from \"./DOMAPI\";\n\ninterface HTMLElementWithBoundingRectCacheId extends HTMLElement {\n    __tabsterCacheId?: string;\n}\n\ninterface FocusedElementWithIgnoreFlag extends HTMLElement {\n    __shouldIgnoreFocus: boolean;\n}\n\nexport interface WindowWithUID extends Window {\n    __tabsterCrossOriginWindowUID?: string;\n}\n\nexport interface HTMLElementWithUID extends HTMLElement {\n    __tabsterElementUID?: string;\n}\n\nexport interface HTMLElementWithDummyContainer extends HTMLElement {\n    __tabsterDummyContainer?: WeakHTMLElement;\n}\n\nexport interface TabsterDOMRect {\n    bottom: number;\n    left: number;\n    right: number;\n    top: number;\n}\n\nexport interface InstanceContext {\n    elementByUId: { [uid: string]: WeakHTMLElement<HTMLElementWithUID> };\n    basics: InternalBasics;\n    WeakRef?: WeakRefConstructor;\n    containerBoundingRectCache: {\n        [id: string]: {\n            rect: TabsterDOMRect;\n            element: HTMLElementWithBoundingRectCacheId;\n        };\n    };\n    lastContainerBoundingRectCacheId: number;\n    containerBoundingRectCacheTimer?: number;\n    fakeWeakRefs: TabsterWeakRef<unknown>[];\n    fakeWeakRefsTimer?: number;\n    fakeWeakRefsStarted: boolean;\n}\n\nlet _isBrokenIE11: boolean;\n\nconst _DOMRect =\n    typeof DOMRect !== \"undefined\"\n        ? DOMRect\n        : class {\n              readonly bottom: number;\n              readonly left: number;\n              readonly right: number;\n              readonly top: number;\n\n              constructor(\n                  x?: number,\n                  y?: number,\n                  width?: number,\n                  height?: number\n              ) {\n                  this.left = x || 0;\n                  this.top = y || 0;\n                  this.right = (x || 0) + (width || 0);\n                  this.bottom = (y || 0) + (height || 0);\n              }\n          };\n\nlet _uidCounter = 0;\n\ntry {\n    // IE11 only accepts `filter` argument as a function (not object with the `acceptNode`\n    // property as the docs define). Also `entityReferenceExpansion` argument is not\n    // optional. And it throws exception when the above arguments aren't there.\n    document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT);\n    _isBrokenIE11 = false;\n} catch (e) {\n    _isBrokenIE11 = true;\n}\n\nconst _updateDummyInputsTimeout = 100;\n\ninterface WindowWithUtilsConext extends Window {\n    __tabsterInstanceContext?: InstanceContext;\n    Promise: PromiseConstructor;\n    WeakRef: WeakRefConstructor;\n}\n\nexport function getInstanceContext(getWindow: GetWindow): InstanceContext {\n    const win = getWindow() as WindowWithUtilsConext;\n\n    let ctx = win.__tabsterInstanceContext;\n\n    if (!ctx) {\n        ctx = {\n            elementByUId: {},\n            basics: {\n                Promise: win.Promise || undefined,\n                WeakRef: win.WeakRef || undefined,\n            },\n            containerBoundingRectCache: {},\n            lastContainerBoundingRectCacheId: 0,\n            fakeWeakRefs: [],\n            fakeWeakRefsStarted: false,\n        };\n\n        win.__tabsterInstanceContext = ctx;\n    }\n\n    return ctx;\n}\n\nexport function disposeInstanceContext(win: Window): void {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n\n    if (ctx) {\n        ctx.elementByUId = {};\n\n        delete ctx.WeakRef;\n\n        ctx.containerBoundingRectCache = {};\n\n        if (ctx.containerBoundingRectCacheTimer) {\n            win.clearTimeout(ctx.containerBoundingRectCacheTimer);\n        }\n\n        if (ctx.fakeWeakRefsTimer) {\n            win.clearTimeout(ctx.fakeWeakRefsTimer);\n        }\n\n        ctx.fakeWeakRefs = [];\n\n        delete (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    }\n}\n\nexport function createWeakMap<K extends object, V>(win: Window): WeakMap<K, V> {\n    const ctx = (win as WindowWithUtilsConext).__tabsterInstanceContext;\n    return new (ctx?.basics.WeakMap || WeakMap)();\n}\n\nexport function hasSubFocusable(element: HTMLElement): boolean {\n    return !!element.querySelector(Types.FocusableSelector);\n}\n\ninterface TabsterWeakRef<T> {\n    deref(): T | undefined;\n}\n\nclass FakeWeakRef<T extends HTMLElement = HTMLElement>\n    implements TabsterWeakRef<T>\n{\n    private _target: T | undefined;\n\n    constructor(target: T) {\n        this._target = target;\n    }\n\n    deref(): T | undefined {\n        return this._target;\n    }\n\n    static cleanup(fwr: FakeWeakRef, forceRemove?: boolean): boolean {\n        if (!fwr._target) {\n            return true;\n        }\n\n        if (\n            forceRemove ||\n            !documentContains(fwr._target.ownerDocument, fwr._target)\n        ) {\n            delete fwr._target;\n            return true;\n        }\n\n        return false;\n    }\n}\n\nexport class WeakHTMLElement<T extends HTMLElement = HTMLElement, D = undefined>\n    implements Types.WeakHTMLElement<D>\n{\n    private _ref: TabsterWeakRef<T> | undefined;\n    private _data: D | undefined;\n\n    constructor(getWindow: GetWindow, element: T, data?: D) {\n        const context = getInstanceContext(getWindow);\n\n        let ref: TabsterWeakRef<T>;\n        if (context.WeakRef) {\n            ref = new context.WeakRef(element);\n        } else {\n            ref = new FakeWeakRef(element);\n            context.fakeWeakRefs.push(ref);\n        }\n\n        this._ref = ref;\n        this._data = data;\n    }\n\n    get(): T | undefined {\n        const ref = this._ref;\n        let element: T | undefined;\n\n        if (ref) {\n            element = ref.deref();\n\n            if (!element) {\n                delete this._ref;\n            }\n        }\n\n        return element;\n    }\n\n    getData(): D | undefined {\n        return this._data;\n    }\n}\n\nexport function cleanupFakeWeakRefs(\n    getWindow: GetWindow,\n    forceRemove?: boolean\n): void {\n    const context = getInstanceContext(getWindow);\n    context.fakeWeakRefs = context.fakeWeakRefs.filter(\n        (e) => !FakeWeakRef.cleanup(e as FakeWeakRef, forceRemove)\n    );\n}\n\nexport function startFakeWeakRefsCleanup(getWindow: GetWindow): void {\n    const context = getInstanceContext(getWindow);\n\n    if (!context.fakeWeakRefsStarted) {\n        context.fakeWeakRefsStarted = true;\n        context.WeakRef = getWeakRef(context);\n    }\n\n    if (!context.fakeWeakRefsTimer) {\n        context.fakeWeakRefsTimer = getWindow().setTimeout(() => {\n            context.fakeWeakRefsTimer = undefined;\n            cleanupFakeWeakRefs(getWindow);\n            startFakeWeakRefsCleanup(getWindow);\n        }, 2 * 60 * 1000); // 2 minutes.\n    }\n}\n\nexport function stopFakeWeakRefsCleanupAndClearStorage(\n    getWindow: GetWindow\n): void {\n    const context = getInstanceContext(getWindow);\n\n    context.fakeWeakRefsStarted = false;\n\n    if (context.fakeWeakRefsTimer) {\n        getWindow().clearTimeout(context.fakeWeakRefsTimer);\n        context.fakeWeakRefsTimer = undefined;\n        context.fakeWeakRefs = [];\n    }\n}\n\nexport function createElementTreeWalker(\n    doc: Document,\n    root: Node,\n    acceptNode: (node: Node) => number\n): TreeWalker | undefined {\n    // IE11 will throw an exception when the TreeWalker root is not an Element.\n    if (root.nodeType !== Node.ELEMENT_NODE) {\n        return undefined;\n    }\n\n    // TypeScript isn't aware of IE11 behaving badly.\n    const filter = (_isBrokenIE11\n        ? acceptNode\n        : ({ acceptNode } as NodeFilter)) as unknown as NodeFilter;\n\n    return dom.createTreeWalker(\n        doc,\n        root,\n        NodeFilter.SHOW_ELEMENT,\n        filter,\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore: We still don't want to completely break IE11, so, entityReferenceExpansion argument is not optional.\n        false /* Last argument is not optional for IE11! */\n    );\n}\n\nexport function getBoundingRect(\n    getWindow: GetWindow,\n    element: HTMLElementWithBoundingRectCacheId\n): TabsterDOMRect {\n    let cacheId = element.__tabsterCacheId;\n    const context = getInstanceContext(getWindow);\n    const cached = cacheId\n        ? context.containerBoundingRectCache[cacheId]\n        : undefined;\n\n    if (cached) {\n        return cached.rect;\n    }\n\n    const scrollingElement =\n        element.ownerDocument && element.ownerDocument.documentElement;\n\n    if (!scrollingElement) {\n        return new _DOMRect();\n    }\n\n    // A bounding rect of the top-level element contains the whole page regardless of the\n    // scrollbar. So, we improvise a little and limiting the final result...\n    let left = 0;\n    let top = 0;\n    let right = scrollingElement.clientWidth;\n    let bottom = scrollingElement.clientHeight;\n\n    if (element !== scrollingElement) {\n        const r = element.getBoundingClientRect();\n        left = Math.max(left, r.left);\n        top = Math.max(top, r.top);\n        right = Math.min(right, r.right);\n        bottom = Math.min(bottom, r.bottom);\n    }\n\n    const rect = new _DOMRect(\n        left < right ? left : -1,\n        top < bottom ? top : -1,\n        left < right ? right - left : 0,\n        top < bottom ? bottom - top : 0\n    );\n\n    if (!cacheId) {\n        cacheId = \"r-\" + ++context.lastContainerBoundingRectCacheId;\n        element.__tabsterCacheId = cacheId;\n    }\n\n    context.containerBoundingRectCache[cacheId] = {\n        rect,\n        element,\n    };\n\n    if (!context.containerBoundingRectCacheTimer) {\n        context.containerBoundingRectCacheTimer = window.setTimeout(() => {\n            context.containerBoundingRectCacheTimer = undefined;\n\n            for (const cId of Object.keys(context.containerBoundingRectCache)) {\n                delete context.containerBoundingRectCache[cId].element\n                    .__tabsterCacheId;\n            }\n\n            context.containerBoundingRectCache = {};\n        }, 50);\n    }\n\n    return rect;\n}\n\nexport function isElementVerticallyVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    tolerance: number\n): boolean {\n    const container = getScrollableContainer(element);\n    if (!container) {\n        return false;\n    }\n\n    const containerRect = getBoundingRect(getWindow, container);\n    const elementRect = element.getBoundingClientRect();\n    const intersectionTolerance = elementRect.height * (1 - tolerance);\n    const topIntersection = Math.max(0, containerRect.top - elementRect.top);\n    const bottomIntersection = Math.max(\n        0,\n        elementRect.bottom - containerRect.bottom\n    );\n    const totalIntersection = topIntersection + bottomIntersection;\n\n    return (\n        totalIntersection === 0 || totalIntersection <= intersectionTolerance\n    );\n}\n\nexport function isElementVisibleInContainer(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    gap = 0\n): Visibility {\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (\n            elementRect.left > containerRect.right ||\n            elementRect.top > containerRect.bottom ||\n            elementRect.bottom < containerRect.top ||\n            elementRect.right < containerRect.left\n        ) {\n            return Visibilities.Invisible;\n        }\n\n        if (\n            elementRect.top + gap >= containerRect.top &&\n            elementRect.top <= containerRect.bottom &&\n            elementRect.bottom >= containerRect.top &&\n            elementRect.bottom - gap <= containerRect.bottom &&\n            elementRect.left + gap >= containerRect.left &&\n            elementRect.left <= containerRect.right &&\n            elementRect.right >= containerRect.left &&\n            elementRect.right - gap <= containerRect.right\n        ) {\n            return Visibilities.Visible;\n        }\n\n        return Visibilities.PartiallyVisible;\n    }\n\n    return Visibilities.Invisible;\n}\n\nexport function scrollIntoView(\n    getWindow: GetWindow,\n    element: HTMLElement,\n    alignToTop: boolean\n): void {\n    // Built-in DOM's scrollIntoView() is cool, but when we have nested containers,\n    // it scrolls all of them, not just the deepest one. So, trying to work it around.\n    const container = getScrollableContainer(element);\n\n    if (container) {\n        const containerRect = getBoundingRect(getWindow, container);\n        const elementRect = element.getBoundingClientRect();\n\n        if (alignToTop) {\n            container.scrollTop += elementRect.top - containerRect.top;\n        } else {\n            container.scrollTop += elementRect.bottom - containerRect.bottom;\n        }\n    }\n}\n\nexport function getScrollableContainer(\n    element: HTMLElement\n): HTMLElement | null {\n    const doc = element.ownerDocument;\n\n    if (doc) {\n        for (\n            let el: HTMLElement | null = dom.getParentElement(element);\n            el;\n            el = dom.getParentElement(el)\n        ) {\n            if (\n                el.scrollWidth > el.clientWidth ||\n                el.scrollHeight > el.clientHeight\n            ) {\n                return el;\n            }\n        }\n\n        return doc.documentElement;\n    }\n\n    return null;\n}\n\nexport function makeFocusIgnored(element: HTMLElement): void {\n    (element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus = true;\n}\n\nexport function shouldIgnoreFocus(element: HTMLElement): boolean {\n    return !!(element as FocusedElementWithIgnoreFlag).__shouldIgnoreFocus;\n}\n\nexport function getUId(wnd: Window & { msCrypto?: Crypto }): string {\n    const rnd = new Uint32Array(4);\n\n    if (wnd.crypto && wnd.crypto.getRandomValues) {\n        wnd.crypto.getRandomValues(rnd);\n    } else if (wnd.msCrypto && wnd.msCrypto.getRandomValues) {\n        wnd.msCrypto.getRandomValues(rnd);\n    } else {\n        for (let i = 0; i < rnd.length; i++) {\n            rnd[i] = 0xffffffff * Math.random();\n        }\n    }\n\n    const srnd: string[] = [];\n\n    for (let i = 0; i < rnd.length; i++) {\n        srnd.push(rnd[i].toString(36));\n    }\n\n    srnd.push(\"|\");\n    srnd.push((++_uidCounter).toString(36));\n    srnd.push(\"|\");\n    srnd.push(Date.now().toString(36));\n\n    return srnd.join(\"\");\n}\n\nexport function getElementUId(\n    getWindow: GetWindow,\n    element: HTMLElementWithUID\n): string {\n    const context = getInstanceContext(getWindow);\n    let uid = element.__tabsterElementUID;\n\n    if (!uid) {\n        uid = element.__tabsterElementUID = getUId(getWindow());\n    }\n\n    if (\n        !context.elementByUId[uid] &&\n        documentContains(element.ownerDocument, element)\n    ) {\n        context.elementByUId[uid] = new WeakHTMLElement(getWindow, element);\n    }\n\n    return uid;\n}\n\nexport function getElementByUId(\n    context: InstanceContext,\n    uid: string\n): WeakHTMLElement<HTMLElementWithUID, undefined> | undefined {\n    return context.elementByUId[uid];\n}\n\nexport function getWindowUId(win: WindowWithUID): string {\n    let uid = win.__tabsterCrossOriginWindowUID;\n\n    if (!uid) {\n        uid = win.__tabsterCrossOriginWindowUID = getUId(win);\n    }\n\n    return uid;\n}\n\nexport function clearElementCache(\n    getWindow: GetWindow,\n    parent?: HTMLElement\n): void {\n    const context = getInstanceContext(getWindow);\n\n    for (const key of Object.keys(context.elementByUId)) {\n        const wel = context.elementByUId[key];\n        const el = wel && wel.get();\n\n        if (el && parent) {\n            if (!dom.nodeContains(parent, el)) {\n                continue;\n            }\n        }\n\n        delete context.elementByUId[key];\n    }\n}\n\n// IE11 doesn't have document.contains()...\nexport function documentContains(\n    doc: HTMLDocument | null | undefined,\n    element: HTMLElement\n): boolean {\n    return dom.nodeContains(doc?.body, element);\n}\n\nexport function matchesSelector(\n    element: HTMLElement,\n    selector: string\n): boolean {\n    interface HTMLElementWithMatches extends HTMLElement {\n        matchesSelector?: typeof HTMLElement.prototype.matches;\n        msMatchesSelector?: typeof HTMLElement.prototype.matches;\n    }\n\n    const matches =\n        element.matches ||\n        (element as HTMLElementWithMatches).matchesSelector ||\n        (element as HTMLElementWithMatches).msMatchesSelector ||\n        element.webkitMatchesSelector;\n\n    return matches && matches.call(element, selector);\n}\n\nexport function getPromise(getWindow: GetWindow): PromiseConstructor {\n    const context = getInstanceContext(getWindow);\n    if (context.basics.Promise) {\n        return context.basics.Promise;\n    }\n\n    throw new Error(\"No Promise defined.\");\n}\n\nexport function getWeakRef(\n    context: InstanceContext\n): WeakRefConstructor | undefined {\n    return context.basics.WeakRef;\n}\n\ninterface InternalBasics {\n    Promise?: PromiseConstructor;\n    WeakRef?: WeakRefConstructor;\n    WeakMap?: WeakMapConstructor;\n}\n\nexport function setBasics(win: Window, basics: InternalBasics): void {\n    const context = getInstanceContext(() => win);\n\n    let key: keyof InternalBasics;\n\n    key = \"Promise\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakRef\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n\n    key = \"WeakMap\";\n    if (key in basics) {\n        context.basics[key] = basics[key];\n    }\n}\n\nlet _lastTabsterPartId = 0;\n\nexport abstract class TabsterPart<P, D = undefined>\n    implements Types.TabsterPart<P>\n{\n    protected _tabster: Types.TabsterCore;\n    protected _element: WeakHTMLElement<HTMLElement, D>;\n    protected _props: P;\n\n    readonly id: string;\n\n    constructor(tabster: Types.TabsterCore, element: HTMLElement, props: P) {\n        const getWindow = tabster.getWindow;\n        this._tabster = tabster;\n        this._element = new WeakHTMLElement(getWindow, element);\n        this._props = { ...props };\n        this.id = \"i\" + ++_lastTabsterPartId;\n    }\n\n    getElement(): HTMLElement | undefined {\n        return this._element.get();\n    }\n\n    getProps(): P {\n        return this._props;\n    }\n\n    setProps(props: P): void {\n        this._props = { ...props };\n    }\n}\n\nexport interface DummyInputProps {\n    /** The input is created to be used only once and autoremoved when focused. */\n    isPhantom?: boolean;\n    /** Whether the input is before or after the content it is guarding.  */\n    isFirst: boolean;\n}\n\nexport type DummyInputFocusCallback = (\n    dummyInput: DummyInput,\n    isBackward: boolean,\n    relatedTarget: HTMLElement | null\n) => void;\n\n/**\n * Dummy HTML elements that are used as focus sentinels for the DOM enclosed within them\n */\nexport class DummyInput {\n    private _isPhantom: DummyInputProps[\"isPhantom\"];\n    private _fixedTarget?: WeakHTMLElement;\n    private _disposeTimer: number | undefined;\n    private _clearDisposeTimeout: (() => void) | undefined;\n\n    input: HTMLElement | undefined;\n    useDefaultAction?: boolean;\n    isFirst: DummyInputProps[\"isFirst\"];\n    isOutside: boolean;\n    /** Called when the input is focused */\n    onFocusIn?: DummyInputFocusCallback;\n    /** Called when the input is blurred */\n    onFocusOut?: DummyInputFocusCallback;\n\n    constructor(\n        getWindow: Types.GetWindow,\n        isOutside: boolean,\n        props: DummyInputProps,\n        element?: WeakHTMLElement,\n        fixedTarget?: WeakHTMLElement\n    ) {\n        const win = getWindow();\n        const input = win.document.createElement(\"i\");\n\n        input.tabIndex = 0;\n        input.setAttribute(\"role\", \"none\");\n\n        input.setAttribute(Types.TabsterDummyInputAttributeName, \"\");\n        input.setAttribute(\"aria-hidden\", \"true\");\n\n        const style = input.style;\n        style.position = \"fixed\";\n        style.width = style.height = \"1px\";\n        style.opacity = \"0.001\";\n        style.zIndex = \"-1\";\n        style.setProperty(\"content-visibility\", \"hidden\");\n\n        makeFocusIgnored(input);\n\n        this.input = input;\n        this.isFirst = props.isFirst;\n        this.isOutside = isOutside;\n        this._isPhantom = props.isPhantom ?? false;\n        this._fixedTarget = fixedTarget;\n\n        input.addEventListener(\"focusin\", this._focusIn);\n        input.addEventListener(\"focusout\", this._focusOut);\n\n        (input as HTMLElementWithDummyContainer).__tabsterDummyContainer =\n            element;\n\n        if (this._isPhantom) {\n            this._disposeTimer = win.setTimeout(() => {\n                delete this._disposeTimer;\n                this.dispose();\n            }, 0);\n\n            this._clearDisposeTimeout = () => {\n                if (this._disposeTimer) {\n                    win.clearTimeout(this._disposeTimer);\n                    delete this._disposeTimer;\n                }\n\n                delete this._clearDisposeTimeout;\n            };\n        }\n    }\n\n    dispose(): void {\n        if (this._clearDisposeTimeout) {\n            this._clearDisposeTimeout();\n        }\n\n        const input = this.input;\n\n        if (!input) {\n            return;\n        }\n\n        delete this._fixedTarget;\n        delete this.onFocusIn;\n        delete this.onFocusOut;\n        delete this.input;\n\n        input.removeEventListener(\"focusin\", this._focusIn);\n        input.removeEventListener(\"focusout\", this._focusOut);\n\n        delete (input as HTMLElementWithDummyContainer).__tabsterDummyContainer;\n\n        dom.getParentNode(input)?.removeChild(input);\n    }\n\n    setTopLeft(top: number, left: number): void {\n        const style = this.input?.style;\n\n        if (style) {\n            style.top = `${top}px`;\n            style.left = `${left}px`;\n        }\n    }\n\n    private _isBackward(\n        isIn: boolean,\n        current: HTMLElement,\n        previous: HTMLElement | null\n    ): boolean {\n        return isIn && !previous\n            ? !this.isFirst\n            : !!(\n                  previous &&\n                  current.compareDocumentPosition(previous) &\n                      Node.DOCUMENT_POSITION_FOLLOWING\n              );\n    }\n\n    private _focusIn = (e: FocusEvent): void => {\n        if (this._fixedTarget) {\n            const target = this._fixedTarget.get();\n\n            if (target) {\n                nativeFocus(target);\n            }\n\n            return;\n        }\n\n        const input = this.input;\n\n        if (this.onFocusIn && input) {\n            const relatedTarget = e.relatedTarget as HTMLElement | null;\n\n            this.onFocusIn(\n                this,\n                this._isBackward(true, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n\n    private _focusOut = (e: FocusEvent): void => {\n        if (this._fixedTarget) {\n            return;\n        }\n\n        this.useDefaultAction = false;\n\n        const input = this.input;\n\n        if (this.onFocusOut && input) {\n            const relatedTarget = e.relatedTarget as HTMLElement | null;\n\n            this.onFocusOut(\n                this,\n                this._isBackward(false, input, relatedTarget),\n                relatedTarget\n            );\n        }\n    };\n}\n\ninterface HTMLElementWithDummyInputs extends HTMLElement {\n    __tabsterDummy?: DummyInputManagerCore;\n}\n\nexport const DummyInputManagerPriorities = {\n    Root: 1,\n    Modalizer: 2,\n    Mover: 3,\n    Groupper: 4,\n};\n\nexport class DummyInputManager {\n    private _instance?: DummyInputManagerCore;\n    private _onFocusIn?: DummyInputFocusCallback;\n    private _onFocusOut?: DummyInputFocusCallback;\n    protected _element: WeakHTMLElement;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        this._element = element;\n\n        this._instance = new DummyInputManagerCore(\n            tabster,\n            element,\n            this,\n            priority,\n            sys,\n            outsideByDefault,\n            callForDefaultAction\n        );\n    }\n\n    protected _setHandlers(\n        onFocusIn?: DummyInputFocusCallback,\n        onFocusOut?: DummyInputFocusCallback\n    ): void {\n        this._onFocusIn = onFocusIn;\n        this._onFocusOut = onFocusOut;\n    }\n\n    moveOut(backwards: boolean): void {\n        this._instance?.moveOut(backwards);\n    }\n\n    moveOutWithDefaultAction(\n        backwards: boolean,\n        relatedEvent: KeyboardEvent\n    ): void {\n        this._instance?.moveOutWithDefaultAction(backwards, relatedEvent);\n    }\n\n    getHandler(isIn: boolean): DummyInputFocusCallback | undefined {\n        return isIn ? this._onFocusIn : this._onFocusOut;\n    }\n\n    setTabbable(tabbable: boolean) {\n        this._instance?.setTabbable(this, tabbable);\n    }\n\n    dispose(): void {\n        if (this._instance) {\n            this._instance.dispose(this);\n            delete this._instance;\n        }\n\n        delete this._onFocusIn;\n        delete this._onFocusOut;\n    }\n\n    static moveWithPhantomDummy(\n        tabster: Types.TabsterCore,\n        element: HTMLElement, // The target element to move to or out of.\n        moveOutOfElement: boolean, // Whether to move out of the element or into it.\n        isBackward: boolean, // Are we tabbing of shift-tabbing?\n        relatedEvent: KeyboardEvent // The event that triggered the move.\n    ): void {\n        // Phantom dummy is a hack to use browser's default action to move\n        // focus from a specific point in the application to the next/previous\n        // element. Default action is needed because next focusable element\n        // is not always available to focus directly (for example, next focusable\n        // is inside isolated iframe) or for uncontrolled areas we want to make\n        // sure that something that controls it takes care of the focusing.\n        // It works in a way that during the Tab key handling, we create a dummy\n        // input element, place it to the specific place in the DOM and focus it,\n        // then the default action of the Tab press will move focus from our dummy\n        // input. And we remove it from the DOM right after that.\n        const dummy: DummyInput = new DummyInput(tabster.getWindow, true, {\n            isPhantom: true,\n            isFirst: true,\n        });\n\n        const input = dummy.input;\n\n        if (input) {\n            let parent: HTMLElement | null;\n            let insertBefore: HTMLElementWithDummyContainer | null;\n\n            // Let's say we have a following DOM structure:\n            // <div>\n            //   <button>Button1</button>\n            //   <div id=\"uncontrolled\" data-tabster={uncontrolled: {}}>\n            //     <button>Button2</button>\n            //     <button>Button3</button>\n            //   </div>\n            //   <button>Button4</button>\n            // </div>\n            //\n            // We pass the \"uncontrolled\" div as the element to move to or out of.\n            //\n            // When we pass moveOutOfElement=true and isBackward=false,\n            // the phantom dummy input will be inserted before Button4.\n            //\n            // When we pass moveOutOfElement=true and isBackward=true, there are\n            // two cases. If the uncontrolled element is focusable (has tabindex=0),\n            // the phantom dummy input will be inserted after Button1. If the\n            // uncontrolled element is not focusable, the phantom dummy input will be\n            // inserted before Button2.\n            //\n            // When we pass moveOutOfElement=false and isBackward=false, the\n            // phantom dummy input will be inserted after Button1.\n            //\n            // When we pass moveOutOfElement=false and isBackward=true, the phantom\n            // dummy input will be inserted before Button4.\n            //\n            // And we have a corner case for <body> and we make sure that the inserted\n            // dummy is inserted properly when there are existing permanent dummies.\n\n            if (element.tagName === \"BODY\") {\n                // We cannot insert elements outside of BODY.\n                parent = element;\n                insertBefore =\n                    (moveOutOfElement && isBackward) ||\n                    (!moveOutOfElement && !isBackward)\n                        ? (dom.getFirstElementChild(\n                              element\n                          ) as HTMLElement | null)\n                        : null;\n            } else {\n                if (\n                    moveOutOfElement &&\n                    (!isBackward ||\n                        (isBackward &&\n                            !tabster.focusable.isFocusable(\n                                element,\n                                false,\n                                true,\n                                true\n                            )))\n                ) {\n                    parent = element;\n                    insertBefore = isBackward\n                        ? (element.firstElementChild as HTMLElementWithDummyContainer | null)\n                        : null;\n                } else {\n                    parent = dom.getParentElement(element);\n                    insertBefore =\n                        (moveOutOfElement && isBackward) ||\n                        (!moveOutOfElement && !isBackward)\n                            ? element\n                            : (dom.getNextElementSibling(\n                                  element\n                              ) as HTMLElement | null);\n                }\n\n                let potentialDummy: HTMLElementWithDummyContainer | null;\n                let dummyFor: HTMLElement | undefined;\n\n                do {\n                    // This is a safety pillow for the cases when someone, combines\n                    // groupper with uncontrolled on the same node. Which is technically\n                    // not correct, but moving into the container element via its dummy\n                    // input would produce a correct behaviour in uncontrolled mode.\n                    potentialDummy = (\n                        (moveOutOfElement && isBackward) ||\n                        (!moveOutOfElement && !isBackward)\n                            ? dom.getPreviousElementSibling(insertBefore)\n                            : insertBefore\n                    ) as HTMLElementWithDummyContainer | null;\n\n                    dummyFor = potentialDummy?.__tabsterDummyContainer?.get();\n\n                    if (dummyFor === element) {\n                        insertBefore =\n                            (moveOutOfElement && isBackward) ||\n                            (!moveOutOfElement && !isBackward)\n                                ? potentialDummy\n                                : (dom.getNextElementSibling(\n                                      potentialDummy\n                                  ) as HTMLElement | null);\n                    } else {\n                        dummyFor = undefined;\n                    }\n                } while (dummyFor);\n            }\n\n            if (\n                parent?.dispatchEvent(\n                    new TabsterMoveFocusEvent({\n                        by: \"root\",\n                        owner: parent,\n                        next: null,\n                        relatedEvent,\n                    })\n                )\n            ) {\n                dom.insertBefore(parent, input, insertBefore);\n                nativeFocus(input);\n            }\n        }\n    }\n\n    static addPhantomDummyWithTarget(\n        tabster: Types.TabsterCore,\n        sourceElement: HTMLElement,\n        isBackward: boolean,\n        targetElement: HTMLElement\n    ): void {\n        const dummy: DummyInput = new DummyInput(\n            tabster.getWindow,\n            true,\n            {\n                isPhantom: true,\n                isFirst: true,\n            },\n            undefined,\n            new WeakHTMLElement(tabster.getWindow, targetElement)\n        );\n\n        const input = dummy.input;\n\n        if (input) {\n            let dummyParent: HTMLElement | null;\n            let insertBefore: HTMLElement | null;\n\n            if (hasSubFocusable(sourceElement) && !isBackward) {\n                dummyParent = sourceElement;\n                insertBefore = dom.getFirstElementChild(\n                    sourceElement\n                ) as HTMLElement | null;\n            } else {\n                dummyParent = dom.getParentElement(sourceElement);\n                insertBefore = isBackward\n                    ? sourceElement\n                    : (dom.getNextElementSibling(\n                          sourceElement\n                      ) as HTMLElement | null);\n            }\n\n            if (dummyParent) {\n                dom.insertBefore(dummyParent, input, insertBefore);\n            }\n        }\n    }\n}\n\ninterface DummyInputWrapper {\n    manager: DummyInputManager;\n    priority: number;\n    tabbable: boolean;\n}\n\nfunction setDummyInputDebugValue(\n    dummy: DummyInput,\n    wrappers: DummyInputWrapper[]\n): void {\n    const what: Record<number, string> = {\n        1: \"Root\",\n        2: \"Modalizer\",\n        3: \"Mover\",\n        4: \"Groupper\",\n    };\n\n    dummy.input?.setAttribute(\n        Types.TabsterDummyInputAttributeName,\n        [\n            `isFirst=${dummy.isFirst}`,\n            `isOutside=${dummy.isOutside}`,\n            ...wrappers.map(\n                (w) => `(${what[w.priority]}, tabbable=${w.tabbable})`\n            ),\n        ].join(\", \")\n    );\n}\n\nexport class DummyInputObserver implements Types.DummyInputObserver {\n    private _win?: GetWindow;\n    private _updateQueue: Set<\n        (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    > = new Set();\n    private _updateTimer?: number;\n    private _lastUpdateQueueTime = 0;\n    private _changedParents: WeakSet<Node> = new WeakSet();\n    private _updateDummyInputsTimer?: number;\n    private _dummyElements: WeakHTMLElement<HTMLElement>[] = [];\n    private _dummyCallbacks: WeakMap<HTMLElement, () => void> = new WeakMap();\n    domChanged?(parent: HTMLElement): void;\n\n    constructor(win: GetWindow) {\n        this._win = win;\n    }\n\n    add(dummy: HTMLElement, callback: () => void): void {\n        if (!this._dummyCallbacks.has(dummy) && this._win) {\n            this._dummyElements.push(new WeakHTMLElement(this._win, dummy));\n            this._dummyCallbacks.set(dummy, callback);\n            this.domChanged = this._domChanged;\n        }\n    }\n\n    remove(dummy: HTMLElement): void {\n        this._dummyElements = this._dummyElements.filter((ref) => {\n            const element = ref.get();\n            return element && element !== dummy;\n        });\n\n        this._dummyCallbacks.delete(dummy);\n\n        if (this._dummyElements.length === 0) {\n            delete this.domChanged;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win?.();\n\n        if (this._updateTimer) {\n            win?.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        if (this._updateDummyInputsTimer) {\n            win?.clearTimeout(this._updateDummyInputsTimer);\n            delete this._updateDummyInputsTimer;\n        }\n\n        this._changedParents = new WeakSet();\n        this._dummyCallbacks = new WeakMap();\n        this._dummyElements = [];\n        this._updateQueue.clear();\n\n        delete this.domChanged;\n        delete this._win;\n    }\n\n    private _domChanged = (parent: HTMLElement): void => {\n        if (this._changedParents.has(parent)) {\n            return;\n        }\n\n        this._changedParents.add(parent);\n\n        if (this._updateDummyInputsTimer) {\n            return;\n        }\n\n        this._updateDummyInputsTimer = this._win?.().setTimeout(() => {\n            delete this._updateDummyInputsTimer;\n\n            for (const ref of this._dummyElements) {\n                const dummyElement = ref.get();\n\n                if (dummyElement) {\n                    const callback = this._dummyCallbacks.get(dummyElement);\n\n                    if (callback) {\n                        const dummyParent = dom.getParentNode(dummyElement);\n\n                        if (\n                            !dummyParent ||\n                            this._changedParents.has(dummyParent)\n                        ) {\n                            callback();\n                        }\n                    }\n                }\n            }\n\n            this._changedParents = new WeakSet();\n        }, _updateDummyInputsTimeout);\n    };\n\n    updatePositions(\n        compute: (\n            scrollTopLeftCache: Map<\n                HTMLElement,\n                { scrollTop: number; scrollLeft: number } | null\n            >\n        ) => () => void\n    ): void {\n        if (!this._win) {\n            // As this is a public method, we make sure that it has no effect when\n            // called after dispose().\n            return;\n        }\n\n        this._updateQueue.add(compute);\n\n        this._lastUpdateQueueTime = Date.now();\n\n        this._scheduledUpdatePositions();\n    }\n\n    private _scheduledUpdatePositions(): void {\n        if (this._updateTimer) {\n            return;\n        }\n\n        this._updateTimer = this._win?.().setTimeout(() => {\n            delete this._updateTimer;\n\n            // updatePositions() might be called quite a lot during the scrolling.\n            // So, instead of clearing the timeout and scheduling a new one, we\n            // check if enough time has passed since the last updatePositions() call\n            // and only schedule a new one if not.\n            // At maximum, we will update dummy inputs positions\n            // _updateDummyInputsTimeout * 2 after the last updatePositions() call.\n            if (\n                this._lastUpdateQueueTime + _updateDummyInputsTimeout <=\n                Date.now()\n            ) {\n                // A cache for current bulk of updates to reduce getComputedStyle() calls.\n                const scrollTopLeftCache = new Map<\n                    HTMLElement,\n                    { scrollTop: number; scrollLeft: number } | null\n                >();\n\n                const setTopLeftCallbacks: (() => void)[] = [];\n\n                for (const compute of this._updateQueue) {\n                    setTopLeftCallbacks.push(compute(scrollTopLeftCache));\n                }\n\n                this._updateQueue.clear();\n\n                // We're splitting the computation of offsets and setting them to avoid extra\n                // reflows.\n                for (const setTopLeft of setTopLeftCallbacks) {\n                    setTopLeft();\n                }\n\n                // Explicitly clear to not hold references till the next garbage collection.\n                scrollTopLeftCache.clear();\n            } else {\n                this._scheduledUpdatePositions();\n            }\n        }, _updateDummyInputsTimeout);\n    }\n}\n\n/**\n * Parent class that encapsulates the behaviour of dummy inputs (focus sentinels)\n */\nclass DummyInputManagerCore {\n    private _tabster: Types.TabsterCore;\n    private _addTimer: number | undefined;\n    private _getWindow: Types.GetWindow;\n    private _wrappers: DummyInputWrapper[] = [];\n    private _element: WeakHTMLElement | undefined;\n    private _isOutside = false;\n    private _firstDummy: DummyInput | undefined;\n    private _lastDummy: DummyInput | undefined;\n    private _transformElements: Set<HTMLElement> = new Set();\n    private _callForDefaultAction: boolean | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        manager: DummyInputManager,\n        priority: number,\n        sys: Types.SysProps | undefined,\n        outsideByDefault?: boolean,\n        callForDefaultAction?: boolean\n    ) {\n        const el = element.get() as HTMLElementWithDummyInputs;\n\n        if (!el) {\n            throw new Error(\"No element\");\n        }\n\n        this._tabster = tabster;\n        this._getWindow = tabster.getWindow;\n        this._callForDefaultAction = callForDefaultAction;\n\n        const instance = el.__tabsterDummy;\n\n        (instance || this)._wrappers.push({\n            manager,\n            priority,\n            tabbable: true,\n        });\n\n        if (instance) {\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(\n                        this._firstDummy,\n                        instance._wrappers\n                    );\n                this._lastDummy &&\n                    setDummyInputDebugValue(\n                        this._lastDummy,\n                        instance._wrappers\n                    );\n            }\n\n            return instance;\n        }\n\n        el.__tabsterDummy = this;\n\n        // Some elements allow only specific types of direct descendants and we need to\n        // put our dummy inputs inside or outside of the element accordingly.\n        const forcedDummyPosition = sys?.dummyInputsPosition;\n        const tagName = el.tagName;\n        this._isOutside = !forcedDummyPosition\n            ? (outsideByDefault ||\n                  tagName === \"UL\" ||\n                  tagName === \"OL\" ||\n                  tagName === \"TABLE\") &&\n              !(tagName === \"LI\" || tagName === \"TD\" || tagName === \"TH\")\n            : forcedDummyPosition === Types.SysDummyInputsPositions.Outside;\n\n        this._firstDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: true,\n            },\n            element\n        );\n\n        this._lastDummy = new DummyInput(\n            this._getWindow,\n            this._isOutside,\n            {\n                isFirst: false,\n            },\n            element\n        );\n\n        // We will be checking dummy input parents to see if their child list have changed.\n        // So, it is enough to have just one of the inputs observed, because\n        // both dummy inputs always have the same parent.\n        const dummyElement = this._firstDummy.input;\n        dummyElement &&\n            tabster._dummyObserver.add(dummyElement, this._addDummyInputs);\n\n        this._firstDummy.onFocusIn = this._onFocusIn;\n        this._firstDummy.onFocusOut = this._onFocusOut;\n        this._lastDummy.onFocusIn = this._onFocusIn;\n        this._lastDummy.onFocusOut = this._onFocusOut;\n\n        this._element = element;\n        this._addDummyInputs();\n    }\n\n    dispose(manager: DummyInputManager, force?: boolean): void {\n        const wrappers = (this._wrappers = this._wrappers.filter(\n            (w) => w.manager !== manager && !force\n        ));\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, wrappers);\n        }\n\n        if (wrappers.length === 0) {\n            delete (this._element?.get() as HTMLElementWithDummyInputs)\n                .__tabsterDummy;\n\n            for (const el of this._transformElements) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n            this._transformElements.clear();\n\n            const win = this._getWindow();\n\n            if (this._addTimer) {\n                win.clearTimeout(this._addTimer);\n                delete this._addTimer;\n            }\n\n            const dummyElement = this._firstDummy?.input;\n            dummyElement && this._tabster._dummyObserver.remove(dummyElement);\n\n            this._firstDummy?.dispose();\n            this._lastDummy?.dispose();\n        }\n    }\n\n    private _onFocus(\n        isIn: boolean,\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void {\n        const wrapper = this._getCurrent();\n\n        if (\n            wrapper &&\n            (!dummyInput.useDefaultAction || this._callForDefaultAction)\n        ) {\n            wrapper.manager.getHandler(isIn)?.(\n                dummyInput,\n                isBackward,\n                relatedTarget\n            );\n        }\n    }\n\n    private _onFocusIn = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(true, dummyInput, isBackward, relatedTarget);\n    };\n\n    private _onFocusOut = (\n        dummyInput: DummyInput,\n        isBackward: boolean,\n        relatedTarget: HTMLElement | null\n    ): void => {\n        this._onFocus(false, dummyInput, isBackward, relatedTarget);\n    };\n\n    moveOut = (backwards: boolean): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    firstInput.tabIndex = 0;\n                    toFocus = firstInput;\n                } else {\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    /**\n     * Prepares to move focus out of the given element by focusing\n     * one of the dummy inputs and setting the `useDefaultAction` flag\n     * @param backwards focus moving to an element behind the given element\n     */\n    moveOutWithDefaultAction = (\n        backwards: boolean,\n        relatedEvent: KeyboardEvent\n    ): void => {\n        const first = this._firstDummy;\n        const last = this._lastDummy;\n\n        if (first && last) {\n            // For the sake of performance optimization, the dummy input\n            // position in the DOM updates asynchronously from the DOM change.\n            // Calling _ensurePosition() to make sure the position is correct.\n            this._ensurePosition();\n\n            const firstInput = first.input;\n            const lastInput = last.input;\n            const element = this._element?.get();\n\n            if (firstInput && lastInput && element) {\n                let toFocus: HTMLElement | undefined;\n\n                if (backwards) {\n                    if (\n                        !first.isOutside &&\n                        this._tabster.focusable.isFocusable(\n                            element,\n                            true,\n                            true,\n                            true\n                        )\n                    ) {\n                        toFocus = element;\n                    } else {\n                        first.useDefaultAction = true;\n                        firstInput.tabIndex = 0;\n                        toFocus = firstInput;\n                    }\n                } else {\n                    last.useDefaultAction = true;\n                    lastInput.tabIndex = 0;\n                    toFocus = lastInput;\n                }\n\n                if (\n                    toFocus &&\n                    element.dispatchEvent(\n                        new TabsterMoveFocusEvent({\n                            by: \"root\",\n                            owner: element,\n                            next: null,\n                            relatedEvent,\n                        })\n                    )\n                ) {\n                    nativeFocus(toFocus);\n                }\n            }\n        }\n    };\n\n    setTabbable = (manager: DummyInputManager, tabbable: boolean) => {\n        for (const w of this._wrappers) {\n            if (w.manager === manager) {\n                w.tabbable = tabbable;\n                break;\n            }\n        }\n\n        const wrapper = this._getCurrent();\n\n        if (wrapper) {\n            const tabIndex = wrapper.tabbable ? 0 : -1;\n\n            let input = this._firstDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n\n            input = this._lastDummy?.input;\n\n            if (input) {\n                input.tabIndex = tabIndex;\n            }\n        }\n\n        if (__DEV__) {\n            this._firstDummy &&\n                setDummyInputDebugValue(this._firstDummy, this._wrappers);\n            this._lastDummy &&\n                setDummyInputDebugValue(this._lastDummy, this._wrappers);\n        }\n    };\n\n    private _getCurrent(): DummyInputWrapper | undefined {\n        this._wrappers.sort((a, b) => {\n            if (a.tabbable !== b.tabbable) {\n                return a.tabbable ? -1 : 1;\n            }\n\n            return a.priority - b.priority;\n        });\n\n        return this._wrappers[0];\n    }\n\n    /**\n     * Adds dummy inputs as the first and last child of the given element\n     * Called each time the children under the element is mutated\n     */\n    private _addDummyInputs = () => {\n        if (this._addTimer) {\n            return;\n        }\n\n        this._addTimer = this._getWindow().setTimeout(() => {\n            delete this._addTimer;\n\n            this._ensurePosition();\n\n            if (__DEV__) {\n                this._firstDummy &&\n                    setDummyInputDebugValue(this._firstDummy, this._wrappers);\n                this._lastDummy &&\n                    setDummyInputDebugValue(this._lastDummy, this._wrappers);\n            }\n\n            this._addTransformOffsets();\n        }, 0);\n    };\n\n    private _ensurePosition(): void {\n        const element = this._element?.get();\n        const firstDummyInput = this._firstDummy?.input;\n        const lastDummyInput = this._lastDummy?.input;\n\n        if (!element || !firstDummyInput || !lastDummyInput) {\n            return;\n        }\n\n        if (this._isOutside) {\n            const elementParent = dom.getParentNode(element);\n\n            if (elementParent) {\n                const nextSibling = dom.getNextSibling(element);\n\n                if (nextSibling !== lastDummyInput) {\n                    dom.insertBefore(\n                        elementParent,\n                        lastDummyInput,\n                        nextSibling\n                    );\n                }\n\n                if (\n                    dom.getPreviousElementSibling(element) !== firstDummyInput\n                ) {\n                    dom.insertBefore(elementParent, firstDummyInput, element);\n                }\n            }\n        } else {\n            if (dom.getLastElementChild(element) !== lastDummyInput) {\n                dom.appendChild(element, lastDummyInput);\n            }\n\n            const firstElementChild = dom.getFirstElementChild(element);\n\n            if (\n                firstElementChild &&\n                firstElementChild !== firstDummyInput &&\n                firstElementChild.parentNode\n            ) {\n                dom.insertBefore(\n                    firstElementChild.parentNode,\n                    firstDummyInput,\n                    firstElementChild\n                );\n            }\n        }\n    }\n\n    private _addTransformOffsets = (): void => {\n        this._tabster._dummyObserver.updatePositions(\n            this._computeTransformOffsets\n        );\n    };\n\n    private _computeTransformOffsets = (\n        scrollTopLeftCache: Map<\n            HTMLElement,\n            { scrollTop: number; scrollLeft: number } | null\n        >\n    ): (() => void) => {\n        const from = this._firstDummy?.input || this._lastDummy?.input;\n        const transformElements = this._transformElements;\n        const newTransformElements: typeof transformElements = new Set();\n        let scrollTop = 0;\n        let scrollLeft = 0;\n\n        const win = this._getWindow();\n\n        for (\n            let element: HTMLElement | undefined | null = from;\n            element && element.nodeType === Node.ELEMENT_NODE;\n            element = dom.getParentElement(element)\n        ) {\n            let scrollTopLeft = scrollTopLeftCache.get(element);\n\n            // getComputedStyle() and element.scrollLeft/Top() cause style recalculation,\n            // so we cache the result across all elements in the current bulk.\n            if (scrollTopLeft === undefined) {\n                const transform = win.getComputedStyle(element).transform;\n\n                if (transform && transform !== \"none\") {\n                    scrollTopLeft = {\n                        scrollTop: element.scrollTop,\n                        scrollLeft: element.scrollLeft,\n                    };\n                }\n\n                scrollTopLeftCache.set(element, scrollTopLeft || null);\n            }\n\n            if (scrollTopLeft) {\n                newTransformElements.add(element);\n\n                if (!transformElements.has(element)) {\n                    element.addEventListener(\n                        \"scroll\",\n                        this._addTransformOffsets\n                    );\n                }\n\n                scrollTop += scrollTopLeft.scrollTop;\n                scrollLeft += scrollTopLeft.scrollLeft;\n            }\n        }\n\n        for (const el of transformElements) {\n            if (!newTransformElements.has(el)) {\n                el.removeEventListener(\"scroll\", this._addTransformOffsets);\n            }\n        }\n\n        this._transformElements = newTransformElements;\n\n        return () => {\n            this._firstDummy?.setTopLeft(scrollTop, scrollLeft);\n            this._lastDummy?.setTopLeft(scrollTop, scrollLeft);\n        };\n    };\n}\n\nexport function getLastChild(container: HTMLElement): HTMLElement | undefined {\n    let lastChild: HTMLElement | null = null;\n\n    for (\n        let i = dom.getLastElementChild(container);\n        i;\n        i = dom.getLastElementChild(i)\n    ) {\n        lastChild = i as HTMLElement;\n    }\n\n    return lastChild || undefined;\n}\n\nexport function getAdjacentElement(\n    from: HTMLElement,\n    prev?: boolean\n): HTMLElement | undefined {\n    let cur: HTMLElement | null = from;\n    let adjacent: HTMLElement | null = null;\n\n    while (cur && !adjacent) {\n        adjacent = (\n            prev\n                ? dom.getPreviousElementSibling(cur)\n                : dom.getNextElementSibling(cur)\n        ) as HTMLElement | null;\n        cur = dom.getParentElement(cur);\n    }\n\n    return adjacent || undefined;\n}\n\nexport function augmentAttribute(\n    tabster: Types.TabsterCore,\n    element: HTMLElement,\n    name: string,\n    value?: string | null // Restore original value when undefined.\n): boolean {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const entry = tabster.storageEntry(element, true)!;\n    let ret = false;\n\n    if (!entry.aug) {\n        if (value === undefined) {\n            return ret;\n        }\n\n        entry.aug = {};\n    }\n\n    if (value === undefined) {\n        if (name in entry.aug) {\n            const origVal = entry.aug[name];\n\n            delete entry.aug[name];\n\n            if (origVal === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, origVal);\n            }\n\n            ret = true;\n        }\n    } else {\n        let origValue: string | null | undefined;\n\n        if (!(name in entry.aug)) {\n            origValue = element.getAttribute(name);\n        }\n\n        if (origValue !== undefined && origValue !== value) {\n            entry.aug[name] = origValue;\n\n            if (value === null) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, value);\n            }\n\n            ret = true;\n        }\n    }\n\n    if (value === undefined && Object.keys(entry.aug).length === 0) {\n        delete entry.aug;\n        tabster.storageEntry(element, false);\n    }\n\n    return ret;\n}\n\nexport function getTabsterAttributeOnElement(\n    element: HTMLElement\n): Types.TabsterAttributeProps | null {\n    if (!element.hasAttribute(Types.TabsterAttributeName)) {\n        return null;\n    }\n\n    // We already checked the presence with `hasAttribute`\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const rawAttribute = element.getAttribute(Types.TabsterAttributeName)!;\n    let tabsterAttribute: Types.TabsterAttributeProps;\n    try {\n        tabsterAttribute = JSON.parse(rawAttribute);\n    } catch {\n        console.error(\"Tabster: failed to parse attribute\", rawAttribute);\n        tabsterAttribute = {};\n    }\n\n    return tabsterAttribute;\n}\n\nexport function isDisplayNone(element: HTMLElement): boolean {\n    const elementDocument = element.ownerDocument;\n    const computedStyle =\n        elementDocument.defaultView?.getComputedStyle(element);\n\n    // offsetParent is null for elements with display:none, display:fixed and for <body>.\n    if (\n        element.offsetParent === null &&\n        elementDocument.body !== element &&\n        computedStyle?.position !== \"fixed\"\n    ) {\n        return true;\n    }\n\n    // For our purposes of looking for focusable elements, visibility:hidden has the same\n    // effect as display:none.\n    if (computedStyle?.visibility === \"hidden\") {\n        return true;\n    }\n\n    // if an element has display: fixed, we need to check if it is also hidden with CSS,\n    // or within a parent hidden with CSS\n    if (computedStyle?.position === \"fixed\") {\n        if (computedStyle.display === \"none\") {\n            return true;\n        }\n\n        if (\n            element.parentElement?.offsetParent === null &&\n            elementDocument.body !== element.parentElement\n        ) {\n            return true;\n        }\n    }\n\n    return false;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps\n): Types.TabsterDOMAttribute;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain: true\n): string;\nexport function getTabsterAttribute(\n    props: Types.TabsterAttributeProps,\n    plain?: true\n): Types.TabsterDOMAttribute | string {\n    const attr = JSON.stringify(props);\n\n    if (plain === true) {\n        return attr;\n    }\n\n    return {\n        [Types.TabsterAttributeName]: attr,\n    };\n}\n\n/**\n * Updates Tabster props object with new props.\n * @param element an element to set data-tabster attribute on.\n * @param props current Tabster props to update.\n * @param newProps new Tabster props to add.\n *  When the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function mergeTabsterProps(\n    props: Types.TabsterAttributeProps,\n    newProps: Types.TabsterAttributeProps\n): void {\n    for (const key of Object.keys(\n        newProps\n    ) as (keyof Types.TabsterAttributeProps)[]) {\n        const value = newProps[key];\n\n        if (value) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            props[key] = value as any;\n        } else {\n            delete props[key];\n        }\n    }\n}\n\n/**\n * Sets or updates Tabster attribute of the element.\n * @param element an element to set data-tabster attribute on.\n * @param newProps new Tabster props to set.\n * @param update if true, newProps will be merged with the existing props.\n *  When true and the value of a property in newProps is undefined, the property\n *  will be removed from the attribute.\n */\nexport function setTabsterAttribute(\n    element: HTMLElement,\n    newProps: Types.TabsterAttributeProps,\n    update?: boolean\n): void {\n    let props: Types.TabsterAttributeProps | undefined;\n\n    if (update) {\n        const attr = element.getAttribute(Types.TabsterAttributeName);\n\n        if (attr) {\n            try {\n                props = JSON.parse(attr);\n            } catch (e) {\n                if (__DEV__) {\n                    console.error(\n                        `data-tabster attribute error: ${e}`,\n                        element\n                    );\n                }\n            }\n        }\n    }\n\n    if (!props) {\n        props = {};\n    }\n\n    mergeTabsterProps(props, newProps);\n\n    if (Object.keys(props).length > 0) {\n        element.setAttribute(\n            Types.TabsterAttributeName,\n            getTabsterAttribute(props, true)\n        );\n    } else {\n        element.removeAttribute(Types.TabsterAttributeName);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { KEYBORG_FOCUSIN, KEYBORG_FOCUSOUT, nativeFocus } from \"keyborg\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport { RootFocusEvent, RootBlurEvent } from \"./Events\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    TabsterPart,\n    WeakHTMLElement,\n} from \"./Utils\";\nimport { setTabsterAttribute } from \"./AttributeHelpers\";\n\nexport interface WindowWithTabsterInstance extends Window {\n    __tabsterInstance?: Types.TabsterCore;\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    id?: string\n) {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-root\");\n            } else {\n                element.style.setProperty(\"--tabster-root\", id + \",\");\n            }\n        }\n    }\n}\n\nclass RootDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _setFocused: (focused: boolean) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: WeakHTMLElement,\n        setFocused: (focused: boolean) => void,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Root,\n            sys,\n            undefined,\n            true\n        );\n\n        this._setHandlers(this._onDummyInputFocus);\n\n        this._tabster = tabster;\n        this._setFocused = setFocused;\n    }\n\n    private _onDummyInputFocus = (dummyInput: DummyInput): void => {\n        if (dummyInput.useDefaultAction) {\n            // When we've reached the last focusable element, we want to let the browser\n            // to move the focus outside of the page. In order to do that we're synchronously\n            // calling focus() of the dummy input from the Tab key handler and allowing\n            // the default action to move the focus out.\n            this._setFocused(false);\n        } else {\n            // The only way a dummy input gets focused is during the keyboard navigation.\n            this._tabster.keyboardNavigation.setNavigatingWithKeyboard(true);\n\n            const element = this._element.get();\n\n            if (element) {\n                this._setFocused(true);\n\n                const toFocus =\n                    this._tabster.focusedElement.getFirstOrLastTabbable(\n                        dummyInput.isFirst,\n                        { container: element, ignoreAccessibility: true }\n                    );\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                    return;\n                }\n            }\n\n            dummyInput.input?.blur();\n        }\n    };\n}\n\nexport class Root\n    extends TabsterPart<Types.RootProps, undefined>\n    implements Types.Root\n{\n    readonly uid: string;\n\n    private _dummyManager?: RootDummyManager;\n    private _sys?: Types.SysProps;\n    private _isFocused = false;\n    private _setFocusedTimer: number | undefined;\n    private _onDispose: (root: Root) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (root: Root) => void,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._onDispose = onDispose;\n\n        const win = tabster.getWindow;\n        this.uid = getElementUId(win, element);\n\n        this._sys = sys;\n\n        if (tabster.controlTab || tabster.rootDummyInputs) {\n            this.addDummyInputs();\n        }\n\n        const w = win();\n        const doc = w.document;\n\n        doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn);\n        doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);\n\n        this._add();\n    }\n\n    addDummyInputs(): void {\n        if (!this._dummyManager) {\n            this._dummyManager = new RootDummyManager(\n                this._tabster,\n                this._element,\n                this._setFocused,\n                this._sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const win = this._tabster.getWindow();\n        const doc = win.document;\n\n        doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn);\n        doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut);\n\n        if (this._setFocusedTimer) {\n            win.clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        this._dummyManager?.dispose();\n        this._remove();\n    }\n\n    moveOutWithDefaultAction(isBackward: boolean, relatedEvent: KeyboardEvent) {\n        const dummyManager = this._dummyManager;\n\n        if (dummyManager) {\n            dummyManager.moveOutWithDefaultAction(isBackward, relatedEvent);\n        } else {\n            const el = this.getElement();\n\n            if (el) {\n                RootDummyManager.moveWithPhantomDummy(\n                    this._tabster,\n                    el,\n                    true,\n                    isBackward,\n                    relatedEvent\n                );\n            }\n        }\n    }\n\n    private _setFocused = (hasFocused: boolean): void => {\n        if (this._setFocusedTimer) {\n            this._tabster.getWindow().clearTimeout(this._setFocusedTimer);\n            delete this._setFocusedTimer;\n        }\n\n        if (this._isFocused === hasFocused) {\n            return;\n        }\n\n        const element = this._element.get();\n\n        if (element) {\n            if (hasFocused) {\n                this._isFocused = true;\n                this._dummyManager?.setTabbable(false);\n                element.dispatchEvent(new RootFocusEvent({ element }));\n            } else {\n                this._setFocusedTimer = this._tabster\n                    .getWindow()\n                    .setTimeout(() => {\n                        delete this._setFocusedTimer;\n\n                        this._isFocused = false;\n                        this._dummyManager?.setTabbable(true);\n                        element.dispatchEvent(new RootBlurEvent({ element }));\n                    }, 0);\n            }\n        }\n    };\n\n    private _onFocusIn = (event: FocusEvent) => {\n        const getParent = this._tabster.getParent;\n        const rootElement = this._element.get();\n        let curElement = event.composedPath()[0] as HTMLElement | null;\n\n        do {\n            if (curElement === rootElement) {\n                this._setFocused(true);\n                return;\n            }\n\n            curElement =\n                curElement && (getParent(curElement) as HTMLElement | null);\n        } while (curElement);\n    };\n\n    private _onFocusOut = () => {\n        this._setFocused(false);\n    };\n\n    private _add(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, false, this.uid);\n        }\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateRootProps(props: Types.RootProps): void {\n    // TODO: Implement validation.\n}\n\nexport class RootAPI implements Types.RootAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _autoRoot: Types.RootProps | undefined;\n    private _autoRootWaiting = false;\n    private _roots: Record<string, Types.Root> = {};\n    private _forceDummy = false;\n    rootById: { [id: string]: Types.Root } = {};\n\n    constructor(tabster: Types.TabsterCore, autoRoot?: Types.RootProps) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._autoRoot = autoRoot;\n\n        tabster.queueInit(() => {\n            if (this._autoRoot) {\n                this._autoRootCreate();\n            }\n        });\n    }\n\n    private _autoRootCreate = (): Types.Root | undefined => {\n        const doc = this._win().document;\n        const body = doc.body;\n\n        if (body) {\n            this._autoRootUnwait(doc);\n\n            const props = this._autoRoot;\n\n            if (props) {\n                setTabsterAttribute(body, { root: props }, true);\n                updateTabsterByAttribute(this._tabster, body);\n                return getTabsterOnElement(this._tabster, body)?.root;\n            }\n        } else if (!this._autoRootWaiting) {\n            this._autoRootWaiting = true;\n            doc.addEventListener(\"readystatechange\", this._autoRootCreate);\n        }\n\n        return undefined;\n    };\n\n    private _autoRootUnwait(doc: Document): void {\n        doc.removeEventListener(\"readystatechange\", this._autoRootCreate);\n        this._autoRootWaiting = false;\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        this._autoRootUnwait(win.document);\n        delete this._autoRoot;\n\n        Object.keys(this._roots).forEach((rootId) => {\n            if (this._roots[rootId]) {\n                this._roots[rootId].dispose();\n                delete this._roots[rootId];\n            }\n        });\n\n        this.rootById = {};\n    }\n\n    createRoot(\n        element: HTMLElement,\n        props: Types.RootProps,\n        sys: Types.SysProps | undefined\n    ): Types.Root {\n        if (__DEV__) {\n            validateRootProps(props);\n        }\n\n        const newRoot = new Root(\n            this._tabster,\n            element,\n            this._onRootDispose,\n            props,\n            sys\n        ) as Types.Root;\n\n        this._roots[newRoot.id] = newRoot;\n\n        if (this._forceDummy) {\n            newRoot.addDummyInputs();\n        }\n\n        return newRoot;\n    }\n\n    addDummyInputs(): void {\n        this._forceDummy = true;\n\n        const roots = this._roots;\n\n        for (const id of Object.keys(roots)) {\n            roots[id].addDummyInputs();\n        }\n    }\n\n    static getRootByUId(\n        getWindow: Types.GetWindow,\n        id: string\n    ): Types.Root | undefined {\n        const tabster = (getWindow() as WindowWithTabsterInstance)\n            .__tabsterInstance;\n        return tabster && (tabster.root as RootAPI).rootById[id];\n    }\n\n    /**\n     * Fetches the tabster context for an element walking up its ancestors\n     *\n     * @param tabster Tabster instance\n     * @param element The element the tabster context should represent\n     * @param options Additional options\n     * @returns undefined if the element is not a child of a tabster root, otherwise all applicable tabster behaviours and configurations\n     */\n    static getTabsterContext(\n        tabster: Types.TabsterCore,\n        element: Node,\n        options: Types.GetTabsterContextOptions = {}\n    ): Types.TabsterContext | undefined {\n        if (!element.ownerDocument) {\n            return undefined;\n        }\n\n        const { checkRtl, referenceElement } = options;\n\n        const getParent = tabster.getParent;\n\n        // Normally, the initialization starts on the next tick after the tabster\n        // instance creation. However, if the application starts using it before\n        // the next tick, we need to make sure the initialization is done.\n        tabster.drainInitQueue();\n\n        let root: Types.Root | undefined;\n        let modalizer: Types.Modalizer | undefined;\n        let groupper: Types.Groupper | undefined;\n        let mover: Types.Mover | undefined;\n        let excludedFromMover = false;\n        let groupperBeforeMover: boolean | undefined;\n        let modalizerInGroupper: Types.Groupper | undefined;\n        let dirRightToLeft: boolean | undefined;\n        let uncontrolled: HTMLElement | null | undefined;\n        let curElement: Node | null = referenceElement || element;\n        const ignoreKeydown: Types.FocusableProps[\"ignoreKeydown\"] = {};\n\n        while (curElement && (!root || checkRtl)) {\n            const tabsterOnElement = getTabsterOnElement(\n                tabster,\n                curElement as HTMLElement\n            );\n\n            if (checkRtl && dirRightToLeft === undefined) {\n                const dir = (curElement as HTMLElement).dir;\n\n                if (dir) {\n                    dirRightToLeft = dir.toLowerCase() === \"rtl\";\n                }\n            }\n\n            if (!tabsterOnElement) {\n                curElement = getParent(curElement);\n                continue;\n            }\n\n            const tagName = (curElement as HTMLElement).tagName;\n\n            if (\n                tabsterOnElement.uncontrolled ||\n                tagName === \"IFRAME\" ||\n                tagName === \"WEBVIEW\"\n            ) {\n                uncontrolled = curElement as HTMLElement;\n            }\n\n            if (\n                !mover &&\n                tabsterOnElement.focusable?.excludeFromMover &&\n                !groupper\n            ) {\n                excludedFromMover = true;\n            }\n\n            const curModalizer = tabsterOnElement.modalizer;\n            const curGroupper = tabsterOnElement.groupper;\n            const curMover = tabsterOnElement.mover;\n\n            if (!modalizer && curModalizer) {\n                modalizer = curModalizer;\n            }\n\n            if (!groupper && curGroupper && (!modalizer || curModalizer)) {\n                if (modalizer) {\n                    // Modalizer dominates the groupper when they are on the same node and the groupper is active.\n                    if (\n                        !curGroupper.isActive() &&\n                        curGroupper.getProps().tabbability &&\n                        modalizer.userId !== tabster.modalizer?.activeId\n                    ) {\n                        modalizer = undefined;\n                        groupper = curGroupper;\n                    }\n\n                    modalizerInGroupper = curGroupper;\n                } else {\n                    groupper = curGroupper;\n                }\n            }\n\n            if (\n                !mover &&\n                curMover &&\n                (!modalizer || curModalizer) &&\n                (!curGroupper || curElement !== element)\n            ) {\n                mover = curMover;\n                groupperBeforeMover = !!groupper && groupper !== curGroupper;\n            }\n\n            if (tabsterOnElement.root) {\n                root = tabsterOnElement.root;\n            }\n\n            if (tabsterOnElement.focusable?.ignoreKeydown) {\n                Object.assign(\n                    ignoreKeydown,\n                    tabsterOnElement.focusable.ignoreKeydown\n                );\n            }\n\n            curElement = getParent(curElement);\n        }\n\n        // No root element could be found, try to get an auto root\n        if (!root) {\n            const rootAPI = tabster.root as RootAPI;\n            const autoRoot = rootAPI._autoRoot;\n\n            if (autoRoot) {\n                if (element.ownerDocument?.body) {\n                    root = rootAPI._autoRootCreate();\n                }\n            }\n        }\n\n        if (groupper && !mover) {\n            groupperBeforeMover = true;\n        }\n\n        if (__DEV__ && !root) {\n            if (modalizer || groupper || mover) {\n                console.error(\n                    \"Tabster Root is required for Mover, Groupper and Modalizer to work.\"\n                );\n            }\n        }\n\n        const shouldIgnoreKeydown = (event: KeyboardEvent) =>\n            !!ignoreKeydown[\n                event.key as keyof Types.FocusableProps[\"ignoreKeydown\"]\n            ];\n\n        return root\n            ? {\n                  root,\n                  modalizer,\n                  groupper,\n                  mover,\n                  groupperBeforeMover,\n                  modalizerInGroupper,\n                  rtl: checkRtl ? !!dirRightToLeft : undefined,\n                  uncontrolled,\n                  excludedFromMover,\n                  ignoreKeydown: shouldIgnoreKeydown,\n              }\n            : undefined;\n    }\n\n    static getRoot(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Root | undefined {\n        const getParent = tabster.getParent;\n\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = getParent(el) as HTMLElement | null\n        ) {\n            const root = getTabsterOnElement(tabster, el)?.root;\n\n            if (root) {\n                return root;\n            }\n        }\n\n        return undefined;\n    }\n\n    onRoot(root: Types.Root, removed?: boolean): void {\n        if (removed) {\n            delete this.rootById[root.uid];\n        } else {\n            this.rootById[root.uid] = root;\n        }\n    }\n\n    private _onRootDispose = (root: Root) => {\n        delete this._roots[root.id];\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    DeloserFocusLostEvent,\n    TabsterMoveFocusEvent,\n    DeloserRestoreFocusEvent,\n    DeloserRestoreFocusEventName,\n} from \"./Events\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    isDisplayNone,\n    TabsterPart,\n    WeakHTMLElement,\n} from \"./Utils\";\nimport { dom } from \"./DOMAPI\";\n\nconst _containerHistoryLength = 10;\n\nexport abstract class DeloserItemBase<C> {\n    abstract resetFocus(): Promise<boolean>;\n    abstract belongsTo(deloser: C): boolean;\n}\n\nexport class DeloserItem extends DeloserItemBase<Types.Deloser> {\n    readonly uid: string;\n    private _tabster: Types.TabsterCore;\n    private _deloser: Types.Deloser;\n\n    constructor(tabster: Types.TabsterCore, deloser: Types.Deloser) {\n        super();\n        this.uid = deloser.uid;\n        this._tabster = tabster;\n        this._deloser = deloser;\n    }\n\n    belongsTo(deloser: Types.Deloser): boolean {\n        return deloser === this._deloser;\n    }\n\n    unshift(element: HTMLElement): void {\n        this._deloser.unshift(element);\n    }\n\n    async focusAvailable(): Promise<boolean | null> {\n        const available = this._deloser.findAvailable();\n        const deloserElement = this._deloser.getElement();\n\n        if (available && deloserElement) {\n            if (\n                !deloserElement.dispatchEvent(\n                    new TabsterMoveFocusEvent({\n                        by: \"deloser\",\n                        owner: deloserElement,\n                        next: available,\n                    })\n                )\n            ) {\n                // Default action is prevented, don't look further.\n                return null;\n            }\n\n            return this._tabster.focusedElement.focus(available);\n        }\n\n        return false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const getWindow = this._tabster.getWindow;\n        return getPromise(getWindow).resolve(this._deloser.resetFocus());\n    }\n}\n\nexport abstract class DeloserHistoryByRootBase<\n    I,\n    D extends DeloserItemBase<I>\n> {\n    protected _tabster: Types.TabsterCore;\n    protected _history: D[] = [];\n    readonly rootUId: string;\n\n    constructor(tabster: Types.TabsterCore, rootUId: string) {\n        this._tabster = tabster;\n        this.rootUId = rootUId;\n    }\n\n    getLength(): number {\n        return this._history.length;\n    }\n\n    removeDeloser(deloser: I): void {\n        this._history = this._history.filter((c) => !c.belongsTo(deloser));\n    }\n\n    hasDeloser(deloser: I): boolean {\n        return this._history.some((d) => d.belongsTo(deloser));\n    }\n\n    abstract focusAvailable(from: I | null): Promise<boolean | null>;\n    abstract resetFocus(from: I | null): Promise<boolean>;\n}\n\nclass DeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    Types.Deloser,\n    DeloserItem\n> {\n    unshiftToDeloser(deloser: Types.Deloser, element: HTMLElement): void {\n        let item: DeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new DeloserItem(this._tabster, deloser);\n        }\n\n        item.unshift(element);\n\n        this._history.unshift(item);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean | null> {\n        let skip = !!from;\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip) {\n                const result = await i.focusAvailable();\n\n                // Result is null when the default action is prevented by the application\n                // and we don't need to look further.\n                if (result || result === null) {\n                    return result;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n        const resetQueue: { [id: string]: DeloserItem } = {};\n\n        for (const i of this._history) {\n            if (from && i.belongsTo(from)) {\n                skip = false;\n            }\n\n            if (!skip && !resetQueue[i.uid]) {\n                resetQueue[i.uid] = i;\n            }\n        }\n\n        // Nothing is found, at least try to reset.\n        for (const id of Object.keys(resetQueue)) {\n            if (await resetQueue[id].resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nexport class DeloserHistory {\n    private _tabster: Types.TabsterCore;\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    private _history: DeloserHistoryByRootBase<\n        unknown,\n        DeloserItemBase<unknown>\n    >[] = [];\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        this._history = [];\n    }\n\n    process(element: HTMLElement): Types.Deloser | undefined {\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n        const rootUId = ctx && ctx.root.uid;\n        const deloser = DeloserAPI.getDeloser(this._tabster, element);\n\n        if (!rootUId || !deloser) {\n            return undefined;\n        }\n\n        const historyByRoot = this.make(\n            rootUId,\n            () => new DeloserHistoryByRoot(this._tabster, rootUId)\n        );\n\n        if (!ctx || !ctx.modalizer || ctx.modalizer?.isActive()) {\n            historyByRoot.unshiftToDeloser(deloser, element);\n        }\n\n        return deloser;\n    }\n\n    make<\n        I,\n        D extends DeloserItemBase<I>,\n        C extends DeloserHistoryByRootBase<I, D>\n    >(rootUId: string, createInstance: () => C): C {\n        let historyByRoot: C | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            const hbr = this._history[i] as C;\n\n            if (hbr.rootUId === rootUId) {\n                historyByRoot = hbr;\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!historyByRoot) {\n            historyByRoot = createInstance();\n        }\n\n        this._history.unshift(historyByRoot);\n\n        this._history.splice(\n            _containerHistoryLength,\n            this._history.length - _containerHistoryLength\n        );\n\n        return historyByRoot;\n    }\n\n    removeDeloser(deloser: Types.Deloser): void {\n        this._history.forEach((i) => {\n            i.removeDeloser(deloser);\n        });\n\n        this._history = this._history.filter((i) => i.getLength() > 0);\n    }\n\n    async focusAvailable(from: Types.Deloser | null): Promise<boolean | null> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip) {\n                const result = await h.focusAvailable(from);\n\n                // Result is null when the default action is prevented by the application\n                // and we don't need to look further.\n                if (result || result === null) {\n                    return result;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(from: Types.Deloser | null): Promise<boolean> {\n        let skip = !!from;\n\n        for (const h of this._history) {\n            if (from && h.hasDeloser(from)) {\n                skip = false;\n            }\n\n            if (!skip && (await h.resetFocus(from))) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    isActive?: boolean,\n    snapshotIndex?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-deloser\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-deloser\",\n                    (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        (\"snapshot-\" + snapshotIndex)\n                );\n            }\n        }\n    }\n}\n\nfunction buildElementSelector(\n    element: HTMLElement,\n    withClass?: boolean,\n    withIndex?: boolean\n): string {\n    const selector: string[] = [];\n    const escapeRegExp = /(:|\\.|\\[|\\]|,|=|@)/g;\n    const escapeReplaceValue = \"\\\\$1\";\n\n    const elementId = element.getAttribute(\"id\");\n\n    if (elementId) {\n        selector.push(\n            \"#\" + elementId.replace(escapeRegExp, escapeReplaceValue)\n        );\n    }\n\n    if (withClass !== false && element.className) {\n        element.className.split(\" \").forEach((cls) => {\n            cls = cls.trim();\n\n            if (cls) {\n                selector.push(\n                    \".\" + cls.replace(escapeRegExp, escapeReplaceValue)\n                );\n            }\n        });\n    }\n\n    let index = 0;\n    let el: Element | null;\n\n    if (withIndex !== false && selector.length === 0) {\n        el = element;\n        while (el) {\n            index++;\n            el = el.previousElementSibling;\n        }\n        selector.unshift(\":nth-child(\" + index + \")\");\n    }\n\n    selector.unshift(element.tagName.toLowerCase());\n\n    return selector.join(\"\");\n}\n\nfunction buildSelector(element: HTMLElement): string | undefined {\n    if (!documentContains(element.ownerDocument, element)) {\n        return undefined;\n    }\n\n    const selector: string[] = [buildElementSelector(element)];\n\n    let node = dom.getParentNode(element);\n\n    while (node && node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\n        // Stop at the shadow root as cross shadow selectors won't work.\n        if (node.nodeType === Node.ELEMENT_NODE) {\n            const isBody = (node as HTMLElement).tagName === \"BODY\";\n\n            selector.unshift(\n                buildElementSelector(node as HTMLElement, false, !isBody)\n            );\n\n            if (isBody) {\n                break;\n            }\n        }\n\n        node = dom.getParentNode(node);\n    }\n\n    return selector.join(\" \");\n}\n\nexport class Deloser\n    extends TabsterPart<Types.DeloserProps>\n    implements Types.Deloser\n{\n    readonly uid: string;\n    readonly strategy: Types.DeloserStrategy;\n    private _isActive = false;\n    private _history: WeakHTMLElement<HTMLElement, string>[][] = [[]];\n    private _snapshotIndex = 0;\n    private _onDispose: (deloser: Deloser) => void;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (deloser: Deloser) => void,\n        props: Types.DeloserProps\n    ) {\n        super(tabster, element, props);\n\n        this.uid = getElementUId(tabster.getWindow, element);\n        this.strategy = props.strategy || Types.DeloserStrategies.Auto;\n        this._onDispose = onDispose;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    dispose(): void {\n        this._remove();\n\n        this._onDispose(this);\n\n        this._isActive = false;\n        this._snapshotIndex = 0;\n\n        this._props = {};\n        this._history = [];\n    }\n\n    isActive = (): boolean => {\n        return this._isActive;\n    };\n\n    setActive(active: boolean): void {\n        this._isActive = active;\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    }\n\n    getActions(): Types.DeloserElementActions {\n        return {\n            focusDefault: this.focusDefault,\n            focusFirst: this.focusFirst,\n            resetFocus: this.resetFocus,\n            clearHistory: this.clearHistory,\n            setSnapshot: this.setSnapshot,\n            isActive: this.isActive,\n        };\n    }\n\n    setSnapshot = (index: number): void => {\n        this._snapshotIndex = index;\n\n        if (this._history.length > index + 1) {\n            this._history.splice(index + 1, this._history.length - index - 1);\n        }\n\n        if (!this._history[index]) {\n            this._history[index] = [];\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this._isActive,\n                this._snapshotIndex\n            );\n        }\n    };\n\n    focusFirst = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusFirst({ container: e });\n    };\n\n    unshift(element: HTMLElement): void {\n        let cur = this._history[this._snapshotIndex];\n\n        cur = this._history[this._snapshotIndex] = cur.filter((we) => {\n            const e = we.get();\n            return e && e !== element;\n        });\n\n        cur.unshift(\n            new WeakHTMLElement(\n                this._tabster.getWindow,\n                element,\n                buildSelector(element)\n            )\n        );\n\n        while (cur.length > _containerHistoryLength) {\n            cur.pop();\n        }\n    }\n\n    focusDefault = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.focusDefault(e);\n    };\n\n    resetFocus = (): boolean => {\n        const e = this._element.get();\n        return !!e && this._tabster.focusedElement.resetFocus(e);\n    };\n\n    findAvailable(): HTMLElement | null {\n        const element = this._element.get();\n\n        if (!element || !this._tabster.focusable.isVisible(element)) {\n            return null;\n        }\n\n        let restoreFocusOrder = this._props.restoreFocusOrder;\n        let available: HTMLElement | null = null;\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n        if (!ctx) {\n            return null;\n        }\n\n        const root = ctx.root;\n        const rootElement = root.getElement();\n\n        if (!rootElement) {\n            return null;\n        }\n\n        if (restoreFocusOrder === undefined) {\n            restoreFocusOrder = root.getProps().restoreFocusOrder;\n        }\n\n        if (restoreFocusOrder === Types.RestoreFocusOrders.RootDefault) {\n            available = this._tabster.focusable.findDefault({\n                container: rootElement,\n            });\n        }\n\n        if (\n            !available &&\n            restoreFocusOrder === Types.RestoreFocusOrders.RootFirst\n        ) {\n            available = this._findFirst(rootElement);\n        }\n\n        if (available) {\n            return available;\n        }\n\n        const availableInHistory = this._findInHistory();\n\n        if (\n            availableInHistory &&\n            restoreFocusOrder === Types.RestoreFocusOrders.History\n        ) {\n            return availableInHistory;\n        }\n\n        const availableDefault = this._tabster.focusable.findDefault({\n            container: element,\n        });\n\n        if (\n            availableDefault &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserDefault\n        ) {\n            return availableDefault;\n        }\n\n        const availableFirst = this._findFirst(element);\n\n        if (\n            availableFirst &&\n            restoreFocusOrder === Types.RestoreFocusOrders.DeloserFirst\n        ) {\n            return availableFirst;\n        }\n\n        return availableDefault || availableInHistory || availableFirst || null;\n    }\n\n    clearHistory = (preserveExisting?: boolean): void => {\n        const element = this._element.get();\n\n        if (!element) {\n            this._history[this._snapshotIndex] = [];\n\n            return;\n        }\n\n        this._history[this._snapshotIndex] = this._history[\n            this._snapshotIndex\n        ].filter((we) => {\n            const e = we.get();\n            return e && preserveExisting ? dom.nodeContains(element, e) : false;\n        });\n    };\n\n    customFocusLostHandler(element: HTMLElement): boolean {\n        return element.dispatchEvent(\n            new DeloserFocusLostEvent(this.getActions())\n        );\n    }\n\n    private _findInHistory(): HTMLElement | null {\n        const cur = this._history[this._snapshotIndex].slice(0);\n\n        this.clearHistory(true);\n\n        for (let i = 0; i < cur.length; i++) {\n            const we = cur[i];\n            const e = we.get();\n            const element = this._element.get();\n\n            if (e && element && dom.nodeContains(element, e)) {\n                if (this._tabster.focusable.isFocusable(e)) {\n                    return e;\n                }\n            } else if (!this._props.noSelectorCheck) {\n                // Element is not in the DOM, try to locate the node by it's\n                // selector. This might return not exactly the right node,\n                // but it would be easily fixable by having more detailed selectors.\n                const selector = we.getData();\n\n                if (selector && element) {\n                    let els: Element[];\n\n                    try {\n                        els = dom.querySelectorAll(\n                            element.ownerDocument,\n                            selector\n                        );\n                    } catch (e) {\n                        if (__DEV__) {\n                            // This should never happen, unless there is some bug in buildElementSelector().\n                            console.error(\n                                `Failed to querySelectorAll('${selector}')`\n                            );\n                        }\n                        continue;\n                    }\n\n                    for (let i = 0; i < els.length; i++) {\n                        const el = els[i] as HTMLElement;\n\n                        if (el && this._tabster.focusable.isFocusable(el)) {\n                            return el;\n                        }\n                    }\n                }\n            }\n        }\n\n        return null;\n    }\n\n    private _findFirst(element: HTMLElement): HTMLElement | null {\n        if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            const first = this._tabster.focusable.findFirst({\n                container: element,\n                useActiveModalizer: true,\n            });\n\n            if (first) {\n                return first;\n            }\n        }\n\n        return null;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateDeloserProps(props: Types.DeloserProps): void {\n    // TODO: Implement validation.\n}\n\nexport class DeloserAPI implements Types.DeloserAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    /**\n     * Tracks if focus is inside a deloser\n     */\n    private _inDeloser = false;\n    private _curDeloser: Types.Deloser | undefined;\n    private _history: DeloserHistory;\n    private _restoreFocusTimer: number | undefined;\n    private _isRestoringFocus = false;\n    private _isPaused = false;\n    private _autoDeloser: Types.DeloserProps | undefined;\n    private _autoDeloserInstance: Deloser | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        props?: { autoDeloser: Types.DeloserProps }\n    ) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._history = new DeloserHistory(tabster);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n            const doc = this._win().document;\n\n            doc.addEventListener(\n                DeloserRestoreFocusEventName,\n                this._onRestoreFocus\n            );\n\n            const activeElement = dom.getActiveElement(doc);\n\n            if (activeElement && activeElement !== doc.body) {\n                // Adding currently focused element to the deloser history.\n                this._onFocus(activeElement as HTMLElement);\n            }\n        });\n\n        const autoDeloser = props?.autoDeloser;\n        if (autoDeloser) {\n            this._autoDeloser = autoDeloser;\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._restoreFocusTimer) {\n            win.clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (this._autoDeloserInstance) {\n            this._autoDeloserInstance.dispose();\n            delete this._autoDeloserInstance;\n            delete this._autoDeloser;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.document.removeEventListener(\n            DeloserRestoreFocusEventName,\n            this._onRestoreFocus\n        );\n\n        this._history.dispose();\n\n        delete this._curDeloser;\n    }\n\n    createDeloser(\n        element: HTMLElement,\n        props: Types.DeloserProps\n    ): Types.Deloser {\n        if (__DEV__) {\n            validateDeloserProps(props);\n        }\n\n        const deloser = new Deloser(\n            this._tabster,\n            element,\n            this._onDeloserDispose,\n            props\n        );\n\n        if (\n            dom.nodeContains(\n                element,\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            this._activate(deloser);\n        }\n\n        return deloser;\n    }\n\n    getActions(element: HTMLElement): Types.DeloserElementActions | undefined {\n        for (\n            let e: HTMLElement | null = element;\n            e;\n            e = dom.getParentElement(e)\n        ) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (tabsterOnElement && tabsterOnElement.deloser) {\n                return tabsterOnElement.deloser.getActions();\n            }\n        }\n\n        return undefined;\n    }\n\n    pause(): void {\n        this._isPaused = true;\n\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n    }\n\n    resume(restore?: boolean): void {\n        this._isPaused = false;\n\n        if (restore) {\n            this._scheduleRestoreFocus();\n        }\n    }\n\n    private _onRestoreFocus = (event: DeloserRestoreFocusEvent): void => {\n        const target = event.composedPath()[0] as\n            | HTMLElement\n            | null\n            | undefined;\n\n        if (target) {\n            const available = DeloserAPI.getDeloser(\n                this._tabster,\n                target\n            )?.findAvailable();\n\n            if (available) {\n                this._tabster.focusedElement.focus(available);\n            }\n\n            event.stopImmediatePropagation();\n        }\n    };\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (this._restoreFocusTimer) {\n            this._win().clearTimeout(this._restoreFocusTimer);\n            this._restoreFocusTimer = undefined;\n        }\n\n        if (!e) {\n            this._scheduleRestoreFocus();\n\n            return;\n        }\n\n        const deloser = this._history.process(e);\n\n        if (deloser) {\n            this._activate(deloser);\n        } else {\n            this._deactivate();\n        }\n    };\n\n    /**\n     * Activates and sets the current deloser\n     */\n    private _activate(deloser: Types.Deloser) {\n        const curDeloser = this._curDeloser;\n        if (curDeloser !== deloser) {\n            this._inDeloser = true;\n            curDeloser?.setActive(false);\n            deloser.setActive(true);\n            this._curDeloser = deloser;\n        }\n    }\n\n    /**\n     * Called when focus should no longer be in a deloser\n     */\n    private _deactivate() {\n        this._inDeloser = false;\n        this._curDeloser?.setActive(false);\n        this._curDeloser = undefined;\n    }\n\n    private _scheduleRestoreFocus(force?: boolean): void {\n        if (this._isPaused || this._isRestoringFocus) {\n            return;\n        }\n\n        const restoreFocus = async () => {\n            this._restoreFocusTimer = undefined;\n            const lastFocused =\n                this._tabster.focusedElement.getLastFocusedElement();\n\n            if (\n                !force &&\n                (this._isRestoringFocus ||\n                    !this._inDeloser ||\n                    (lastFocused && !isDisplayNone(lastFocused)))\n            ) {\n                return;\n            }\n\n            const curDeloser = this._curDeloser;\n            let isManual = false;\n\n            if (curDeloser) {\n                if (\n                    lastFocused &&\n                    curDeloser.customFocusLostHandler(lastFocused)\n                ) {\n                    return;\n                }\n\n                if (curDeloser.strategy === Types.DeloserStrategies.Manual) {\n                    isManual = true;\n                } else {\n                    const curDeloserElement = curDeloser.getElement();\n                    const el = curDeloser.findAvailable();\n\n                    if (\n                        el &&\n                        (!curDeloserElement?.dispatchEvent(\n                            new TabsterMoveFocusEvent({\n                                by: \"deloser\",\n                                owner: curDeloserElement,\n                                next: el,\n                            })\n                        ) ||\n                            this._tabster.focusedElement.focus(el))\n                    ) {\n                        return;\n                    }\n                }\n            }\n\n            this._deactivate();\n\n            if (isManual) {\n                return;\n            }\n\n            this._isRestoringFocus = true;\n\n            // focusAvailable returns null when the default action is prevented by the application, false\n            // when nothing was focused and true when something was focused.\n            if ((await this._history.focusAvailable(null)) === false) {\n                await this._history.resetFocus(null);\n            }\n\n            this._isRestoringFocus = false;\n        };\n\n        if (force) {\n            restoreFocus();\n        } else {\n            this._restoreFocusTimer = this._win().setTimeout(restoreFocus, 100);\n        }\n    }\n\n    static getDeloser(\n        tabster: Types.TabsterCore,\n        element: HTMLElement\n    ): Types.Deloser | undefined {\n        let root: Types.Root | undefined;\n\n        for (\n            let e: HTMLElement | null = element;\n            e;\n            e = dom.getParentElement(e)\n        ) {\n            const tabsterOnElement = getTabsterOnElement(tabster, e);\n\n            if (tabsterOnElement) {\n                if (!root) {\n                    root = tabsterOnElement.root;\n                }\n\n                const deloser = tabsterOnElement.deloser;\n\n                if (deloser) {\n                    return deloser;\n                }\n            }\n        }\n\n        const deloserAPI = tabster.deloser && (tabster.deloser as DeloserAPI);\n\n        if (deloserAPI) {\n            if (deloserAPI._autoDeloserInstance) {\n                return deloserAPI._autoDeloserInstance;\n            }\n\n            const autoDeloserProps = deloserAPI._autoDeloser;\n\n            if (root && !deloserAPI._autoDeloserInstance && autoDeloserProps) {\n                const body = element.ownerDocument?.body;\n\n                if (body) {\n                    deloserAPI._autoDeloserInstance = new Deloser(\n                        tabster,\n                        body,\n                        (tabster.deloser as DeloserAPI)._onDeloserDispose,\n                        autoDeloserProps\n                    );\n                }\n            }\n\n            return deloserAPI._autoDeloserInstance;\n        }\n\n        return undefined;\n    }\n\n    private _onDeloserDispose = (deloser: Deloser) => {\n        this._history.removeDeloser(deloser);\n\n        if (deloser.isActive()) {\n            this._scheduleRestoreFocus();\n        }\n    };\n\n    static getHistory(instance: Types.DeloserAPI): DeloserHistory {\n        return (instance as DeloserAPI)._history;\n    }\n\n    static forceRestoreFocus(instance: Types.DeloserAPI): void {\n        (instance as DeloserAPI)._scheduleRestoreFocus(true);\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"../Types\";\n\nexport abstract class Subscribable<A, B = undefined>\n    implements Types.Subscribable<A, B>\n{\n    protected _val: A | undefined;\n    private _callbacks: Types.SubscribableCallback<A, B>[] = [];\n\n    dispose(): void {\n        this._callbacks = [];\n        delete this._val;\n    }\n\n    subscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index < 0) {\n            callbacks.push(callback);\n        }\n    }\n\n    subscribeFirst(callback: Types.SubscribableCallback<A, B>): void {\n        const callbacks = this._callbacks;\n        const index = callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            callbacks.splice(index, 1);\n        }\n\n        callbacks.unshift(callback);\n    }\n\n    unsubscribe(callback: Types.SubscribableCallback<A, B>): void {\n        const index = this._callbacks.indexOf(callback);\n\n        if (index >= 0) {\n            this._callbacks.splice(index, 1);\n        }\n    }\n\n    protected setVal(val: A, detail: B): void {\n        if (this._val === val) {\n            return;\n        }\n\n        this._val = val;\n\n        this._callCallbacks(val, detail);\n    }\n\n    protected getVal(): A | undefined {\n        return this._val;\n    }\n\n    protected trigger(val: A, detail: B): void {\n        this._callCallbacks(val, detail);\n    }\n\n    private _callCallbacks(val: A, detail: B): void {\n        this._callbacks.forEach((callback) => callback(val, detail));\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    DeloserAPI,\n    DeloserHistoryByRootBase,\n    DeloserItemBase,\n} from \"./Deloser\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { Subscribable } from \"./State/Subscribable\";\nimport * as Types from \"./Types\";\nimport {\n    getElementUId,\n    getInstanceContext,\n    getPromise,\n    getUId,\n    getWindowUId,\n    HTMLElementWithUID,\n} from \"./Utils\";\nimport { dom } from \"./DOMAPI\";\n\nconst _transactionTimeout = 1500;\nconst _pingTimeout = 3000;\n\nconst _targetIdUp = \"up\";\n\nconst CrossOriginTransactionTypes: Types.CrossOriginTransactionTypes = {\n    Bootstrap: 1,\n    FocusElement: 2,\n    State: 3,\n    GetElement: 4,\n    RestoreFocusInDeloser: 5,\n    Ping: 6,\n};\n\ninterface CrossOriginInstanceContext {\n    ignoreKeyboardNavigationStateUpdate: boolean;\n    focusOwner?: string;\n    focusOwnerTimestamp?: number;\n    deloserByUId: { [uid: string]: Types.Deloser };\n    origOutlineSetup?: (props?: Partial<Types.OutlineProps>) => void;\n}\n\ninterface KnownTargets {\n    [id: string]: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        send: (payload: Types.CrossOriginTransactionData<any, any>) => void;\n        last?: number;\n    };\n}\n\nclass CrossOriginDeloserItem extends DeloserItemBase<CrossOriginDeloser> {\n    private _deloser: CrossOriginDeloser;\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        deloser: CrossOriginDeloser,\n        trasactions: CrossOriginTransactions\n    ) {\n        super();\n        this._deloser = deloser;\n        this._transactions = trasactions;\n    }\n\n    belongsTo(deloser: CrossOriginDeloser): boolean {\n        return deloser.deloserUId === this._deloser.deloserUId;\n    }\n\n    async focusAvailable(): Promise<boolean | null> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: false,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n\n    async resetFocus(): Promise<boolean> {\n        const data: RestoreFocusInDeloserTransactionData = {\n            ...this._deloser,\n            reset: true,\n        };\n\n        return this._transactions\n            .beginTransaction(RestoreFocusInDeloserTransaction, data)\n            .then((value) => !!value);\n    }\n}\n\nclass CrossOriginDeloserHistoryByRoot extends DeloserHistoryByRootBase<\n    CrossOriginDeloser,\n    CrossOriginDeloserItem\n> {\n    private _transactions: CrossOriginTransactions;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        rootUId: string,\n        transactions: CrossOriginTransactions\n    ) {\n        super(tabster, rootUId);\n        this._transactions = transactions;\n    }\n\n    unshift(deloser: CrossOriginDeloser): void {\n        let item: CrossOriginDeloserItem | undefined;\n\n        for (let i = 0; i < this._history.length; i++) {\n            if (this._history[i].belongsTo(deloser)) {\n                item = this._history[i];\n                this._history.splice(i, 1);\n                break;\n            }\n        }\n\n        if (!item) {\n            item = new CrossOriginDeloserItem(\n                this._tabster,\n                deloser,\n                this._transactions\n            );\n        }\n\n        this._history.unshift(item);\n\n        this._history.splice(10, this._history.length - 10);\n    }\n\n    async focusAvailable(): Promise<boolean | null> {\n        for (const i of this._history) {\n            if (await i.focusAvailable()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    async resetFocus(): Promise<boolean> {\n        for (const i of this._history) {\n            if (await i.resetFocus()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n\nabstract class CrossOriginTransaction<I, O> {\n    abstract type: Types.CrossOriginTransactionType;\n    readonly id: string;\n    readonly beginData: I;\n    readonly timeout?: number;\n    protected tabster: Types.TabsterCore;\n    protected endData: O | undefined;\n    protected owner: Types.GetWindow;\n    protected ownerId: string;\n    protected sendUp: Types.CrossOriginTransactionSend | undefined;\n    private _promise: Promise<O>;\n    protected _resolve: ((endData?: O | PromiseLike<O>) => void) | undefined;\n    private _reject: ((reason: string) => void) | undefined;\n    private _knownTargets: KnownTargets;\n    private _sentTo: Types.CrossOriginSentTo;\n    protected targetId: string | undefined;\n    private _inProgress: { [id: string]: boolean } = {};\n    private _isDone = false;\n    private _isSelfResponding = false;\n    private _sentCount = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ) {\n        this.tabster = tabster;\n        this.owner = getOwner;\n        this.ownerId = getWindowUId(getOwner());\n        this.id = getUId(getOwner());\n        this.beginData = value;\n        this._knownTargets = knownTargets;\n        this._sentTo = sentTo || { [this.ownerId]: true };\n        this.targetId = targetId;\n        this.sendUp = sendUp;\n        this.timeout = timeout;\n        this._promise = new (getPromise(getOwner))<O>((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n    }\n\n    protected getTargets(knownTargets: KnownTargets): KnownTargets | null {\n        return this.targetId === _targetIdUp\n            ? this.sendUp\n                ? { [_targetIdUp]: { send: this.sendUp } }\n                : null\n            : this.targetId\n            ? knownTargets[this.targetId]\n                ? {\n                      [this.targetId]: {\n                          send: knownTargets[this.targetId].send,\n                      },\n                  }\n                : null\n            : Object.keys(knownTargets).length === 0 && this.sendUp\n            ? { [_targetIdUp]: { send: this.sendUp } }\n            : Object.keys(knownTargets).length > 0\n            ? knownTargets\n            : null;\n    }\n\n    begin(\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>\n    ): Promise<O | undefined> {\n        const targets = this.getTargets(this._knownTargets);\n        const sentTo: Types.CrossOriginSentTo = { ...this._sentTo };\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                sentTo[id] = true;\n            }\n        }\n\n        const data: Types.CrossOriginTransactionData<I, O> = {\n            transaction: this.id,\n            type: this.type,\n            isResponse: false,\n            timestamp: Date.now(),\n            owner: this.ownerId,\n            sentto: sentTo,\n            timeout: this.timeout,\n            beginData: this.beginData,\n        };\n\n        if (this.targetId) {\n            data.target = this.targetId;\n        }\n\n        if (selfResponse) {\n            this._isSelfResponding = true;\n\n            selfResponse(data).then((value) => {\n                this._isSelfResponding = false;\n\n                if (value !== undefined) {\n                    if (!this.endData) {\n                        this.endData = value;\n                    }\n                }\n\n                if (this.endData || this._sentCount === 0) {\n                    this.end();\n                }\n            });\n        }\n\n        if (targets) {\n            for (const id of Object.keys(targets)) {\n                if (!(id in this._sentTo)) {\n                    this._send(targets[id].send, id, data);\n                }\n            }\n        }\n\n        if (this._sentCount === 0 && !this._isSelfResponding) {\n            this.end();\n        }\n\n        return this._promise;\n    }\n\n    private _send(\n        send: (data: Types.CrossOriginTransactionData<I, O>) => void,\n        targetId: string,\n        data: Types.CrossOriginTransactionData<I, O>\n    ) {\n        if (this._inProgress[targetId] === undefined) {\n            this._inProgress[targetId] = true;\n            this._sentCount++;\n            send(data);\n        }\n    }\n\n    end(error?: string): void {\n        if (this._isDone) {\n            return;\n        }\n\n        this._isDone = true;\n\n        if (this.endData === undefined && error) {\n            if (this._reject) {\n                this._reject(error);\n            }\n        } else if (this._resolve) {\n            this._resolve(this.endData);\n        }\n    }\n\n    onResponse(data: Types.CrossOriginTransactionData<I, O>): void {\n        const endData = data.endData;\n\n        if (endData !== undefined && !this.endData) {\n            this.endData = endData;\n        }\n\n        const inProgressId =\n            data.target === _targetIdUp ? _targetIdUp : data.owner;\n\n        if (this._inProgress[inProgressId]) {\n            this._inProgress[inProgressId] = false;\n            this._sentCount--;\n\n            if (\n                this.endData ||\n                (this._sentCount === 0 && !this._isSelfResponding)\n            ) {\n                this.end();\n            }\n        }\n    }\n}\n\ninterface CrossOriginTransactionClass<I, O> {\n    new (\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        knownTargets: KnownTargets,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        sendUp?: Types.CrossOriginTransactionSend\n    ): CrossOriginTransaction<I, O>;\n    shouldForward?(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n    makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<I, O>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<O | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<O>;\n    shouldSelfRespond?(\n        tabster: Types.TabsterCore,\n        data: I,\n        getOwner: Types.GetWindow,\n        ownerId: string\n    ): boolean;\n}\n\ninterface BootstrapTransactionContents {\n    isNavigatingWithKeyboard: boolean;\n}\n\nclass BootstrapTransaction extends CrossOriginTransaction<\n    undefined,\n    BootstrapTransactionContents\n> {\n    type = CrossOriginTransactionTypes.Bootstrap;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore\n    ): Promise<BootstrapTransactionContents> {\n        return {\n            isNavigatingWithKeyboard:\n                tabster.keyboardNavigation.isNavigatingWithKeyboard(),\n        };\n    }\n}\n\ninterface CrossOriginElementDataIn {\n    uid?: string;\n    id?: string;\n    rootId?: string;\n    ownerId?: string;\n    observedName?: string;\n    /**\n     * Optionally wait if the element is accessible or focusable before returning it\n     */\n    accessibility?: Types.ObservedElementAccesibility;\n}\n\ninterface FocusElementData extends CrossOriginElementDataIn {\n    noFocusedProgrammaticallyFlag?: boolean;\n    noAccessibleCheck?: boolean;\n}\n\nclass FocusElementTransaction extends CrossOriginTransaction<\n    FocusElementData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.FocusElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static shouldForward(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow\n    ): boolean {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return !el || !tabster.focusable.isFocusable(el);\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<FocusElementData, boolean>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean> {\n        const el = GetElementTransaction.findElement(\n            tabster,\n            getOwner,\n            data.beginData\n        );\n        return (\n            (!!el && tabster.focusedElement.focus(el, true)) ||\n            !!(await forwardResult)\n        );\n    }\n}\n\nconst CrossOriginStates: {\n    Focused: 1;\n    Blurred: 2;\n    Observed: 3;\n    DeadWindow: 4;\n    KeyboardNavigation: 5;\n    Outline: 6;\n} = {\n    Focused: 1,\n    Blurred: 2,\n    Observed: 3,\n    DeadWindow: 4,\n    KeyboardNavigation: 5,\n    Outline: 6,\n};\ntype CrossOriginState =\n    typeof CrossOriginStates[keyof typeof CrossOriginStates];\n\ninterface CrossOriginElementDataOut {\n    ownerUId: string;\n    uid?: string;\n    id?: string;\n    rootUId?: string;\n    deloserUId?: string;\n    observedName?: string;\n    observedDetails?: string;\n}\n\ninterface CrossOriginStateData extends CrossOriginElementDataOut {\n    state: CrossOriginState;\n    isFocusedProgrammatically?: boolean;\n    force?: boolean;\n    isNavigatingWithKeyboard?: boolean;\n    outline?: Partial<Types.OutlineProps>;\n}\n\nclass StateTransaction extends CrossOriginTransaction<\n    CrossOriginStateData,\n    true\n> {\n    type = CrossOriginTransactionTypes.State;\n\n    static shouldSelfRespond(\n        tabster: Types.TabsterCore,\n        data: CrossOriginStateData\n    ): boolean {\n        return (\n            data.state !== CrossOriginStates.DeadWindow &&\n            data.state !== CrossOriginStates.KeyboardNavigation\n        );\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<CrossOriginStateData, true>,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const timestamp = data.timestamp;\n        const beginData = data.beginData;\n\n        if (timestamp && beginData) {\n            switch (beginData.state) {\n                case CrossOriginStates.Focused:\n                    return StateTransaction._makeFocusedResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions,\n                        isSelfResponse\n                    );\n                case CrossOriginStates.Blurred:\n                    return StateTransaction._makeBlurredResponse(\n                        tabster,\n                        timestamp,\n                        beginData,\n                        transactions.ctx\n                    );\n                case CrossOriginStates.Observed:\n                    return StateTransaction._makeObservedResponse(\n                        tabster,\n                        beginData\n                    );\n                case CrossOriginStates.DeadWindow:\n                    return StateTransaction._makeDeadWindowResponse(\n                        tabster,\n                        beginData,\n                        transactions,\n                        forwardResult\n                    );\n                case CrossOriginStates.KeyboardNavigation:\n                    return StateTransaction._makeKeyboardNavigationResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.isNavigatingWithKeyboard\n                    );\n                case CrossOriginStates.Outline:\n                    return StateTransaction._makeOutlineResponse(\n                        tabster,\n                        transactions.ctx,\n                        beginData.outline\n                    );\n            }\n        }\n\n        return true;\n    }\n\n    static createElement(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginElementDataOut\n    ): CrossOriginElement | null {\n        return beginData.uid\n            ? new CrossOriginElement(\n                  tabster,\n                  beginData.uid,\n                  beginData.ownerUId,\n                  beginData.id,\n                  beginData.rootUId,\n                  beginData.observedName,\n                  beginData.observedDetails\n              )\n            : null;\n    }\n\n    private static async _makeFocusedResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        isSelfResponse?: boolean\n    ): Promise<true> {\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (beginData && beginData.ownerUId && element) {\n            transactions.ctx.focusOwner = beginData.ownerUId;\n            transactions.ctx.focusOwnerTimestamp = timestamp;\n\n            if (!isSelfResponse && beginData.rootUId && beginData.deloserUId) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    const history = DeloserAPI.getHistory(deloserAPI);\n\n                    const deloser: CrossOriginDeloser = {\n                        ownerUId: beginData.ownerUId,\n                        deloserUId: beginData.deloserUId,\n                        rootUId: beginData.rootUId,\n                    };\n\n                    const historyItem = history.make(\n                        beginData.rootUId,\n                        () =>\n                            new CrossOriginDeloserHistoryByRoot(\n                                tabster,\n                                deloser.rootUId,\n                                transactions\n                            )\n                    );\n\n                    historyItem.unshift(deloser);\n                }\n            }\n\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                element,\n                {\n                    isFocusedProgrammatically:\n                        beginData.isFocusedProgrammatically,\n                }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeBlurredResponse(\n        tabster: Types.TabsterCore,\n        timestamp: number,\n        beginData: CrossOriginStateData,\n        context: CrossOriginInstanceContext\n    ): Promise<true> {\n        if (\n            beginData &&\n            (beginData.ownerUId === context.focusOwner || beginData.force) &&\n            (!context.focusOwnerTimestamp ||\n                context.focusOwnerTimestamp < timestamp)\n        ) {\n            CrossOriginFocusedElementState.setVal(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.focusedElement,\n                undefined,\n                {}\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeObservedResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData\n    ): Promise<true> {\n        const name = beginData.observedName;\n        const element = StateTransaction.createElement(tabster, beginData);\n\n        if (name && element) {\n            CrossOriginObservedElementState.trigger(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.crossOrigin!.observedElement,\n                element,\n                { names: [name], details: beginData.observedDetails }\n            );\n        }\n\n        return true;\n    }\n\n    private static async _makeDeadWindowResponse(\n        tabster: Types.TabsterCore,\n        beginData: CrossOriginStateData,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<true | undefined>\n    ): Promise<true> {\n        const deadUId = beginData && beginData.ownerUId;\n\n        if (deadUId) {\n            transactions.removeTarget(deadUId);\n        }\n\n        return forwardResult.then(() => {\n            if (deadUId === transactions.ctx.focusOwner) {\n                const deloserAPI = tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n            return true;\n        });\n    }\n\n    private static async _makeKeyboardNavigationResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        isNavigatingWithKeyboard?: boolean\n    ): Promise<true> {\n        if (\n            isNavigatingWithKeyboard !== undefined &&\n            tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                isNavigatingWithKeyboard\n        ) {\n            context.ignoreKeyboardNavigationStateUpdate = true;\n            tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                isNavigatingWithKeyboard\n            );\n            context.ignoreKeyboardNavigationStateUpdate = false;\n        }\n        return true;\n    }\n\n    private static async _makeOutlineResponse(\n        tabster: Types.TabsterCore,\n        context: CrossOriginInstanceContext,\n        props?: Partial<Types.OutlineProps>\n    ): Promise<true> {\n        if (context.origOutlineSetup) {\n            context.origOutlineSetup.call(\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tabster.outline!,\n                props\n            );\n        }\n        return true;\n    }\n}\n\nclass GetElementTransaction extends CrossOriginTransaction<\n    CrossOriginElementDataIn | undefined,\n    CrossOriginElementDataOut\n> {\n    type = CrossOriginTransactionTypes.GetElement;\n\n    static shouldSelfRespond() {\n        return true;\n    }\n\n    static findElement(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        data?: CrossOriginElementDataIn\n    ): HTMLElement | null {\n        let element: HTMLElement | null | undefined;\n\n        if (\n            data &&\n            (!data.ownerId || data.ownerId === getWindowUId(getOwner()))\n        ) {\n            if (data.id) {\n                element = dom.getElementById(getOwner().document, data.id);\n\n                if (element && data.rootId) {\n                    const ctx = RootAPI.getTabsterContext(tabster, element);\n\n                    if (!ctx || ctx.root.uid !== data.rootId) {\n                        return null;\n                    }\n                }\n            } else if (data.uid) {\n                const ref = getInstanceContext(getOwner).elementByUId[data.uid];\n                element = ref && ref.get();\n            } else if (data.observedName) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                element = tabster.observedElement!.getElement(\n                    data.observedName,\n                    data.accessibility\n                );\n            }\n        }\n\n        return element || null;\n    }\n\n    static getElementData(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext,\n        ownerUId: string\n    ): CrossOriginElementDataOut {\n        const deloser = DeloserAPI.getDeloser(tabster, element);\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const tabsterOnElement = getTabsterOnElement(tabster, element);\n        const observed = tabsterOnElement && tabsterOnElement.observed;\n\n        return {\n            uid: getElementUId(getOwner, element),\n            ownerUId,\n            id: element.id || undefined,\n            rootUId: ctx ? ctx.root.uid : undefined,\n            deloserUId: deloser\n                ? getDeloserUID(getOwner, context, deloser)\n                : undefined,\n            observedName: observed && observed.names && observed.names[0],\n            observedDetails: observed && observed.details,\n        };\n    }\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            CrossOriginElementDataIn | undefined,\n            CrossOriginElementDataOut\n        >,\n        getOwner: Types.GetWindow,\n        ownerUId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<CrossOriginElementDataOut | undefined>\n    ): Promise<CrossOriginElementDataOut | undefined> {\n        const beginData = data.beginData;\n        let element: HTMLElement | undefined;\n        let dataOut: CrossOriginElementDataOut | undefined;\n\n        if (beginData === undefined) {\n            element = tabster.focusedElement.getFocusedElement();\n        } else if (beginData) {\n            element =\n                GetElementTransaction.findElement(\n                    tabster,\n                    getOwner,\n                    beginData\n                ) || undefined;\n        }\n\n        if (!element && beginData) {\n            const name = beginData.observedName;\n            const timeout = data.timeout;\n            const accessibility = beginData.accessibility;\n\n            if (name && timeout) {\n                const e: {\n                    element?: HTMLElement | null;\n                    crossOrigin?: CrossOriginElementDataOut;\n                } = await new (getPromise(getOwner))((resolve) => {\n                    let isWaitElementResolved = false;\n                    let isForwardResolved = false;\n                    let isResolved = false;\n\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    tabster\n                        .observedElement!.waitElement(\n                            name,\n                            timeout,\n                            accessibility\n                        )\n                        .result.then((value) => {\n                            isWaitElementResolved = true;\n\n                            if (!isResolved && (value || isForwardResolved)) {\n                                isResolved = true;\n                                resolve({ element: value });\n                            }\n                        });\n\n                    forwardResult.then((value) => {\n                        isForwardResolved = true;\n\n                        if (!isResolved && (value || isWaitElementResolved)) {\n                            isResolved = true;\n                            resolve({ crossOrigin: value });\n                        }\n                    });\n                });\n\n                if (e.element) {\n                    element = e.element;\n                } else if (e.crossOrigin) {\n                    dataOut = e.crossOrigin;\n                }\n            }\n        }\n\n        return element\n            ? GetElementTransaction.getElementData(\n                  tabster,\n                  element,\n                  getOwner,\n                  transactions.ctx,\n                  ownerUId\n              )\n            : dataOut;\n    }\n}\n\ninterface CrossOriginDeloser {\n    ownerUId: string;\n    deloserUId: string;\n    rootUId: string;\n}\n\ninterface RestoreFocusInDeloserTransactionData extends CrossOriginDeloser {\n    reset: boolean;\n}\n\nclass RestoreFocusInDeloserTransaction extends CrossOriginTransaction<\n    RestoreFocusInDeloserTransactionData,\n    boolean\n> {\n    type = CrossOriginTransactionTypes.RestoreFocusInDeloser;\n\n    static async makeResponse(\n        tabster: Types.TabsterCore,\n        data: Types.CrossOriginTransactionData<\n            RestoreFocusInDeloserTransactionData,\n            boolean\n        >,\n        getOwner: Types.GetWindow,\n        ownerId: string,\n        transactions: CrossOriginTransactions,\n        forwardResult: Promise<boolean | undefined>\n    ): Promise<boolean | null> {\n        const forwardRet = await forwardResult;\n        const begin = !forwardRet && data.beginData;\n        const uid = begin && begin.deloserUId;\n        const deloser = uid && transactions.ctx.deloserByUId[uid];\n        const deloserAPI = tabster.deloser;\n\n        if (begin && deloser && deloserAPI) {\n            const history = DeloserAPI.getHistory(deloserAPI);\n            return begin.reset\n                ? history.resetFocus(deloser)\n                : history.focusAvailable(deloser);\n        }\n\n        return !!forwardRet;\n    }\n}\n\nclass PingTransaction extends CrossOriginTransaction<undefined, true> {\n    type = CrossOriginTransactionTypes.Ping;\n\n    static shouldForward() {\n        return false;\n    }\n\n    static async makeResponse(): Promise<true> {\n        return true;\n    }\n}\n\ninterface CrossOriginTransactionWrapper<I, O> {\n    transaction: CrossOriginTransaction<I, O>;\n    timer?: number;\n}\n\nclass CrossOriginTransactions {\n    private _owner: Types.GetWindow;\n    private _ownerUId: string;\n    private _knownTargets: KnownTargets = {};\n    private _transactions: {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        [id: string]: CrossOriginTransactionWrapper<any, any>;\n    } = {};\n    private _tabster: Types.TabsterCore;\n    private _pingTimer: number | undefined;\n    private _isDefaultSendUp = false;\n    private _deadPromise: Promise<true | undefined> | undefined;\n    isSetUp = false;\n    sendUp: Types.CrossOriginTransactionSend | undefined;\n    ctx: CrossOriginInstanceContext;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        getOwner: Types.GetWindow,\n        context: CrossOriginInstanceContext\n    ) {\n        this._tabster = tabster;\n        this._owner = getOwner;\n        this._ownerUId = getWindowUId(getOwner());\n        this.ctx = context;\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp) {\n            if (__DEV__) {\n                console.error(\"CrossOrigin is already set up.\");\n            }\n        } else {\n            this.isSetUp = true;\n\n            this.setSendUp(sendUp);\n\n            this._owner().addEventListener(\"pagehide\", this._onPageHide);\n\n            this._ping();\n        }\n\n        return this._onMessage;\n    }\n\n    setSendUp(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (!this.isSetUp) {\n            throw new Error(\"CrossOrigin is not set up.\");\n        }\n\n        this.sendUp = sendUp || undefined;\n\n        const owner = this._owner();\n\n        if (sendUp === undefined) {\n            if (!this._isDefaultSendUp) {\n                if (owner.document) {\n                    this._isDefaultSendUp = true;\n\n                    if (\n                        owner.parent &&\n                        owner.parent !== owner &&\n                        owner.parent.postMessage\n                    ) {\n                        this.sendUp = (\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            data: Types.CrossOriginTransactionData<any, any>\n                        ) => {\n                            owner.parent.postMessage(JSON.stringify(data), \"*\");\n                        };\n                    }\n\n                    owner.addEventListener(\"message\", this._onBrowserMessage);\n                }\n            }\n        } else if (this._isDefaultSendUp) {\n            owner.removeEventListener(\"message\", this._onBrowserMessage);\n            this._isDefaultSendUp = false;\n        }\n\n        return this._onMessage;\n    }\n\n    async dispose(): Promise<void> {\n        const owner = this._owner();\n\n        if (this._pingTimer) {\n            owner.clearTimeout(this._pingTimer);\n            this._pingTimer = undefined;\n        }\n\n        owner.removeEventListener(\"message\", this._onBrowserMessage);\n        owner.removeEventListener(\"pagehide\", this._onPageHide);\n\n        await this._dead();\n\n        delete this._deadPromise;\n\n        for (const id of Object.keys(this._transactions)) {\n            const t = this._transactions[id];\n\n            if (t.timer) {\n                owner.clearTimeout(t.timer);\n                delete t.timer;\n            }\n\n            t.transaction.end();\n        }\n\n        this._knownTargets = {};\n\n        delete this.sendUp;\n    }\n\n    beginTransaction<I, O>(\n        Transaction: CrossOriginTransactionClass<I, O>,\n        value: I,\n        timeout?: number,\n        sentTo?: Types.CrossOriginSentTo,\n        targetId?: string,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        if (!this._owner) {\n            return getPromise(this._owner).reject();\n        }\n\n        const transaction = new Transaction(\n            this._tabster,\n            this._owner,\n            this._knownTargets,\n            value,\n            timeout,\n            sentTo,\n            targetId,\n            this.sendUp\n        );\n        let selfResponse:\n            | ((\n                  data: Types.CrossOriginTransactionData<I, O>\n              ) => Promise<O | undefined>)\n            | undefined;\n\n        if (\n            Transaction.shouldSelfRespond &&\n            Transaction.shouldSelfRespond(\n                this._tabster,\n                value,\n                this._owner,\n                this._ownerUId\n            )\n        ) {\n            selfResponse = (data: Types.CrossOriginTransactionData<I, O>) => {\n                return Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    getPromise(this._owner).resolve(undefined),\n                    true\n                );\n            };\n        }\n\n        return this._beginTransaction(\n            transaction,\n            timeout,\n            selfResponse,\n            withReject\n        );\n    }\n\n    removeTarget(uid: string): void {\n        delete this._knownTargets[uid];\n    }\n\n    private _beginTransaction<I, O>(\n        transaction: CrossOriginTransaction<I, O>,\n        timeout?: number,\n        selfResponse?: (\n            data: Types.CrossOriginTransactionData<I, O>\n        ) => Promise<O | undefined>,\n        withReject?: boolean\n    ): Promise<O | undefined> {\n        const owner = this._owner();\n\n        const wrapper: CrossOriginTransactionWrapper<I, O> = {\n            transaction,\n            timer: owner.setTimeout(() => {\n                delete wrapper.timer;\n                transaction.end(\"Cross origin transaction timed out.\");\n            }, _transactionTimeout + (timeout || 0)),\n        };\n\n        this._transactions[transaction.id] = wrapper;\n\n        const ret = transaction.begin(selfResponse);\n\n        ret.catch(() => {\n            /**/\n        }).finally(() => {\n            if (wrapper.timer) {\n                owner.clearTimeout(wrapper.timer);\n            }\n            delete this._transactions[transaction.id];\n        });\n\n        return ret.then(\n            (value) => value,\n            withReject ? undefined : () => undefined\n        );\n    }\n\n    forwardTransaction(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        data: Types.CrossOriginTransactionData<any, any>\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): Promise<any> {\n        const owner = this._owner;\n        let targetId = data.target;\n\n        if (targetId === this._ownerUId) {\n            return getPromise(owner).resolve();\n        }\n\n        const Transaction = this._getTransactionClass(data.type);\n\n        if (Transaction) {\n            if (\n                Transaction.shouldForward === undefined ||\n                Transaction.shouldForward(\n                    this._tabster,\n                    data,\n                    owner,\n                    this._ownerUId\n                )\n            ) {\n                const sentTo = data.sentto;\n\n                if (targetId === _targetIdUp) {\n                    targetId = undefined;\n                    sentTo[this._ownerUId] = true;\n                }\n\n                delete sentTo[_targetIdUp];\n\n                return this._beginTransaction(\n                    new Transaction(\n                        this._tabster,\n                        owner,\n                        this._knownTargets,\n                        data.beginData,\n                        data.timeout,\n                        sentTo,\n                        targetId,\n                        this.sendUp\n                    ),\n                    data.timeout\n                );\n            } else {\n                return getPromise(owner).resolve();\n            }\n        }\n\n        return getPromise(owner).reject(\n            `Unknown transaction type ${data.type}`\n        );\n    }\n\n    private _getTransactionClass(\n        type: Types.CrossOriginTransactionType\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ): CrossOriginTransactionClass<any, any> | null {\n        switch (type) {\n            case CrossOriginTransactionTypes.Bootstrap:\n                return BootstrapTransaction;\n            case CrossOriginTransactionTypes.FocusElement:\n                return FocusElementTransaction;\n            case CrossOriginTransactionTypes.State:\n                return StateTransaction;\n            case CrossOriginTransactionTypes.GetElement:\n                return GetElementTransaction;\n            case CrossOriginTransactionTypes.RestoreFocusInDeloser:\n                return RestoreFocusInDeloserTransaction;\n            case CrossOriginTransactionTypes.Ping:\n                return PingTransaction;\n            default:\n                return null;\n        }\n    }\n\n    private _onMessage = (e: Types.CrossOriginMessage) => {\n        if (e.data.owner === this._ownerUId || !this._tabster) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const data: Types.CrossOriginTransactionData<any, any> = e.data;\n        let transactionId: string;\n\n        if (\n            !data ||\n            !(transactionId = data.transaction) ||\n            !data.type ||\n            !data.timestamp ||\n            !data.owner ||\n            !data.sentto\n        ) {\n            return;\n        }\n\n        let knownTarget = this._knownTargets[data.owner];\n\n        if (!knownTarget && e.send && data.owner !== this._ownerUId) {\n            knownTarget = this._knownTargets[data.owner] = { send: e.send };\n        }\n\n        if (knownTarget) {\n            knownTarget.last = Date.now();\n        }\n\n        if (data.isResponse) {\n            const t = this._transactions[transactionId];\n\n            if (t && t.transaction && t.transaction.type === data.type) {\n                t.transaction.onResponse(data);\n            }\n        } else {\n            const Transaction = this._getTransactionClass(data.type);\n\n            const forwardResult = this.forwardTransaction(data);\n\n            if (Transaction && e.send) {\n                Transaction.makeResponse(\n                    this._tabster,\n                    data,\n                    this._owner,\n                    this._ownerUId,\n                    this,\n                    forwardResult,\n                    false\n                ).then((r) => {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                    const response: Types.CrossOriginTransactionData<any, any> =\n                        {\n                            transaction: data.transaction,\n                            type: data.type,\n                            isResponse: true,\n                            timestamp: Date.now(),\n                            owner: this._ownerUId,\n                            timeout: data.timeout,\n                            sentto: {},\n                            target:\n                                data.target === _targetIdUp\n                                    ? _targetIdUp\n                                    : data.owner,\n                            endData: r,\n                        };\n\n                    e.send(response);\n                });\n            }\n        }\n    };\n\n    private _onPageHide = () => {\n        this._dead();\n    };\n\n    private async _dead(): Promise<void> {\n        if (!this._deadPromise && this.ctx.focusOwner === this._ownerUId) {\n            this._deadPromise = this.beginTransaction(StateTransaction, {\n                ownerUId: this._ownerUId,\n                state: CrossOriginStates.DeadWindow,\n            });\n        }\n\n        if (this._deadPromise) {\n            await this._deadPromise;\n        }\n    }\n\n    private async _ping(): Promise<void> {\n        if (this._pingTimer) {\n            return;\n        }\n\n        let deadWindows: { [key: string]: boolean } | undefined;\n        const now = Date.now();\n        const targets = Object.keys(this._knownTargets).filter(\n            (uid) => now - (this._knownTargets[uid].last || 0) > _pingTimeout\n        );\n\n        if (this.sendUp) {\n            targets.push(_targetIdUp);\n        }\n\n        if (targets.length) {\n            await getPromise(this._owner).all(\n                targets.map((uid) =>\n                    this.beginTransaction(\n                        PingTransaction,\n                        undefined,\n                        undefined,\n                        undefined,\n                        uid,\n                        true\n                    ).then(\n                        () => true,\n                        () => {\n                            if (uid !== _targetIdUp) {\n                                if (!deadWindows) {\n                                    deadWindows = {};\n                                }\n                                deadWindows[uid] = true;\n                                delete this._knownTargets[uid];\n                            }\n                            return false;\n                        }\n                    )\n                )\n            );\n        }\n\n        if (deadWindows) {\n            const focused = await this.beginTransaction(\n                GetElementTransaction,\n                undefined\n            );\n\n            if (\n                !focused &&\n                this.ctx.focusOwner &&\n                this.ctx.focusOwner in deadWindows\n            ) {\n                await this.beginTransaction(StateTransaction, {\n                    ownerUId: this._ownerUId,\n                    state: CrossOriginStates.Blurred,\n                    force: true,\n                });\n\n                const deloserAPI = this._tabster.deloser;\n\n                if (deloserAPI) {\n                    DeloserAPI.forceRestoreFocus(deloserAPI);\n                }\n            }\n        }\n\n        this._pingTimer = this._owner().setTimeout(() => {\n            this._pingTimer = undefined;\n            this._ping();\n        }, _pingTimeout);\n    }\n\n    private _onBrowserMessage = (e: MessageEvent) => {\n        if (e.source === this._owner()) {\n            return;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const send = (data: Types.CrossOriginTransactionData<any, any>) => {\n            if (e.source && e.source.postMessage) {\n                // eslint-disable-next-line @typescript-eslint/ban-types\n                (e.source.postMessage as Function)(JSON.stringify(data), \"*\");\n            }\n        };\n\n        try {\n            this._onMessage({\n                data: JSON.parse(e.data),\n                send,\n            });\n        } catch (e) {\n            /* Ignore */\n        }\n    };\n}\n\nexport class CrossOriginElement implements Types.CrossOriginElement {\n    private _tabster: Types.TabsterCore;\n    readonly uid: string;\n    readonly ownerId: string;\n    readonly id?: string;\n    readonly rootId?: string;\n    readonly observedName?: string;\n    readonly observedDetails?: string;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        uid: string,\n        ownerId: string,\n        id?: string,\n        rootId?: string,\n        observedName?: string,\n        observedDetails?: string\n    ) {\n        this._tabster = tabster;\n        this.uid = uid;\n        this.ownerId = ownerId;\n        this.id = id;\n        this.rootId = rootId;\n        this.observedName = observedName;\n        this.observedDetails = observedDetails;\n    }\n\n    focus(\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return this._tabster.crossOrigin!.focusedElement.focus(\n            this,\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n}\n\nexport class CrossOriginFocusedElementState\n    extends Subscribable<\n        CrossOriginElement | undefined,\n        Types.FocusedElementDetail\n    >\n    implements Types.CrossOriginFocusedElementState\n{\n    private _transactions: CrossOriginTransactions;\n\n    constructor(transactions: CrossOriginTransactions) {\n        super();\n        this._transactions = transactions;\n    }\n\n    async focus(\n        element: Types.CrossOriginElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            {\n                uid: element.uid,\n                id: element.id,\n                rootId: element.rootId,\n                ownerId: element.ownerId,\n                observedName: element.observedName,\n            },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusById(\n        elementId: string,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { id: elementId, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck\n        );\n    }\n\n    async focusByObservedName(\n        observedName: string,\n        timeout?: number,\n        rootId?: string,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): Promise<boolean> {\n        return this._focus(\n            { observedName, rootId },\n            noFocusedProgrammaticallyFlag,\n            noAccessibleCheck,\n            timeout\n        );\n    }\n\n    private async _focus(\n        elementData: CrossOriginElementDataIn,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean,\n        timeout?: number\n    ): Promise<boolean> {\n        return this._transactions\n            .beginTransaction(\n                FocusElementTransaction,\n                {\n                    ...elementData,\n                    noFocusedProgrammaticallyFlag,\n                    noAccessibleCheck,\n                },\n                timeout\n            )\n            .then((value) => !!value);\n    }\n\n    static setVal(\n        instance: Types.CrossOriginFocusedElementState,\n        val: CrossOriginElement | undefined,\n        detail: Types.FocusedElementDetail\n    ): void {\n        (instance as CrossOriginFocusedElementState).setVal(val, detail);\n    }\n}\n\nexport class CrossOriginObservedElementState\n    extends Subscribable<CrossOriginElement, Types.ObservedElementProps>\n    implements Types.CrossOriginObservedElementState\n{\n    private _tabster: Types.TabsterCore;\n    private _transactions: CrossOriginTransactions;\n    private _lastRequestFocusId = 0;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        transactions: CrossOriginTransactions\n    ) {\n        super();\n        this._tabster = tabster;\n        this._transactions = transactions;\n    }\n\n    async getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this.waitElement(observedName, 0, accessibility);\n    }\n\n    async waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Promise<CrossOriginElement | null> {\n        return this._transactions\n            .beginTransaction(\n                GetElementTransaction,\n                {\n                    observedName,\n                    accessibility,\n                },\n                timeout\n            )\n            .then((value) =>\n                value\n                    ? StateTransaction.createElement(this._tabster, value)\n                    : null\n            );\n    }\n\n    async requestFocus(\n        observedName: string,\n        timeout: number\n    ): Promise<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        return this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        ).then((element) =>\n            this._lastRequestFocusId === requestId && element\n                ? // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                  this._tabster.crossOrigin!.focusedElement.focus(element, true)\n                : false\n        );\n    }\n\n    static trigger(\n        instance: Types.CrossOriginObservedElementState,\n        element: CrossOriginElement,\n        details: Types.ObservedElementProps\n    ): void {\n        (instance as CrossOriginObservedElementState).trigger(element, details);\n    }\n}\n\nexport class CrossOriginAPI implements Types.CrossOriginAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _transactions: CrossOriginTransactions;\n    private _blurTimer: number | undefined;\n    private _ctx: CrossOriginInstanceContext;\n\n    focusedElement: Types.CrossOriginFocusedElementState;\n    observedElement: Types.CrossOriginObservedElementState;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._ctx = {\n            ignoreKeyboardNavigationStateUpdate: false,\n            deloserByUId: {},\n        };\n\n        this._transactions = new CrossOriginTransactions(\n            tabster,\n            this._win,\n            this._ctx\n        );\n        this.focusedElement = new CrossOriginFocusedElementState(\n            this._transactions\n        );\n        this.observedElement = new CrossOriginObservedElementState(\n            tabster,\n            this._transactions\n        );\n    }\n\n    setup(\n        sendUp?: Types.CrossOriginTransactionSend | null\n    ): (msg: Types.CrossOriginMessage) => void {\n        if (this.isSetUp()) {\n            return this._transactions.setSendUp(sendUp);\n        } else {\n            this._tabster.queueInit(this._init);\n            return this._transactions.setup(sendUp);\n        }\n    }\n\n    isSetUp(): boolean {\n        return this._transactions.isSetUp;\n    }\n\n    private _init = (): void => {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.subscribe(this._onFocus);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tabster.observedElement!.subscribe(this._onObserved);\n\n        if (!this._ctx.origOutlineSetup) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this._ctx.origOutlineSetup = tabster.outline!.setup;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            tabster.outline!.setup = this._outlineSetup;\n        }\n\n        this._transactions\n            .beginTransaction(\n                BootstrapTransaction,\n                undefined,\n                undefined,\n                undefined,\n                _targetIdUp\n            )\n            .then((data) => {\n                if (\n                    data &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() !==\n                        data.isNavigatingWithKeyboard\n                ) {\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = true;\n                    this._tabster.keyboardNavigation.setNavigatingWithKeyboard(\n                        data.isNavigatingWithKeyboard\n                    );\n                    this._ctx.ignoreKeyboardNavigationStateUpdate = false;\n                }\n            });\n    };\n\n    dispose(): void {\n        const tabster = this._tabster;\n\n        tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        tabster.focusedElement.unsubscribe(this._onFocus);\n        tabster.observedElement?.unsubscribe(this._onObserved);\n\n        this._transactions.dispose();\n        this.focusedElement.dispose();\n        this.observedElement.dispose();\n\n        this._ctx.deloserByUId = {};\n    }\n\n    private _onKeyboardNavigationStateChanged = (value: boolean): void => {\n        if (!this._ctx.ignoreKeyboardNavigationStateUpdate) {\n            this._transactions.beginTransaction(StateTransaction, {\n                state: CrossOriginStates.KeyboardNavigation,\n                ownerUId: getWindowUId(this._win()),\n                isNavigatingWithKeyboard: value,\n            });\n        }\n    };\n\n    private _onFocus = (element: HTMLElementWithUID | undefined): void => {\n        const win = this._win();\n\n        const ownerUId = getWindowUId(win);\n\n        if (this._blurTimer) {\n            win.clearTimeout(this._blurTimer);\n            this._blurTimer = undefined;\n        }\n\n        if (element) {\n            this._transactions.beginTransaction(StateTransaction, {\n                ...GetElementTransaction.getElementData(\n                    this._tabster,\n                    element,\n                    this._win,\n                    this._ctx,\n                    ownerUId\n                ),\n                state: CrossOriginStates.Focused,\n            });\n        } else {\n            this._blurTimer = win.setTimeout(() => {\n                this._blurTimer = undefined;\n\n                if (this._ctx.focusOwner && this._ctx.focusOwner === ownerUId) {\n                    this._transactions\n                        .beginTransaction(GetElementTransaction, undefined)\n                        .then((value) => {\n                            if (!value && this._ctx.focusOwner === ownerUId) {\n                                this._transactions.beginTransaction(\n                                    StateTransaction,\n                                    {\n                                        ownerUId,\n                                        state: CrossOriginStates.Blurred,\n                                        force: false,\n                                    }\n                                );\n                            }\n                        });\n                }\n            }, 0);\n        }\n    };\n\n    private _onObserved = (\n        element: HTMLElement,\n        details: Types.ObservedElementProps\n    ): void => {\n        const d = GetElementTransaction.getElementData(\n            this._tabster,\n            element,\n            this._win,\n            this._ctx,\n            getWindowUId(this._win())\n        ) as CrossOriginStateData;\n\n        d.state = CrossOriginStates.Observed;\n        d.observedName = details.names?.[0];\n        d.observedDetails = details.details;\n\n        this._transactions.beginTransaction(StateTransaction, d);\n    };\n\n    private _outlineSetup = (props?: Partial<Types.OutlineProps>): void => {\n        this._transactions.beginTransaction(StateTransaction, {\n            state: CrossOriginStates.Outline,\n            ownerUId: getWindowUId(this._win()),\n            outline: props,\n        });\n    };\n}\n\nfunction getDeloserUID(\n    getWindow: Types.GetWindow,\n    context: CrossOriginInstanceContext,\n    deloser: Types.Deloser\n): string | undefined {\n    const deloserElement = deloser.getElement();\n\n    if (deloserElement) {\n        const uid = getElementUId(getWindow, deloserElement);\n\n        if (!context.deloserByUId[uid]) {\n            context.deloserByUId[uid] = deloser;\n        }\n\n        return uid;\n    }\n\n    return undefined;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getLastChild,\n    matchesSelector,\n    shouldIgnoreFocus,\n    HTMLElementWithDummyContainer,\n    isDisplayNone,\n} from \"./Utils\";\nimport { dom } from \"./DOMAPI\";\n\nexport class FocusableAPI implements Types.FocusableAPI {\n    private _tabster: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n    }\n\n    dispose(): void {\n        /**/\n    }\n\n    getProps(element: HTMLElement): Types.FocusableProps {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n        return (tabsterOnElement && tabsterOnElement.focusable) || {};\n    }\n\n    isFocusable(\n        el: HTMLElement,\n        includeProgrammaticallyFocusable?: boolean,\n        noVisibleCheck?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            matchesSelector(el, Types.FocusableSelector) &&\n            (includeProgrammaticallyFocusable || el.tabIndex !== -1)\n        ) {\n            return (\n                (noVisibleCheck || this.isVisible(el)) &&\n                (noAccessibleCheck || this.isAccessible(el))\n            );\n        }\n\n        return false;\n    }\n\n    isVisible(el: HTMLElement): boolean {\n        if (!el.ownerDocument || el.nodeType !== Node.ELEMENT_NODE) {\n            return false;\n        }\n\n        if (isDisplayNone(el)) {\n            return false;\n        }\n\n        const rect = el.ownerDocument.body.getBoundingClientRect();\n\n        if (rect.width === 0 && rect.height === 0) {\n            // This might happen, for example, if our <body> is in hidden <iframe>.\n            return false;\n        }\n\n        return true;\n    }\n\n    isAccessible(el: HTMLElement): boolean {\n        for (let e: HTMLElement | null = el; e; e = dom.getParentElement(e)) {\n            const tabsterOnElement = getTabsterOnElement(this._tabster, e);\n\n            if (this._isHidden(e)) {\n                return false;\n            }\n\n            const ignoreDisabled =\n                tabsterOnElement?.focusable?.ignoreAriaDisabled;\n\n            if (!ignoreDisabled && this._isDisabled(e)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private _isDisabled(el: HTMLElement): boolean {\n        return el.hasAttribute(\"disabled\");\n    }\n\n    private _isHidden(el: HTMLElement): boolean {\n        const attrVal = el.getAttribute(\"aria-hidden\");\n\n        if (attrVal && attrVal.toLowerCase() === \"true\") {\n            if (!this._tabster.modalizer?.isAugmented(el)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    findFirst(\n        options: Types.FindFirstProps,\n        out?: Types.FindFocusableOutputProps\n    ): HTMLElement | null | undefined {\n        return this.findElement(\n            {\n                ...options,\n            },\n            out\n        );\n    }\n\n    findLast(\n        options: Types.FindFirstProps,\n        out?: Types.FindFocusableOutputProps\n    ): HTMLElement | null | undefined {\n        return this.findElement(\n            {\n                isBackward: true,\n                ...options,\n            },\n            out\n        );\n    }\n\n    findNext(\n        options: Types.FindNextProps,\n        out?: Types.FindFocusableOutputProps\n    ): HTMLElement | null | undefined {\n        return this.findElement({ ...options }, out);\n    }\n\n    findPrev(\n        options: Types.FindNextProps,\n        out?: Types.FindFocusableOutputProps\n    ): HTMLElement | null | undefined {\n        return this.findElement({ ...options, isBackward: true }, out);\n    }\n\n    findDefault(\n        options: Types.FindDefaultProps,\n        out?: Types.FindFocusableOutputProps\n    ): HTMLElement | null {\n        return (\n            this.findElement(\n                {\n                    ...options,\n                    acceptCondition: (el) =>\n                        this.isFocusable(\n                            el,\n                            options.includeProgrammaticallyFocusable\n                        ) && !!this.getProps(el).isDefault,\n                },\n                out\n            ) || null\n        );\n    }\n\n    findAll(options: Types.FindAllProps): HTMLElement[] {\n        return this._findElements(true, options) || [];\n    }\n\n    findElement(\n        options: Types.FindFocusableProps,\n        out?: Types.FindFocusableOutputProps\n    ): HTMLElement | null | undefined {\n        const found = this._findElements(false, options, out);\n        return found ? found[0] : found;\n    }\n\n    private _findElements(\n        findAll: boolean,\n        options: Types.FindFocusableProps,\n        out?: Types.FindFocusableOutputProps\n    ): HTMLElement[] | null | undefined {\n        const {\n            container,\n            currentElement = null,\n            includeProgrammaticallyFocusable,\n            useActiveModalizer,\n            ignoreAccessibility,\n            modalizerId,\n            isBackward,\n            onElement,\n        } = options;\n\n        if (!out) {\n            out = {};\n        }\n\n        const elements: HTMLElement[] = [];\n\n        let { acceptCondition } = options;\n        const hasCustomCondition = !!acceptCondition;\n\n        if (!container) {\n            return null;\n        }\n\n        if (!acceptCondition) {\n            acceptCondition = (el) =>\n                this.isFocusable(\n                    el,\n                    includeProgrammaticallyFocusable,\n                    false,\n                    ignoreAccessibility\n                );\n        }\n\n        const acceptElementState: Types.FocusableAcceptElementState = {\n            container,\n            modalizerUserId:\n                modalizerId === undefined && useActiveModalizer\n                    ? this._tabster.modalizer?.activeId\n                    : modalizerId ||\n                      RootAPI.getTabsterContext(this._tabster, container)\n                          ?.modalizer?.userId,\n            from: currentElement || container,\n            isBackward,\n            acceptCondition,\n            hasCustomCondition,\n            includeProgrammaticallyFocusable,\n            ignoreAccessibility,\n            cachedGrouppers: {},\n        };\n\n        const walker = createElementTreeWalker(\n            container.ownerDocument,\n            container,\n            (node) =>\n                this._acceptElement(node as HTMLElement, acceptElementState)\n        );\n\n        if (!walker) {\n            return null;\n        }\n\n        const prepareForNextElement = (\n            shouldContinueIfNotFound?: boolean\n        ): boolean => {\n            const foundElement =\n                acceptElementState.foundElement ??\n                acceptElementState.foundBackward;\n\n            if (foundElement) {\n                elements.push(foundElement);\n            }\n\n            if (findAll) {\n                if (foundElement) {\n                    acceptElementState.found = false;\n                    delete acceptElementState.foundElement;\n                    delete acceptElementState.foundBackward;\n                    delete acceptElementState.fromCtx;\n                    acceptElementState.from = foundElement;\n\n                    if (onElement && !onElement(foundElement)) {\n                        return false;\n                    }\n                }\n\n                return !!(foundElement || shouldContinueIfNotFound);\n            } else {\n                if (foundElement && out) {\n                    out.uncontrolled = RootAPI.getTabsterContext(\n                        this._tabster,\n                        foundElement\n                    )?.uncontrolled;\n                }\n\n                return !!(shouldContinueIfNotFound && !foundElement);\n            }\n        };\n\n        if (!currentElement) {\n            out.outOfDOMOrder = true;\n        }\n\n        if (currentElement && dom.nodeContains(container, currentElement)) {\n            walker.currentNode = currentElement;\n        } else if (isBackward) {\n            const lastChild = getLastChild(container);\n\n            if (!lastChild) {\n                return null;\n            }\n\n            if (\n                this._acceptElement(lastChild, acceptElementState) ===\n                    NodeFilter.FILTER_ACCEPT &&\n                !prepareForNextElement(true)\n            ) {\n                if (acceptElementState.skippedFocusable) {\n                    out.outOfDOMOrder = true;\n                }\n\n                return elements;\n            }\n\n            walker.currentNode = lastChild;\n        }\n\n        do {\n            if (isBackward) {\n                walker.previousNode();\n            } else {\n                walker.nextNode();\n            }\n        } while (prepareForNextElement());\n\n        if (acceptElementState.skippedFocusable) {\n            out.outOfDOMOrder = true;\n        }\n\n        return elements.length ? elements : null;\n    }\n\n    private _acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number {\n        if (state.found) {\n            return NodeFilter.FILTER_ACCEPT;\n        }\n\n        const foundBackward = state.foundBackward;\n\n        if (\n            foundBackward &&\n            (element === foundBackward ||\n                !dom.nodeContains(foundBackward, element))\n        ) {\n            state.found = true;\n            state.foundElement = foundBackward;\n            return NodeFilter.FILTER_ACCEPT;\n        }\n\n        const container = state.container;\n\n        if (element === container) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (!dom.nodeContains(container, element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        if (\n            (element as HTMLElementWithDummyContainer).__tabsterDummyContainer\n        ) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        if (dom.nodeContains(state.rejectElementsFrom, element)) {\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        const ctx = (state.currentCtx = RootAPI.getTabsterContext(\n            this._tabster,\n            element\n        ));\n\n        // Tabster is opt in, if it is not managed, don't try and get do anything special\n        if (!ctx) {\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        if (shouldIgnoreFocus(element)) {\n            if (this.isFocusable(element, undefined, true, true)) {\n                state.skippedFocusable = true;\n            }\n\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        // We assume iframes are focusable because native tab behaviour would tab inside.\n        // But we do it only during the standard search when there is no custom accept\n        // element condition.\n        if (\n            !state.hasCustomCondition &&\n            (element.tagName === \"IFRAME\" || element.tagName === \"WEBVIEW\")\n        ) {\n            if (ctx.modalizer?.userId === this._tabster.modalizer?.activeId) {\n                state.found = true;\n                state.rejectElementsFrom = state.foundElement = element;\n\n                return NodeFilter.FILTER_ACCEPT;\n            } else {\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        if (!state.ignoreAccessibility && !this.isAccessible(element)) {\n            if (this.isFocusable(element, false, true, true)) {\n                state.skippedFocusable = true;\n            }\n\n            return NodeFilter.FILTER_REJECT;\n        }\n\n        let result: number | undefined;\n\n        let fromCtx = state.fromCtx;\n\n        if (!fromCtx) {\n            fromCtx = state.fromCtx = RootAPI.getTabsterContext(\n                this._tabster,\n                state.from\n            );\n        }\n\n        const fromMover = fromCtx?.mover;\n        let groupper = ctx.groupper;\n        let mover = ctx.mover;\n\n        result = this._tabster.modalizer?.acceptElement(element, state);\n\n        if (result !== undefined) {\n            state.skippedFocusable = true;\n        }\n\n        if (result === undefined && (groupper || mover || fromMover)) {\n            const groupperElement = groupper?.getElement();\n            const fromMoverElement = fromMover?.getElement();\n            let moverElement = mover?.getElement();\n\n            if (\n                moverElement &&\n                dom.nodeContains(fromMoverElement, moverElement) &&\n                dom.nodeContains(container, fromMoverElement) &&\n                (!groupperElement ||\n                    !mover ||\n                    dom.nodeContains(fromMoverElement, groupperElement))\n            ) {\n                mover = fromMover;\n                moverElement = fromMoverElement;\n            }\n\n            if (\n                groupperElement &&\n                (groupperElement === container ||\n                    !dom.nodeContains(container, groupperElement))\n            ) {\n                groupper = undefined;\n            }\n\n            if (moverElement && !dom.nodeContains(container, moverElement)) {\n                mover = undefined;\n            }\n\n            if (groupper && mover) {\n                if (\n                    moverElement &&\n                    groupperElement &&\n                    !dom.nodeContains(groupperElement, moverElement)\n                ) {\n                    mover = undefined;\n                } else {\n                    groupper = undefined;\n                }\n            }\n\n            if (groupper) {\n                result = groupper.acceptElement(element, state);\n            }\n\n            if (mover) {\n                result = mover.acceptElement(element, state);\n            }\n        }\n\n        if (result === undefined) {\n            result = state.acceptCondition(element)\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_SKIP;\n\n            if (\n                result === NodeFilter.FILTER_SKIP &&\n                this.isFocusable(element, false, true, true)\n            ) {\n                state.skippedFocusable = true;\n            }\n        }\n\n        if (result === NodeFilter.FILTER_ACCEPT && !state.found) {\n            if (state.isBackward) {\n                // When TreeWalker goes backwards, it visits the container first,\n                // then it goes inside. So, if the container is accepted, we remember it,\n                // but allowing the TreeWalker to check inside.\n                state.foundBackward = element;\n                result = NodeFilter.FILTER_SKIP;\n            } else {\n                state.found = true;\n                state.foundElement = element;\n            }\n        }\n\n        return result;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport const Keys: {\n    Tab: \"Tab\";\n    Enter: \"Enter\";\n    Escape: \"Escape\";\n    Space: \" \";\n    PageUp: \"PageUp\";\n    PageDown: \"PageDown\";\n    End: \"End\";\n    Home: \"Home\";\n    ArrowLeft: \"ArrowLeft\";\n    ArrowUp: \"ArrowUp\";\n    ArrowRight: \"ArrowRight\";\n    ArrowDown: \"ArrowDown\";\n} = {\n    Tab: \"Tab\",\n    Enter: \"Enter\",\n    Escape: \"Escape\",\n    Space: \" \",\n    PageUp: \"PageUp\",\n    PageDown: \"PageDown\",\n    End: \"End\",\n    Home: \"Home\",\n    ArrowLeft: \"ArrowLeft\",\n    ArrowUp: \"ArrowUp\",\n    ArrowRight: \"ArrowRight\",\n    ArrowDown: \"ArrowDown\",\n};\n\nexport type Key = typeof Keys[keyof typeof Keys];\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport {\n    KeyborgFocusInEvent,\n    KeyborgFocusOutEvent,\n    KEYBORG_FOCUSIN,\n    KEYBORG_FOCUSOUT,\n    nativeFocus,\n} from \"keyborg\";\n\nimport { Keys } from \"../Keys\";\nimport { RootAPI } from \"../Root\";\nimport * as Types from \"../Types\";\nimport {\n    TabsterFocusInEvent,\n    TabsterFocusOutEvent,\n    TabsterMoveFocusEvent,\n} from \"../Events\";\nimport {\n    documentContains,\n    DummyInputManager,\n    getLastChild,\n    shouldIgnoreFocus,\n    WeakHTMLElement,\n} from \"../Utils\";\nimport { getTabsterOnElement } from \"../Instance\";\nimport { dom } from \"../DOMAPI\";\nimport { Subscribable } from \"./Subscribable\";\n\nfunction getUncontrolledCompletelyContainer(\n    tabster: Types.TabsterCore,\n    element: HTMLElement\n): HTMLElement | undefined {\n    const getParent = tabster.getParent;\n    let el: HTMLElement | null = element;\n\n    do {\n        const uncontrolledOnElement = getTabsterOnElement(\n            tabster,\n            el\n        )?.uncontrolled;\n\n        if (\n            uncontrolledOnElement &&\n            tabster.uncontrolled.isUncontrolledCompletely(\n                el,\n                !!uncontrolledOnElement.completely\n            )\n        ) {\n            return el;\n        }\n\n        el = getParent(el) as HTMLElement | null;\n    } while (el);\n\n    return undefined;\n}\n\nconst AsyncFocusIntentPriorityBySource = {\n    [Types.AsyncFocusSources.Restorer]: 0,\n    [Types.AsyncFocusSources.Deloser]: 1,\n    [Types.AsyncFocusSources.EscapeGroupper]: 2,\n};\n\ninterface AsyncFocus {\n    source: Types.AsyncFocusSource;\n    callback: () => void;\n    timeout: number;\n}\n\nexport class FocusedElementState\n    extends Subscribable<HTMLElement | undefined, Types.FocusedElementDetail>\n    implements Types.FocusedElementState\n{\n    private static _lastResetElement: WeakHTMLElement | undefined;\n    private static _isTabbingTimer: number | undefined;\n    static isTabbing = false;\n\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _nextVal:\n        | {\n              element: WeakHTMLElement | undefined;\n              detail: Types.FocusedElementDetail;\n          }\n        | undefined;\n    private _lastVal: WeakHTMLElement | undefined;\n    private _asyncFocus?: AsyncFocus;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        super();\n\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n        const doc = win.document;\n\n        // Add these event listeners as capture - we want Tabster to run before user event handlers\n        doc.addEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n        doc.addEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        const activeElement = dom.getActiveElement(doc);\n\n        if (activeElement && activeElement !== doc.body) {\n            this._setFocusedElement(activeElement as HTMLElement);\n        }\n\n        this.subscribe(this._onChanged);\n    };\n\n    dispose(): void {\n        super.dispose();\n\n        const win = this._win();\n        const doc = win.document;\n\n        doc.removeEventListener(KEYBORG_FOCUSIN, this._onFocusIn, true);\n        doc.removeEventListener(KEYBORG_FOCUSOUT, this._onFocusOut, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        this.unsubscribe(this._onChanged);\n\n        const asyncFocus = this._asyncFocus;\n        if (asyncFocus) {\n            win.clearTimeout(asyncFocus.timeout);\n            delete this._asyncFocus;\n        }\n\n        delete FocusedElementState._lastResetElement;\n\n        delete this._nextVal;\n        delete this._lastVal;\n    }\n\n    static forgetMemorized(\n        instance: Types.FocusedElementState,\n        parent: HTMLElement\n    ): void {\n        let wel = FocusedElementState._lastResetElement;\n        let el = wel && wel.get();\n        if (el && dom.nodeContains(parent, el)) {\n            delete FocusedElementState._lastResetElement;\n        }\n\n        el = (instance as FocusedElementState)._nextVal?.element?.get();\n        if (el && dom.nodeContains(parent, el)) {\n            delete (instance as FocusedElementState)._nextVal;\n        }\n\n        wel = (instance as FocusedElementState)._lastVal;\n        el = wel && wel.get();\n        if (el && dom.nodeContains(parent, el)) {\n            delete (instance as FocusedElementState)._lastVal;\n        }\n    }\n\n    getFocusedElement(): HTMLElement | undefined {\n        return this.getVal();\n    }\n\n    getLastFocusedElement(): HTMLElement | undefined {\n        let el = this._lastVal?.get();\n\n        if (!el || (el && !documentContains(el.ownerDocument, el))) {\n            this._lastVal = el = undefined;\n        }\n\n        return el;\n    }\n\n    focus(\n        element: HTMLElement,\n        noFocusedProgrammaticallyFlag?: boolean,\n        noAccessibleCheck?: boolean\n    ): boolean {\n        if (\n            !this._tabster.focusable.isFocusable(\n                element,\n                noFocusedProgrammaticallyFlag,\n                false,\n                noAccessibleCheck\n            )\n        ) {\n            return false;\n        }\n\n        element.focus();\n\n        return true;\n    }\n\n    focusDefault(container: HTMLElement): boolean {\n        const el = this._tabster.focusable.findDefault({ container });\n\n        if (el) {\n            this._tabster.focusedElement.focus(el);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    getFirstOrLastTabbable(\n        isFirst: boolean,\n        props: Pick<\n            Types.FindFocusableProps,\n            \"container\" | \"ignoreAccessibility\"\n        >\n    ): HTMLElement | undefined {\n        const { container, ignoreAccessibility } = props;\n        let toFocus: HTMLElement | null | undefined;\n\n        if (container) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            if (ctx) {\n                toFocus = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    container,\n                    undefined,\n                    undefined,\n                    !isFirst,\n                    ignoreAccessibility\n                )?.element;\n            }\n        }\n\n        if (toFocus && !dom.nodeContains(container, toFocus)) {\n            toFocus = undefined;\n        }\n\n        return toFocus || undefined;\n    }\n\n    private _focusFirstOrLast(\n        isFirst: boolean,\n        props: Types.FindFirstProps\n    ): boolean {\n        const toFocus = this.getFirstOrLastTabbable(isFirst, props);\n\n        if (toFocus) {\n            this.focus(toFocus, false, true);\n\n            return true;\n        }\n\n        return false;\n    }\n\n    focusFirst(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(true, props);\n    }\n\n    focusLast(props: Types.FindFirstProps): boolean {\n        return this._focusFirstOrLast(false, props);\n    }\n\n    resetFocus(container: HTMLElement): boolean {\n        if (!this._tabster.focusable.isVisible(container)) {\n            return false;\n        }\n\n        if (!this._tabster.focusable.isFocusable(container, true, true, true)) {\n            const prevTabIndex = container.getAttribute(\"tabindex\");\n            const prevAriaHidden = container.getAttribute(\"aria-hidden\");\n\n            container.tabIndex = -1;\n            container.setAttribute(\"aria-hidden\", \"true\");\n\n            FocusedElementState._lastResetElement = new WeakHTMLElement(\n                this._win,\n                container\n            );\n\n            this.focus(container, true, true);\n\n            this._setOrRemoveAttribute(container, \"tabindex\", prevTabIndex);\n            this._setOrRemoveAttribute(\n                container,\n                \"aria-hidden\",\n                prevAriaHidden\n            );\n        } else {\n            this.focus(container);\n        }\n\n        return true;\n    }\n\n    requestAsyncFocus(\n        source: Types.AsyncFocusSource,\n        callback: () => void,\n        delay: number\n    ): void {\n        const win = this._tabster.getWindow();\n        const currentAsyncFocus = this._asyncFocus;\n\n        if (currentAsyncFocus) {\n            if (\n                AsyncFocusIntentPriorityBySource[source] >\n                AsyncFocusIntentPriorityBySource[currentAsyncFocus.source]\n            ) {\n                // Previously registered intent has higher priority.\n                return;\n            }\n\n            // New intent has higher priority.\n            win.clearTimeout(currentAsyncFocus.timeout);\n        }\n\n        this._asyncFocus = {\n            source,\n            callback,\n            timeout: win.setTimeout(() => {\n                this._asyncFocus = undefined;\n                callback();\n            }, delay),\n        };\n    }\n\n    cancelAsyncFocus(source: Types.AsyncFocusSource): void {\n        const asyncFocus = this._asyncFocus;\n\n        if (asyncFocus?.source === source) {\n            this._tabster.getWindow().clearTimeout(asyncFocus.timeout);\n            this._asyncFocus = undefined;\n        }\n    }\n\n    private _setOrRemoveAttribute(\n        element: HTMLElement,\n        name: string,\n        value: string | null\n    ): void {\n        if (value === null) {\n            element.removeAttribute(name);\n        } else {\n            element.setAttribute(name, value);\n        }\n    }\n\n    private _setFocusedElement(\n        element?: HTMLElement,\n        relatedTarget?: HTMLElement,\n        isFocusedProgrammatically?: boolean\n    ): void {\n        if (this._tabster._noop) {\n            return;\n        }\n\n        const detail: Types.FocusedElementDetail = { relatedTarget };\n\n        if (element) {\n            const lastResetElement =\n                FocusedElementState._lastResetElement?.get();\n            FocusedElementState._lastResetElement = undefined;\n\n            if (lastResetElement === element || shouldIgnoreFocus(element)) {\n                return;\n            }\n\n            detail.isFocusedProgrammatically = isFocusedProgrammatically;\n\n            const ctx = RootAPI.getTabsterContext(this._tabster, element);\n\n            const modalizerId = ctx?.modalizer?.userId;\n\n            if (modalizerId) {\n                detail.modalizerId = modalizerId;\n            }\n        }\n\n        const nextVal = (this._nextVal = {\n            element: element\n                ? new WeakHTMLElement(this._win, element)\n                : undefined,\n            detail,\n        });\n\n        if (element && element !== this._val) {\n            this._validateFocusedElement(element);\n        }\n\n        // _validateFocusedElement() might cause the refocus which will trigger\n        // another call to this function. Making sure that the value is correct.\n        if (this._nextVal === nextVal) {\n            this.setVal(element, detail);\n        }\n\n        this._nextVal = undefined;\n    }\n\n    protected setVal(\n        val: HTMLElement | undefined,\n        detail: Types.FocusedElementDetail\n    ): void {\n        super.setVal(val, detail);\n\n        if (val) {\n            this._lastVal = new WeakHTMLElement(this._win, val);\n        }\n    }\n\n    private _onFocusIn = (e: KeyborgFocusInEvent): void => {\n        const target = e.composedPath()[0] as HTMLElement;\n\n        if (target) {\n            this._setFocusedElement(\n                target,\n                e.detail.relatedTarget as HTMLElement | undefined,\n                e.detail.isFocusedProgrammatically\n            );\n        }\n    };\n\n    private _onFocusOut = (e: KeyborgFocusOutEvent): void => {\n        this._setFocusedElement(\n            undefined,\n            e.detail?.originalEvent.relatedTarget as HTMLElement | undefined\n        );\n    };\n\n    static findNextTabbable(\n        tabster: Types.TabsterCore,\n        ctx: Types.TabsterContext,\n        container?: HTMLElement,\n        currentElement?: HTMLElement,\n        referenceElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const actualContainer = container || ctx.root.getElement();\n\n        if (!actualContainer) {\n            return null;\n        }\n\n        let next: Types.NextTabbable | null = null;\n\n        const isTabbingTimer = FocusedElementState._isTabbingTimer;\n        const win = tabster.getWindow();\n\n        if (isTabbingTimer) {\n            win.clearTimeout(isTabbingTimer);\n        }\n\n        FocusedElementState.isTabbing = true;\n        FocusedElementState._isTabbingTimer = win.setTimeout(() => {\n            delete FocusedElementState._isTabbingTimer;\n            FocusedElementState.isTabbing = false;\n        }, 0);\n\n        const modalizer = ctx.modalizer;\n        const groupper = ctx.groupper;\n        const mover = ctx.mover;\n\n        const callFindNext = (\n            what: Types.Groupper | Types.Mover | Types.Modalizer\n        ) => {\n            next = what.findNextTabbable(\n                currentElement,\n                referenceElement,\n                isBackward,\n                ignoreAccessibility\n            );\n\n            if (currentElement && !next?.element) {\n                const parentElement =\n                    what !== modalizer &&\n                    dom.getParentElement(what.getElement());\n\n                if (parentElement) {\n                    const parentCtx = RootAPI.getTabsterContext(\n                        tabster,\n                        currentElement,\n                        { referenceElement: parentElement }\n                    );\n\n                    if (parentCtx) {\n                        const currentScopeElement = what.getElement();\n                        const newCurrent = isBackward\n                            ? currentScopeElement\n                            : (currentScopeElement &&\n                                  getLastChild(currentScopeElement)) ||\n                              currentScopeElement;\n\n                        if (newCurrent) {\n                            next = FocusedElementState.findNextTabbable(\n                                tabster,\n                                parentCtx,\n                                container,\n                                newCurrent,\n                                parentElement,\n                                isBackward,\n                                ignoreAccessibility\n                            );\n\n                            if (next) {\n                                next.outOfDOMOrder = true;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n\n        if (groupper && mover) {\n            callFindNext(ctx.groupperBeforeMover ? groupper : mover);\n        } else if (groupper) {\n            callFindNext(groupper);\n        } else if (mover) {\n            callFindNext(mover);\n        } else if (modalizer) {\n            callFindNext(modalizer);\n        } else {\n            const findProps: Types.FindNextProps = {\n                container: actualContainer,\n                currentElement,\n                referenceElement,\n                ignoreAccessibility,\n                useActiveModalizer: true,\n            };\n\n            const findPropsOut: Types.FindFocusableOutputProps = {};\n\n            const nextElement = tabster.focusable[\n                isBackward ? \"findPrev\" : \"findNext\"\n            ](findProps, findPropsOut);\n\n            next = {\n                element: nextElement,\n                outOfDOMOrder: findPropsOut.outOfDOMOrder,\n                uncontrolled: findPropsOut.uncontrolled,\n            };\n        }\n\n        return next;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    private _validateFocusedElement = (element: HTMLElement): void => {\n        // TODO: Make sure this is not needed anymore and write tests.\n    };\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.key !== Keys.Tab || event.ctrlKey) {\n            return;\n        }\n\n        const currentElement = this.getVal();\n\n        if (\n            !currentElement ||\n            !currentElement.ownerDocument ||\n            currentElement.contentEditable === \"true\"\n        ) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const controlTab = tabster.controlTab;\n        const ctx = RootAPI.getTabsterContext(tabster, currentElement);\n\n        if (!ctx || ctx.ignoreKeydown(event)) {\n            return;\n        }\n\n        const isBackward = event.shiftKey;\n\n        const next = FocusedElementState.findNextTabbable(\n            tabster,\n            ctx,\n            undefined,\n            currentElement,\n            undefined,\n            isBackward,\n            true\n        );\n\n        const rootElement = ctx.root.getElement();\n\n        if (!rootElement) {\n            return;\n        }\n\n        const nextElement = next?.element;\n        const uncontrolledCompletelyContainer =\n            getUncontrolledCompletelyContainer(tabster, currentElement);\n\n        if (nextElement) {\n            const nextUncontrolled = next.uncontrolled;\n\n            if (\n                ctx.uncontrolled ||\n                dom.nodeContains(nextUncontrolled, currentElement)\n            ) {\n                if (\n                    (!next.outOfDOMOrder &&\n                        nextUncontrolled === ctx.uncontrolled) ||\n                    (uncontrolledCompletelyContainer &&\n                        !dom.nodeContains(\n                            uncontrolledCompletelyContainer,\n                            nextElement\n                        ))\n                ) {\n                    // Nothing to do, everything will be done by the browser or something\n                    // that controls the uncontrolled area.\n                    return;\n                }\n\n                // We are in uncontrolled area. We allow whatever controls it to move\n                // focus, but we add a phantom dummy to make sure the focus is moved\n                // to the correct place if the uncontrolled area allows default action.\n                // We only need that in the controlled mode, because in uncontrolled\n                // mode we have dummy inputs around everything that redirects focus.\n                DummyInputManager.addPhantomDummyWithTarget(\n                    tabster,\n                    currentElement,\n                    isBackward,\n                    nextElement\n                );\n\n                return;\n            }\n\n            if (nextUncontrolled || nextElement.tagName === \"IFRAME\") {\n                // For iframes and uncontrolled areas we always want to use default action to\n                // move focus into.\n                if (\n                    rootElement.dispatchEvent(\n                        new TabsterMoveFocusEvent({\n                            by: \"root\",\n                            owner: rootElement,\n                            next: nextElement,\n                            relatedEvent: event,\n                        })\n                    )\n                ) {\n                    DummyInputManager.moveWithPhantomDummy(\n                        this._tabster,\n                        nextUncontrolled ?? nextElement,\n                        false,\n                        isBackward,\n                        event\n                    );\n                }\n\n                return;\n            }\n\n            if (controlTab || next?.outOfDOMOrder) {\n                if (\n                    rootElement.dispatchEvent(\n                        new TabsterMoveFocusEvent({\n                            by: \"root\",\n                            owner: rootElement,\n                            next: nextElement,\n                            relatedEvent: event,\n                        })\n                    )\n                ) {\n                    event.preventDefault();\n                    event.stopImmediatePropagation();\n\n                    nativeFocus(nextElement);\n                }\n            } else {\n                // We are in uncontrolled mode and the next element is in DOM order.\n                // Just allow the default action.\n            }\n        } else {\n            if (\n                !uncontrolledCompletelyContainer &&\n                rootElement.dispatchEvent(\n                    new TabsterMoveFocusEvent({\n                        by: \"root\",\n                        owner: rootElement,\n                        next: null,\n                        relatedEvent: event,\n                    })\n                )\n            ) {\n                ctx.root.moveOutWithDefaultAction(isBackward, event);\n            }\n        }\n    };\n\n    _onChanged = (\n        element: HTMLElement | undefined,\n        detail: Types.FocusedElementDetail\n    ): void => {\n        if (element) {\n            element.dispatchEvent(new TabsterFocusInEvent(detail));\n        } else {\n            const last = this._lastVal?.get();\n\n            if (last) {\n                const d = { ...detail };\n                const lastCtx = RootAPI.getTabsterContext(this._tabster, last);\n                const modalizerId = lastCtx?.modalizer?.userId;\n\n                if (modalizerId) {\n                    d.modalizerId = modalizerId;\n                }\n\n                last.dispatchEvent(new TabsterFocusOutEvent(d));\n            }\n        }\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    GroupperMoveFocusEvent,\n    GroupperMoveFocusEventName,\n    TabsterMoveFocusEvent,\n} from \"./Events\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    getAdjacentElement,\n} from \"./Utils\";\nimport { dom } from \"./DOMAPI\";\n\nclass GroupperDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        groupper: Groupper,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(\n            tabster,\n            element,\n            DummyInputManagerPriorities.Groupper,\n            sys,\n            true\n        );\n\n        this._setHandlers(\n            (\n                dummyInput: DummyInput,\n                isBackward: boolean,\n                relatedTarget: HTMLElement | null\n            ) => {\n                const container = element.get();\n                const input = dummyInput.input;\n\n                if (container && input) {\n                    const ctx = RootAPI.getTabsterContext(tabster, input);\n\n                    if (ctx) {\n                        let next: HTMLElement | null | undefined;\n\n                        next = groupper.findNextTabbable(\n                            relatedTarget || undefined,\n                            undefined,\n                            isBackward,\n                            true\n                        )?.element;\n\n                        if (!next) {\n                            next = FocusedElementState.findNextTabbable(\n                                tabster,\n                                ctx,\n                                undefined,\n                                dummyInput.isOutside\n                                    ? input\n                                    : getAdjacentElement(\n                                          container,\n                                          !isBackward\n                                      ),\n                                undefined,\n                                isBackward,\n                                true\n                            )?.element;\n                        }\n\n                        if (next) {\n                            nativeFocus(next);\n                        }\n                    }\n                }\n            }\n        );\n    }\n}\n\nexport class Groupper\n    extends TabsterPart<Types.GroupperProps>\n    implements Types.Groupper\n{\n    private _shouldTabInside = false;\n    private _first: WeakHTMLElement | undefined;\n    private _onDispose: (groupper: Groupper) => void;\n\n    dummyManager: GroupperDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (groupper: Groupper) => void,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n        this.makeTabbable(false);\n\n        this._onDispose = onDispose;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new GroupperDummyManager(\n                this._element,\n                this,\n                tabster,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        const element = this._element.get();\n        this.dummyManager?.dispose();\n        delete this.dummyManager;\n\n        if (element) {\n            if (__DEV__) {\n                _setInformativeStyle(this._element, true);\n            }\n        }\n\n        delete this._first;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        referenceElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const groupperElement = this.getElement();\n\n        if (!groupperElement) {\n            return null;\n        }\n\n        const currentIsDummy =\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === groupperElement;\n\n        if (\n            !this._shouldTabInside &&\n            currentElement &&\n            dom.nodeContains(groupperElement, currentElement) &&\n            !currentIsDummy\n        ) {\n            return { element: undefined, outOfDOMOrder: true };\n        }\n\n        const groupperFirstFocusable = this.getFirst(true);\n\n        if (\n            !currentElement ||\n            !dom.nodeContains(groupperElement, currentElement) ||\n            currentIsDummy\n        ) {\n            return {\n                element: groupperFirstFocusable,\n                outOfDOMOrder: true,\n            };\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let outOfDOMOrder = false;\n        let uncontrolled: HTMLElement | null | undefined;\n\n        if (this._shouldTabInside && groupperFirstFocusable) {\n            const findProps: Types.FindNextProps = {\n                container: groupperElement,\n                currentElement,\n                referenceElement,\n                ignoreAccessibility,\n                useActiveModalizer: true,\n            };\n\n            const findPropsOut: Types.FindFocusableOutputProps = {};\n\n            next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](\n                findProps,\n                findPropsOut\n            );\n\n            outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n\n            if (\n                !next &&\n                this._props.tabbability ===\n                    Types.GroupperTabbabilities.LimitedTrapFocus\n            ) {\n                next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"](\n                    {\n                        container: groupperElement,\n                        ignoreAccessibility,\n                        useActiveModalizer: true,\n                    },\n                    findPropsOut\n                );\n\n                outOfDOMOrder = true;\n            }\n\n            uncontrolled = findPropsOut.uncontrolled;\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            outOfDOMOrder,\n        };\n    }\n\n    makeTabbable(isTabbable: boolean): void {\n        this._shouldTabInside = isTabbable || !this._props.tabbability;\n\n        if (__DEV__) {\n            _setInformativeStyle(this._element, !this._shouldTabInside);\n        }\n    }\n\n    isActive(noIfFirstIsFocused?: boolean): boolean | undefined {\n        const element = this.getElement() || null;\n        let isParentActive = true;\n\n        for (\n            let e = dom.getParentElement(element);\n            e;\n            e = dom.getParentElement(e)\n        ) {\n            const g = getTabsterOnElement(this._tabster, e)?.groupper as\n                | Groupper\n                | undefined;\n\n            if (g) {\n                if (!g._shouldTabInside) {\n                    isParentActive = false;\n                }\n            }\n        }\n\n        let ret = isParentActive\n            ? this._props.tabbability\n                ? this._shouldTabInside\n                : false\n            : undefined;\n\n        if (ret && noIfFirstIsFocused) {\n            const focused = this._tabster.focusedElement.getFocusedElement();\n\n            if (focused) {\n                ret = focused !== this.getFirst(true);\n            }\n        }\n\n        return ret;\n    }\n\n    getFirst(orContainer: boolean): HTMLElement | undefined {\n        const groupperElement = this.getElement();\n        let first: HTMLElement | undefined;\n\n        if (groupperElement) {\n            if (\n                orContainer &&\n                this._tabster.focusable.isFocusable(groupperElement)\n            ) {\n                return groupperElement;\n            }\n\n            first = this._first?.get();\n\n            if (!first) {\n                first =\n                    this._tabster.focusable.findFirst({\n                        container: groupperElement,\n                        useActiveModalizer: true,\n                    }) || undefined;\n\n                if (first) {\n                    this.setFirst(first);\n                }\n            }\n        }\n\n        return first;\n    }\n\n    setFirst(element: HTMLElement | undefined): void {\n        if (element) {\n            this._first = new WeakHTMLElement(this._tabster.getWindow, element);\n        } else {\n            delete this._first;\n        }\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const cachedGrouppers = state.cachedGrouppers;\n\n        const parentElement = dom.getParentElement(this.getElement());\n        const parentCtx =\n            parentElement &&\n            RootAPI.getTabsterContext(this._tabster, parentElement);\n        const parentCtxGroupper = parentCtx?.groupper;\n        const parentGroupper = parentCtx?.groupperBeforeMover\n            ? parentCtxGroupper\n            : undefined;\n        let parentGroupperElement: HTMLElement | undefined;\n\n        const getIsActive = (groupper: Types.Groupper) => {\n            let cached = cachedGrouppers[groupper.id];\n            let isActive: boolean | undefined;\n\n            if (cached) {\n                isActive = cached.isActive;\n            } else {\n                isActive = this.isActive(true);\n\n                cached = cachedGrouppers[groupper.id] = {\n                    isActive,\n                };\n            }\n\n            return isActive;\n        };\n\n        if (parentGroupper) {\n            parentGroupperElement = parentGroupper.getElement();\n\n            if (\n                !getIsActive(parentGroupper) &&\n                parentGroupperElement &&\n                state.container !== parentGroupperElement &&\n                dom.nodeContains(state.container, parentGroupperElement)\n            ) {\n                // Do not fall into a child groupper of inactive parent groupper if it's in the scope of the search.\n                state.skippedFocusable = true;\n                return NodeFilter.FILTER_REJECT;\n            }\n        }\n\n        const isActive = getIsActive(this);\n        const groupperElement = this.getElement();\n\n        if (groupperElement) {\n            if (isActive !== true) {\n                if (groupperElement === element && parentCtxGroupper) {\n                    if (!parentGroupperElement) {\n                        parentGroupperElement = parentCtxGroupper.getElement();\n                    }\n\n                    if (\n                        parentGroupperElement &&\n                        !getIsActive(parentCtxGroupper) &&\n                        dom.nodeContains(\n                            state.container,\n                            parentGroupperElement\n                        ) &&\n                        parentGroupperElement !== state.container\n                    ) {\n                        state.skippedFocusable = true;\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n\n                if (\n                    groupperElement !== element &&\n                    dom.nodeContains(groupperElement, element)\n                ) {\n                    state.skippedFocusable = true;\n                    return NodeFilter.FILTER_REJECT;\n                }\n\n                const cached = cachedGrouppers[this.id];\n                let first: HTMLElement | null | undefined;\n\n                if (\"first\" in cached) {\n                    first = cached.first;\n                } else {\n                    first = cached.first = this.getFirst(true);\n                }\n\n                if (first && state.acceptCondition(first)) {\n                    state.rejectElementsFrom = groupperElement;\n                    state.skippedFocusable = true;\n\n                    if (first !== state.from) {\n                        state.found = true;\n                        state.foundElement = first;\n                        return NodeFilter.FILTER_ACCEPT;\n                    } else {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n                }\n            }\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateGroupperProps(props: Types.GroupperProps): void {\n    // TODO: Implement validation.\n}\n\nexport class GroupperAPI implements Types.GroupperAPI {\n    private _tabster: Types.TabsterCore;\n    private _updateTimer: number | undefined;\n    private _win: Types.GetWindow;\n    private _current: Record<string, Types.Groupper> = {};\n    private _grouppers: Record<string, Types.Groupper> = {};\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        // Making sure groupper's onFocus is called before modalizer's onFocus.\n        this._tabster.focusedElement.subscribeFirst(this._onFocus);\n\n        const doc = win.document;\n\n        const activeElement = dom.getActiveElement(doc);\n\n        if (activeElement) {\n            this._onFocus(activeElement as HTMLElement);\n        }\n\n        doc.addEventListener(\"mousedown\", this._onMouseDown, true);\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n        win.addEventListener(GroupperMoveFocusEventName, this._onMoveFocus);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._tabster.focusedElement.cancelAsyncFocus(\n            Types.AsyncFocusSources.EscapeGroupper\n        );\n\n        this._current = {};\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.document.removeEventListener(\"mousedown\", this._onMouseDown, true);\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n        win.removeEventListener(GroupperMoveFocusEventName, this._onMoveFocus);\n\n        Object.keys(this._grouppers).forEach((groupperId) => {\n            if (this._grouppers[groupperId]) {\n                this._grouppers[groupperId].dispose();\n                delete this._grouppers[groupperId];\n            }\n        });\n    }\n\n    createGroupper(\n        element: HTMLElement,\n        props: Types.GroupperProps,\n        sys: Types.SysProps | undefined\n    ) {\n        if (__DEV__) {\n            validateGroupperProps(props);\n        }\n\n        const newGroupper = new Groupper(\n            this._tabster,\n            element,\n            this._onGroupperDispose,\n            props,\n            sys\n        );\n\n        this._grouppers[newGroupper.id] = newGroupper;\n\n        const focusedElement = this._tabster.focusedElement.getFocusedElement();\n\n        // Newly created groupper contains currently focused element, update the state on the next tick (to\n        // make sure all grouppers are processed).\n        if (\n            focusedElement &&\n            dom.nodeContains(element, focusedElement) &&\n            !this._updateTimer\n        ) {\n            this._updateTimer = this._win().setTimeout(() => {\n                delete this._updateTimer;\n                // Making sure the focused element hasn't changed.\n                if (\n                    focusedElement ===\n                    this._tabster.focusedElement.getFocusedElement()\n                ) {\n                    this._updateCurrent(focusedElement, true, true);\n                }\n            }, 0);\n        }\n\n        return newGroupper;\n    }\n\n    forgetCurrentGrouppers(): void {\n        this._current = {};\n    }\n\n    private _onGroupperDispose = (groupper: Groupper) => {\n        delete this._grouppers[groupper.id];\n    };\n\n    private _onFocus = (element: HTMLElement | undefined): void => {\n        if (element) {\n            this._updateCurrent(element, true, true);\n        }\n    };\n\n    private _onMouseDown = (e: MouseEvent): void => {\n        if (e.target) {\n            this._updateCurrent(e.target as HTMLElement, true);\n        }\n    };\n\n    private _updateCurrent(\n        element: HTMLElement,\n        includeTarget?: boolean,\n        checkTarget?: boolean\n    ): void {\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        const newIds: Record<string, true> = {};\n\n        let isTarget = true;\n\n        for (\n            let el = element as HTMLElement | null;\n            el;\n            el = dom.getParentElement(el)\n        ) {\n            const groupper = getTabsterOnElement(this._tabster, el)?.groupper;\n\n            if (groupper) {\n                newIds[groupper.id] = true;\n\n                if (isTarget && checkTarget && el !== element) {\n                    isTarget = false;\n                }\n\n                if (includeTarget || !isTarget) {\n                    this._current[groupper.id] = groupper;\n                    const isTabbable =\n                        groupper.isActive() ||\n                        (element !== el &&\n                            (!groupper.getProps().delegated ||\n                                groupper.getFirst(false) !== element));\n\n                    groupper.makeTabbable(isTabbable);\n                }\n\n                isTarget = false;\n            }\n        }\n\n        for (const id of Object.keys(this._current)) {\n            const groupper = this._current[id];\n\n            if (!(groupper.id in newIds)) {\n                groupper.makeTabbable(false);\n                groupper.setFirst(undefined);\n                delete this._current[id];\n            }\n        }\n    }\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.key !== Keys.Enter && event.key !== Keys.Escape) {\n            return;\n        }\n\n        // Give a chance to other listeners to handle the event.\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        const element = this._tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            this.handleKeyPress(element, event);\n        }\n    };\n\n    private _onMoveFocus = (e: GroupperMoveFocusEvent): void => {\n        const element = e.composedPath()[0] as HTMLElement | null | undefined;\n        const action = e.detail?.action;\n\n        if (element && action !== undefined && !e.defaultPrevented) {\n            if (action === Types.GroupperMoveFocusActions.Enter) {\n                this._enterGroupper(element);\n            } else {\n                this._escapeGroupper(element);\n            }\n\n            e.stopImmediatePropagation();\n        }\n    };\n\n    private _enterGroupper(\n        element: HTMLElement,\n        relatedEvent?: KeyboardEvent\n    ): HTMLElement | null {\n        const tabster = this._tabster;\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const groupper = ctx?.groupper || ctx?.modalizerInGroupper;\n        const groupperElement = groupper?.getElement();\n\n        if (\n            groupper &&\n            groupperElement &&\n            (element === groupperElement ||\n                (groupper.getProps().delegated &&\n                    element === groupper.getFirst(false)))\n        ) {\n            const next = tabster.focusable.findNext({\n                container: groupperElement,\n                currentElement: element,\n                useActiveModalizer: true,\n            });\n\n            if (\n                next &&\n                (!relatedEvent ||\n                    (relatedEvent &&\n                        groupperElement.dispatchEvent(\n                            new TabsterMoveFocusEvent({\n                                by: \"groupper\",\n                                owner: groupperElement,\n                                next,\n                                relatedEvent,\n                            })\n                        )))\n            ) {\n                if (relatedEvent) {\n                    // When the application hasn't prevented default,\n                    // we consider the event completely handled, hence we\n                    // prevent the initial event's default action and stop\n                    // propagation.\n                    relatedEvent.preventDefault();\n                    relatedEvent.stopImmediatePropagation();\n                }\n\n                next.focus();\n\n                return next;\n            }\n        }\n\n        return null;\n    }\n\n    private _escapeGroupper(\n        element: HTMLElement,\n        relatedEvent?: KeyboardEvent,\n        fromModalizer?: boolean\n    ): HTMLElement | null {\n        const tabster = this._tabster;\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n        const modalizerInGroupper = ctx?.modalizerInGroupper;\n        let groupper = ctx?.groupper || modalizerInGroupper;\n        const groupperElement = groupper?.getElement();\n\n        if (\n            groupper &&\n            groupperElement &&\n            dom.nodeContains(groupperElement, element)\n        ) {\n            let next: HTMLElement | null | undefined;\n\n            if (element !== groupperElement || fromModalizer) {\n                next = groupper.getFirst(true);\n            } else {\n                const parentElement = dom.getParentElement(groupperElement);\n                const parentCtx = parentElement\n                    ? RootAPI.getTabsterContext(tabster, parentElement)\n                    : undefined;\n\n                groupper = parentCtx?.groupper;\n                next = groupper?.getFirst(true);\n            }\n\n            if (\n                next &&\n                (!relatedEvent ||\n                    (relatedEvent &&\n                        groupperElement.dispatchEvent(\n                            new TabsterMoveFocusEvent({\n                                by: \"groupper\",\n                                owner: groupperElement,\n                                next,\n                                relatedEvent,\n                            })\n                        )))\n            ) {\n                if (groupper) {\n                    groupper.makeTabbable(false);\n\n                    if (modalizerInGroupper) {\n                        tabster.modalizer?.setActive(undefined);\n                    }\n                }\n\n                // This part happens asynchronously inside setTimeout,\n                // so no need to prevent default or stop propagation.\n                next.focus();\n\n                return next;\n            }\n        }\n\n        return null;\n    }\n\n    moveFocus(\n        element: HTMLElement,\n        action: Types.GroupperMoveFocusAction\n    ): HTMLElement | null {\n        return action === Types.GroupperMoveFocusActions.Enter\n            ? this._enterGroupper(element)\n            : this._escapeGroupper(element);\n    }\n\n    handleKeyPress(\n        element: HTMLElement,\n        event: KeyboardEvent,\n        fromModalizer?: boolean\n    ): void {\n        const tabster = this._tabster;\n        const ctx = RootAPI.getTabsterContext(tabster, element);\n\n        if (ctx && (ctx?.groupper || ctx?.modalizerInGroupper)) {\n            tabster.focusedElement.cancelAsyncFocus(\n                Types.AsyncFocusSources.EscapeGroupper\n            );\n\n            if (ctx.ignoreKeydown(event)) {\n                return;\n            }\n\n            if (event.key === Keys.Enter) {\n                this._enterGroupper(element, event);\n            } else if (event.key === Keys.Escape) {\n                // We will handle Esc asynchronously, if something in the application will\n                // move focus during the keypress handling, we will not interfere.\n                const focusedElement =\n                    tabster.focusedElement.getFocusedElement();\n\n                tabster.focusedElement.requestAsyncFocus(\n                    Types.AsyncFocusSources.EscapeGroupper,\n                    () => {\n                        if (\n                            focusedElement !==\n                                tabster.focusedElement.getFocusedElement() &&\n                            // A part of Modalizer that has called this handler to escape the active groupper\n                            // might have been removed from DOM, if the focus is on body, we still want to handle Esc.\n                            ((fromModalizer && !focusedElement) ||\n                                !fromModalizer)\n                        ) {\n                            // Something else in the application has moved focus, we will not handle Esc.\n                            return;\n                        }\n\n                        this._escapeGroupper(element, event, fromModalizer);\n                    },\n                    0\n                );\n            }\n        }\n    }\n}\n\nfunction _setInformativeStyle(\n    weakElement: Types.WeakHTMLElement,\n    remove: boolean\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-groupper\");\n            } else {\n                element.style.setProperty(\"--tabster-groupper\", \"unlimited\");\n            }\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { createKeyborg, disposeKeyborg, Keyborg } from \"keyborg\";\n\nimport * as Types from \"../Types\";\nimport { Subscribable } from \"./Subscribable\";\n\nexport class KeyboardNavigationState\n    extends Subscribable<boolean>\n    implements Types.KeyboardNavigationState\n{\n    private _keyborg?: Keyborg;\n\n    constructor(getWindow: Types.GetWindow) {\n        super();\n        this._keyborg = createKeyborg(getWindow());\n        this._keyborg.subscribe(this._onChange);\n    }\n\n    dispose(): void {\n        super.dispose();\n\n        if (this._keyborg) {\n            this._keyborg.unsubscribe(this._onChange);\n\n            disposeKeyborg(this._keyborg);\n\n            delete this._keyborg;\n        }\n    }\n\n    private _onChange = (isNavigatingWithKeyboard: boolean) => {\n        this.setVal(isNavigatingWithKeyboard, undefined);\n    };\n\n    setNavigatingWithKeyboard(isNavigatingWithKeyboard: boolean): void {\n        this._keyborg?.setVal(isNavigatingWithKeyboard);\n    }\n\n    isNavigatingWithKeyboard(): boolean {\n        return !!this._keyborg?.isNavigatingWithKeyboard();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { RootAPI } from \"./Root\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { Keys } from \"./Keys\";\nimport * as Types from \"./Types\";\nimport {\n    ModalizerActiveEvent,\n    ModalizerEventDetail,\n    ModalizerInactiveEvent,\n} from \"./Events\";\nimport {\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    HTMLElementWithDummyContainer,\n    TabsterPart,\n    WeakHTMLElement,\n    augmentAttribute,\n} from \"./Utils\";\nimport { dom } from \"./DOMAPI\";\n\nlet _wasFocusedCounter = 0;\n\nconst _ariaHidden = \"aria-hidden\";\n\nfunction _setInformativeStyle(\n    weakElement: WeakHTMLElement,\n    remove: boolean,\n    internalId?: string,\n    userId?: string,\n    isActive?: boolean,\n    wasFocused?: number\n): void {\n    if (__DEV__) {\n        const element = weakElement.get();\n\n        if (element) {\n            if (remove) {\n                element.style.removeProperty(\"--tabster-modalizer\");\n            } else {\n                element.style.setProperty(\n                    \"--tabster-modalizer\",\n                    internalId +\n                        \",\" +\n                        userId +\n                        \",\" +\n                        (isActive ? \"active\" : \"inactive\") +\n                        \",\" +\n                        \",\" +\n                        (wasFocused ? `focused(${wasFocused})` : \"not-focused\")\n                );\n            }\n        }\n    }\n}\n\n/**\n * Manages the dummy inputs for the Modalizer.\n */\nclass ModalizerDummyManager extends DummyInputManager {\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Modalizer, sys);\n\n        this._setHandlers((dummyInput: DummyInput, isBackward: boolean) => {\n            const el = element.get();\n            const container = el && RootAPI.getRoot(tabster, el)?.getElement();\n            const input = dummyInput.input;\n            let toFocus: HTMLElement | null | undefined;\n\n            if (container && input) {\n                const dummyContainer = (\n                    input as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get();\n\n                const ctx = RootAPI.getTabsterContext(\n                    tabster,\n                    dummyContainer || input\n                );\n\n                if (ctx) {\n                    toFocus = FocusedElementState.findNextTabbable(\n                        tabster,\n                        ctx,\n                        container,\n                        input,\n                        undefined,\n                        isBackward,\n                        true\n                    )?.element;\n                }\n\n                if (toFocus) {\n                    nativeFocus(toFocus);\n                }\n            }\n        });\n    }\n}\n\nexport class Modalizer\n    extends TabsterPart<Types.ModalizerProps>\n    implements Types.Modalizer\n{\n    userId: string;\n\n    private _isActive: boolean | undefined;\n    private _wasFocused = 0;\n    private _onDispose: (modalizer: Modalizer) => void;\n    private _activeElements: WeakHTMLElement<HTMLElement>[];\n\n    dummyManager: ModalizerDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (modalizer: Modalizer) => void,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined,\n        activeElements: WeakHTMLElement<HTMLElement>[]\n    ) {\n        super(tabster, element, props);\n\n        this.userId = props.id;\n        this._onDispose = onDispose;\n        this._activeElements = activeElements;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new ModalizerDummyManager(\n                this._element,\n                tabster,\n                sys\n            );\n        }\n\n        if (__DEV__) {\n            _setInformativeStyle(\n                this._element,\n                false,\n                this.id,\n                this.userId,\n                this._isActive,\n                this._wasFocused\n            );\n        }\n    }\n\n    makeActive(isActive: boolean): void {\n        if (this._isActive !== isActive) {\n            this._isActive = isActive;\n\n            const element = this.getElement();\n\n            if (element) {\n                const activeElements = this._activeElements;\n                const index = activeElements\n                    .map((e) => e.get())\n                    .indexOf(element);\n\n                if (isActive) {\n                    if (index < 0) {\n                        activeElements.push(\n                            new WeakHTMLElement(\n                                this._tabster.getWindow,\n                                element\n                            )\n                        );\n                    }\n                } else {\n                    if (index >= 0) {\n                        activeElements.splice(index, 1);\n                    }\n                }\n            }\n\n            if (__DEV__) {\n                _setInformativeStyle(\n                    this._element,\n                    false,\n                    this.id,\n                    this.userId,\n                    this._isActive,\n                    this._wasFocused\n                );\n            }\n\n            this._dispatchEvent(isActive);\n        }\n    }\n\n    focused(noIncrement?: boolean): number {\n        if (!noIncrement) {\n            this._wasFocused = ++_wasFocusedCounter;\n        }\n\n        return this._wasFocused;\n    }\n\n    setProps(props: Types.ModalizerProps): void {\n        if (props.id) {\n            this.userId = props.id;\n        }\n\n        this._props = { ...props };\n    }\n\n    dispose(): void {\n        this.makeActive(false);\n        this._onDispose(this);\n        this.dummyManager?.dispose();\n        delete this.dummyManager;\n        this._activeElements = [];\n        this._remove();\n    }\n\n    isActive(): boolean {\n        return !!this._isActive;\n    }\n\n    contains(element: HTMLElement) {\n        return dom.nodeContains(this.getElement(), element);\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        referenceElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const modalizerElement = this.getElement();\n\n        if (!modalizerElement) {\n            return null;\n        }\n\n        const tabster = this._tabster;\n        let next: HTMLElement | null | undefined = null;\n        let outOfDOMOrder = false;\n        let uncontrolled: HTMLElement | null | undefined;\n\n        const container =\n            currentElement &&\n            RootAPI.getRoot(tabster, currentElement)?.getElement();\n\n        if (container) {\n            const findProps: Types.FindNextProps = {\n                container,\n                currentElement,\n                referenceElement,\n                ignoreAccessibility,\n                useActiveModalizer: true,\n            };\n\n            const findPropsOut: Types.FindFocusableOutputProps = {};\n\n            next = tabster.focusable[isBackward ? \"findPrev\" : \"findNext\"](\n                findProps,\n                findPropsOut\n            );\n\n            if (!next && this._props.isTrapped && tabster.modalizer?.activeId) {\n                next = tabster.focusable[isBackward ? \"findLast\" : \"findFirst\"](\n                    {\n                        container,\n                        ignoreAccessibility,\n                        useActiveModalizer: true,\n                    },\n                    findPropsOut\n                );\n\n                outOfDOMOrder = true;\n            } else {\n                outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n            }\n\n            uncontrolled = findPropsOut.uncontrolled;\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            outOfDOMOrder,\n        };\n    }\n\n    private _dispatchEvent(isActive: boolean, allElements?: boolean): boolean {\n        const element = this.getElement();\n        let defaultPrevented = false;\n\n        if (element) {\n            const elements = allElements\n                ? this._activeElements.map((e) => e.get())\n                : [element];\n\n            for (const el of elements) {\n                if (el) {\n                    const eventDetail: ModalizerEventDetail = {\n                        id: this.userId,\n                        element,\n                    };\n\n                    const event = isActive\n                        ? new ModalizerActiveEvent(eventDetail)\n                        : new ModalizerInactiveEvent(eventDetail);\n\n                    el.dispatchEvent(event);\n\n                    if (event.defaultPrevented) {\n                        defaultPrevented = true;\n                    }\n                }\n            }\n        }\n\n        return defaultPrevented;\n    }\n\n    private _remove(): void {\n        if (__DEV__) {\n            _setInformativeStyle(this._element, true);\n        }\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateModalizerProps(props: Types.ModalizerProps): void {\n    // TODO: Implement validation.\n}\n\nexport class ModalizerAPI implements Types.ModalizerAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _restoreModalizerFocusTimer: number | undefined;\n    private _modalizers: Record<string, Types.Modalizer>;\n    private _parts: Record<string, Record<string, Types.Modalizer>>;\n    private _augMap: WeakMap<HTMLElement, true>;\n    private _aug: WeakHTMLElement<HTMLElement>[];\n    private _hiddenUpdateTimer: number | undefined;\n    private _alwaysAccessibleSelector: string | undefined;\n    private _accessibleCheck: Types.ModalizerElementAccessibleCheck | undefined;\n\n    activeId: string | undefined;\n    currentIsOthersAccessible: boolean | undefined;\n    activeElements: WeakHTMLElement<HTMLElement>[];\n\n    constructor(\n        tabster: Types.TabsterCore,\n        // @deprecated use accessibleCheck.\n        alwaysAccessibleSelector?: string,\n        accessibleCheck?: Types.ModalizerElementAccessibleCheck\n    ) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n        this._modalizers = {};\n        this._parts = {};\n        this._augMap = new WeakMap();\n        this._aug = [];\n        this._alwaysAccessibleSelector = alwaysAccessibleSelector;\n        this._accessibleCheck = accessibleCheck;\n        this.activeElements = [];\n\n        if (!tabster.controlTab) {\n            tabster.root.addDummyInputs();\n        }\n\n        const win = this._win();\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n\n        // Dispose all modalizers managed by the API\n        Object.keys(this._modalizers).forEach((modalizerId) => {\n            if (this._modalizers[modalizerId]) {\n                this._modalizers[modalizerId].dispose();\n                delete this._modalizers[modalizerId];\n            }\n        });\n\n        win.clearTimeout(this._restoreModalizerFocusTimer);\n        win.clearTimeout(this._hiddenUpdateTimer);\n\n        this._parts = {};\n        delete this.activeId;\n        this.activeElements = [];\n\n        this._augMap = new WeakMap();\n        this._aug = [];\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n    }\n\n    createModalizer(\n        element: HTMLElement,\n        props: Types.ModalizerProps,\n        sys: Types.SysProps | undefined\n    ): Types.Modalizer {\n        if (__DEV__) {\n            validateModalizerProps(props);\n        }\n\n        const modalizer = new Modalizer(\n            this._tabster,\n            element,\n            this._onModalizerDispose,\n            props,\n            sys,\n            this.activeElements\n        );\n\n        const id = modalizer.id;\n        const userId = props.id;\n\n        this._modalizers[id] = modalizer;\n\n        let part = this._parts[userId];\n        if (!part) {\n            part = this._parts[userId] = {};\n        }\n        part[id] = modalizer;\n\n        // Adding a modalizer which is already focused, activate it\n        if (\n            dom.nodeContains(\n                element,\n                this._tabster.focusedElement.getFocusedElement() ?? null\n            )\n        ) {\n            if (userId !== this.activeId) {\n                this.setActive(modalizer);\n            } else {\n                modalizer.makeActive(true);\n            }\n        }\n\n        return modalizer;\n    }\n\n    private _onModalizerDispose = (modalizer: Modalizer) => {\n        const id = modalizer.id;\n        const userId = modalizer.userId;\n        const part = this._parts[userId];\n\n        delete this._modalizers[id];\n\n        if (part) {\n            delete part[id];\n\n            if (Object.keys(part).length === 0) {\n                delete this._parts[userId];\n\n                if (this.activeId === userId) {\n                    this.setActive(undefined);\n                }\n            }\n        }\n    };\n\n    private _onKeyDown = (event: KeyboardEvent): void => {\n        if (event.key !== Keys.Escape) {\n            return;\n        }\n\n        const tabster = this._tabster;\n        const element = tabster.focusedElement.getFocusedElement();\n\n        if (element) {\n            const ctx = RootAPI.getTabsterContext(tabster, element);\n            const modalizer = ctx?.modalizer;\n\n            if (\n                ctx &&\n                !ctx.groupper &&\n                modalizer?.isActive() &&\n                !ctx.ignoreKeydown(event)\n            ) {\n                const activeId = modalizer.userId;\n\n                if (activeId) {\n                    const part = this._parts[activeId];\n\n                    if (part) {\n                        const focusedSince = Object.keys(part)\n                            .map((id) => {\n                                const m = part[id];\n                                const el = m.getElement();\n                                let groupper: Types.Groupper | undefined;\n\n                                if (el) {\n                                    groupper = getTabsterOnElement(\n                                        this._tabster,\n                                        el\n                                    )?.groupper;\n                                }\n\n                                return m && el && groupper\n                                    ? {\n                                          el,\n                                          focusedSince: m.focused(true),\n                                      }\n                                    : { focusedSince: 0 };\n                            })\n                            .filter((f) => f.focusedSince > 0)\n                            .sort((a, b) =>\n                                a.focusedSince > b.focusedSince\n                                    ? -1\n                                    : a.focusedSince < b.focusedSince\n                                    ? 1\n                                    : 0\n                            );\n\n                        if (focusedSince.length) {\n                            const groupperElement = focusedSince[0].el;\n\n                            if (groupperElement) {\n                                tabster.groupper?.handleKeyPress(\n                                    groupperElement,\n                                    event,\n                                    true\n                                );\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n\n    isAugmented(element: HTMLElement): boolean {\n        return this._augMap.has(element);\n    }\n\n    hiddenUpdate(): void {\n        if (this._hiddenUpdateTimer) {\n            return;\n        }\n\n        this._hiddenUpdateTimer = this._win().setTimeout(() => {\n            delete this._hiddenUpdateTimer;\n            this._hiddenUpdate();\n        }, 250);\n    }\n\n    setActive(modalizer: Types.Modalizer | undefined): void {\n        const userId = modalizer?.userId;\n        const activeId = this.activeId;\n\n        if (activeId === userId) {\n            return;\n        }\n\n        this.activeId = userId;\n\n        if (activeId) {\n            const part = this._parts[activeId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(false);\n                }\n            }\n        }\n\n        if (userId) {\n            const part = this._parts[userId];\n\n            if (part) {\n                for (const id of Object.keys(part)) {\n                    part[id].makeActive(true);\n                }\n            }\n        }\n\n        this.currentIsOthersAccessible =\n            modalizer?.getProps().isOthersAccessible;\n\n        this.hiddenUpdate();\n    }\n\n    focus(\n        elementFromModalizer: HTMLElement,\n        noFocusFirst?: boolean,\n        noFocusDefault?: boolean\n    ): boolean {\n        const ctx = RootAPI.getTabsterContext(\n            this._tabster,\n            elementFromModalizer\n        );\n\n        const modalizer = ctx?.modalizer;\n\n        if (modalizer) {\n            this.setActive(modalizer);\n\n            const props = modalizer.getProps();\n            const modalizerRoot = modalizer.getElement();\n\n            if (modalizerRoot) {\n                if (noFocusFirst === undefined) {\n                    noFocusFirst = props.isNoFocusFirst;\n                }\n\n                if (\n                    !noFocusFirst &&\n                    this._tabster.keyboardNavigation.isNavigatingWithKeyboard() &&\n                    this._tabster.focusedElement.focusFirst({\n                        container: modalizerRoot,\n                    })\n                ) {\n                    return true;\n                }\n\n                if (noFocusDefault === undefined) {\n                    noFocusDefault = props.isNoFocusDefault;\n                }\n\n                if (\n                    !noFocusDefault &&\n                    this._tabster.focusedElement.focusDefault(modalizerRoot)\n                ) {\n                    return true;\n                }\n\n                this._tabster.focusedElement.resetFocus(modalizerRoot);\n            }\n        } else if (__DEV__) {\n            console.error(\"Element is not in Modalizer.\", elementFromModalizer);\n        }\n\n        return false;\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        const modalizerUserId = state.modalizerUserId;\n        const currentModalizer = state.currentCtx?.modalizer;\n\n        if (modalizerUserId) {\n            for (const e of this.activeElements) {\n                const el = e.get();\n\n                if (el && (dom.nodeContains(element, el) || el === element)) {\n                    // We have a part of currently active modalizer somewhere deeper in the DOM,\n                    // skipping all other checks.\n                    return NodeFilter.FILTER_SKIP;\n                }\n            }\n        }\n\n        const ret =\n            modalizerUserId === currentModalizer?.userId ||\n            (!modalizerUserId &&\n                currentModalizer?.getProps().isAlwaysAccessible)\n                ? undefined\n                : NodeFilter.FILTER_SKIP;\n\n        if (ret !== undefined) {\n            state.skippedFocusable = true;\n        }\n\n        return ret;\n    }\n\n    private _hiddenUpdate(): void {\n        const tabster = this._tabster;\n        const body = tabster.getWindow().document.body;\n        const activeId = this.activeId;\n\n        const parts = this._parts;\n        const visibleElements: HTMLElement[] = [];\n        const hiddenElements: HTMLElement[] = [];\n        const alwaysAccessibleSelector = this._alwaysAccessibleSelector;\n        const alwaysAccessibleElements: HTMLElement[] = alwaysAccessibleSelector\n            ? Array.from(\n                  dom.querySelectorAll(\n                      body,\n                      alwaysAccessibleSelector\n                  ) as HTMLElement[]\n              )\n            : [];\n        const activeModalizerElements: HTMLElement[] = [];\n\n        for (const userId of Object.keys(parts)) {\n            const modalizerParts = parts[userId];\n\n            for (const id of Object.keys(modalizerParts)) {\n                const modalizer = modalizerParts[id];\n                const el = modalizer.getElement();\n                const props = modalizer.getProps();\n                const isAlwaysAccessible = props.isAlwaysAccessible;\n\n                if (el) {\n                    if (userId === activeId) {\n                        activeModalizerElements.push(el);\n\n                        if (!this.currentIsOthersAccessible) {\n                            visibleElements.push(el);\n                        }\n                    } else if (isAlwaysAccessible) {\n                        alwaysAccessibleElements.push(el);\n                    } else {\n                        hiddenElements.push(el);\n                    }\n                }\n            }\n        }\n\n        const augmentedMap = this._augMap;\n        const allVisibleElements: HTMLElement[] | undefined =\n            visibleElements.length > 0\n                ? [...visibleElements, ...alwaysAccessibleElements]\n                : undefined;\n\n        const newAugmented: WeakHTMLElement<HTMLElement>[] = [];\n        const newAugmentedMap: WeakMap<HTMLElement, true> = new WeakMap();\n\n        const toggle = (element: HTMLElement, hide: boolean) => {\n            const tagName = element.tagName;\n\n            if (tagName === \"SCRIPT\" || tagName === \"STYLE\") {\n                return;\n            }\n\n            let isAugmented = false;\n\n            if (augmentedMap.has(element)) {\n                if (hide) {\n                    isAugmented = true;\n                } else {\n                    augmentedMap.delete(element);\n                    augmentAttribute(tabster, element, _ariaHidden);\n                }\n            } else if (\n                hide &&\n                !this._accessibleCheck?.(element, activeModalizerElements) &&\n                augmentAttribute(tabster, element, _ariaHidden, \"true\")\n            ) {\n                augmentedMap.set(element, true);\n                isAugmented = true;\n            }\n\n            if (isAugmented) {\n                newAugmented.push(\n                    new WeakHTMLElement(tabster.getWindow, element)\n                );\n                newAugmentedMap.set(element, true);\n            }\n        };\n\n        const walk = (element: HTMLElement) => {\n            for (\n                let el = dom.getFirstElementChild(element);\n                el;\n                el = dom.getNextElementSibling(el)\n            ) {\n                let skip = false;\n                let containsModalizer = false;\n                let containedByModalizer = false;\n\n                if (allVisibleElements) {\n                    const elParent = tabster.getParent(el);\n\n                    for (const c of allVisibleElements) {\n                        if (el === c) {\n                            skip = true;\n                            break;\n                        }\n\n                        if (dom.nodeContains(el, c)) {\n                            containsModalizer = true;\n                            break;\n                        } else if (dom.nodeContains(c, elParent)) {\n                            // tabster.getParent() could be provided by the application to\n                            // handle, for example, virtual parents. Making sure, we are\n                            // not setting aria-hidden on elements which are virtually\n                            // inside modalizer.\n                            containedByModalizer = true;\n                        }\n                    }\n\n                    if (containsModalizer) {\n                        walk(el as HTMLElement);\n                    } else if (!skip && !containedByModalizer) {\n                        toggle(el as HTMLElement, true);\n                    }\n                } else {\n                    toggle(el as HTMLElement, false);\n                }\n            }\n        };\n\n        if (!allVisibleElements) {\n            alwaysAccessibleElements.forEach((e) => toggle(e, false));\n        }\n\n        hiddenElements.forEach((e) => toggle(e, true));\n\n        if (body) {\n            walk(body);\n        }\n\n        this._aug\n            ?.map((e) => e.get())\n            .forEach((e) => {\n                if (e && !newAugmentedMap.get(e)) {\n                    toggle(e, false);\n                }\n            });\n\n        this._aug = newAugmented;\n        this._augMap = newAugmentedMap;\n    }\n\n    /**\n     * Subscribes to the focus state and handles modalizer related focus events\n     * @param focusedElement - Element that is focused\n     * @param detail - Additional data about the focus event\n     */\n    private _onFocus = (\n        focusedElement: HTMLElement | undefined,\n        detail: Types.FocusedElementDetail\n    ): void => {\n        const ctx =\n            focusedElement &&\n            RootAPI.getTabsterContext(this._tabster, focusedElement);\n\n        // Modalizer behaviour is opt in, only apply to elements that have a tabster context\n        if (!ctx || !focusedElement) {\n            return;\n        }\n\n        const augmentedMap = this._augMap;\n\n        for (\n            let e: HTMLElement | null = focusedElement;\n            e;\n            e = dom.getParentElement(e)\n        ) {\n            // If the newly focused element is inside some of the hidden containers,\n            // remove aria-hidden from those synchronously for the screen readers\n            // to be able to read the element. The rest of aria-hiddens, will be removed\n            // acynchronously for the sake of performance.\n\n            if (augmentedMap.has(e)) {\n                augmentedMap.delete(e);\n                augmentAttribute(this._tabster, e, _ariaHidden);\n            }\n        }\n\n        const modalizer = ctx.modalizer;\n\n        // An inactive groupper with the modalizer on the same node will not give the modalizer\n        // in the context, yet we still want to track that the modalizer's container was focused.\n        (\n            modalizer ||\n            getTabsterOnElement(this._tabster, focusedElement)?.modalizer\n        )?.focused();\n\n        if (modalizer?.userId === this.activeId) {\n            this.currentIsOthersAccessible =\n                modalizer?.getProps().isOthersAccessible;\n\n            return;\n        }\n\n        // Developers calling `element.focus()` should change/deactivate active modalizer\n        if (\n            detail.isFocusedProgrammatically ||\n            this.currentIsOthersAccessible ||\n            modalizer?.getProps().isAlwaysAccessible\n        ) {\n            this.setActive(modalizer);\n        } else {\n            // Focused outside of the active modalizer, try pull focus back to current modalizer\n            const win = this._win();\n            win.clearTimeout(this._restoreModalizerFocusTimer);\n            // TODO some rendering frameworks (i.e. React) might async rerender the DOM so we need to wait for a duration\n            // Figure out a better way of doing this rather than a 100ms timeout\n            this._restoreModalizerFocusTimer = win.setTimeout(\n                () => this._restoreModalizerFocus(focusedElement),\n                100\n            );\n        }\n    };\n\n    /**\n     * Called when an element is focused outside of an active modalizer.\n     * Attempts to pull focus back into the active modalizer\n     * @param outsideElement - An element being focused outside of the modalizer\n     */\n    private _restoreModalizerFocus(\n        outsideElement: HTMLElement | undefined\n    ): void {\n        const ownerDocument = outsideElement?.ownerDocument;\n\n        if (!outsideElement || !ownerDocument) {\n            return;\n        }\n\n        const ctx = RootAPI.getTabsterContext(this._tabster, outsideElement);\n        const modalizer = ctx?.modalizer;\n        const activeId = this.activeId;\n\n        if (\n            (!modalizer && !activeId) ||\n            (modalizer && activeId === modalizer.userId)\n        ) {\n            return;\n        }\n\n        const container = ctx?.root.getElement();\n\n        if (container) {\n            let toFocus = this._tabster.focusable.findFirst({\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (toFocus) {\n                if (\n                    outsideElement.compareDocumentPosition(toFocus) &\n                    document.DOCUMENT_POSITION_PRECEDING\n                ) {\n                    toFocus = this._tabster.focusable.findLast({\n                        container,\n                        useActiveModalizer: true,\n                    });\n\n                    if (!toFocus) {\n                        // This only might mean that findFirst/findLast are buggy and inconsistent.\n                        throw new Error(\"Something went wrong.\");\n                    }\n                }\n\n                this._tabster.focusedElement.focus(toFocus);\n\n                return;\n            }\n        }\n\n        // Current Modalizer doesn't seem to have focusable elements.\n        // Blurring the currently focused element which is outside of the current Modalizer.\n        outsideElement.blur();\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nativeFocus } from \"keyborg\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { getTabsterOnElement } from \"./Instance\";\nimport { Keys } from \"./Keys\";\nimport { RootAPI } from \"./Root\";\nimport * as Types from \"./Types\";\nimport {\n    MoverMemorizedElementEvent,\n    MoverMemorizedElementEventName,\n    MoverMoveFocusEvent,\n    MoverMoveFocusEventName,\n    MoverStateEvent,\n    TabsterMoveFocusEvent,\n} from \"./Events\";\nimport {\n    createElementTreeWalker,\n    DummyInput,\n    DummyInputManager,\n    DummyInputManagerPriorities,\n    getElementUId,\n    getPromise,\n    HTMLElementWithDummyContainer,\n    isElementVerticallyVisibleInContainer,\n    matchesSelector,\n    scrollIntoView,\n    TabsterPart,\n    WeakHTMLElement,\n} from \"./Utils\";\nimport { dom } from \"./DOMAPI\";\n\nconst _inputSelector = [\"input\", \"textarea\", \"*[contenteditable]\"].join(\", \");\n\nclass MoverDummyManager extends DummyInputManager {\n    private _tabster: Types.TabsterCore;\n    private _getMemorized: () => WeakHTMLElement | undefined;\n\n    constructor(\n        element: WeakHTMLElement,\n        tabster: Types.TabsterCore,\n        getMemorized: () => WeakHTMLElement | undefined,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, DummyInputManagerPriorities.Mover, sys);\n\n        this._tabster = tabster;\n        this._getMemorized = getMemorized;\n\n        this._setHandlers(this._onFocusDummyInput);\n    }\n\n    private _onFocusDummyInput = (dummyInput: DummyInput) => {\n        const container = this._element.get();\n        const input = dummyInput.input;\n\n        if (container && input) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, container);\n\n            let toFocus: HTMLElement | null | undefined;\n\n            if (ctx) {\n                toFocus = FocusedElementState.findNextTabbable(\n                    this._tabster,\n                    ctx,\n                    undefined,\n                    input,\n                    undefined,\n                    !dummyInput.isFirst,\n                    true\n                )?.element;\n            }\n\n            const memorized = this._getMemorized()?.get();\n            if (memorized) {\n                toFocus = memorized;\n            }\n\n            if (toFocus) {\n                nativeFocus(toFocus);\n            }\n        }\n    };\n}\n\n// TypeScript enums produce depressing JavaScript code, so, we're just using\n// a few old style constants here.\nconst _moverUpdateAdd = 1;\nconst _moverUpdateAttr = 2;\nconst _moverUpdateRemove = 3;\n\ninterface MoverUpdateQueueItem {\n    element: HTMLElement;\n    type:\n        | typeof _moverUpdateAdd\n        | typeof _moverUpdateAttr\n        | typeof _moverUpdateRemove;\n}\n\nexport class Mover\n    extends TabsterPart<Types.MoverProps>\n    implements Types.Mover\n{\n    private _unobserve: (() => void) | undefined;\n    private _intersectionObserver: IntersectionObserver | undefined;\n    private _setCurrentTimer: number | undefined;\n    private _current: WeakHTMLElement | undefined;\n    private _prevCurrent: WeakHTMLElement | undefined;\n    private _visible: Record<string, Types.Visibility> = {};\n    private _fullyVisible: string | undefined;\n    private _win: Types.GetWindow;\n    private _onDispose: (mover: Mover) => void;\n    private _allElements: WeakMap<HTMLElement, Mover> | undefined;\n    private _updateQueue: MoverUpdateQueueItem[] | undefined;\n    private _updateTimer: number | undefined;\n\n    visibilityTolerance: number;\n    dummyManager: MoverDummyManager | undefined;\n\n    constructor(\n        tabster: Types.TabsterCore,\n        element: HTMLElement,\n        onDispose: (mover: Mover) => void,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ) {\n        super(tabster, element, props);\n\n        this._win = tabster.getWindow;\n        this.visibilityTolerance = props.visibilityTolerance ?? 0.8;\n\n        if (this._props.trackState || this._props.visibilityAware) {\n            this._intersectionObserver = new IntersectionObserver(\n                this._onIntersection,\n                { threshold: [0, 0.25, 0.5, 0.75, 1] }\n            );\n            this._observeState();\n        }\n\n        this._onDispose = onDispose;\n        const getMemorized = () =>\n            props.memorizeCurrent ? this._current : undefined;\n\n        if (!tabster.controlTab) {\n            this.dummyManager = new MoverDummyManager(\n                this._element,\n                tabster,\n                getMemorized,\n                sys\n            );\n        }\n    }\n\n    dispose(): void {\n        this._onDispose(this);\n\n        if (this._intersectionObserver) {\n            this._intersectionObserver.disconnect();\n            delete this._intersectionObserver;\n        }\n\n        delete this._current;\n        delete this._fullyVisible;\n        delete this._allElements;\n        delete this._updateQueue;\n\n        if (this._unobserve) {\n            this._unobserve();\n            delete this._unobserve;\n        }\n\n        const win = this._win();\n\n        if (this._setCurrentTimer) {\n            win.clearTimeout(this._setCurrentTimer);\n            delete this._setCurrentTimer;\n        }\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            delete this._updateTimer;\n        }\n\n        this.dummyManager?.dispose();\n        delete this.dummyManager;\n    }\n\n    setCurrent(element: HTMLElement | undefined): void {\n        if (element) {\n            this._current = new WeakHTMLElement(this._win, element);\n        } else {\n            this._current = undefined;\n        }\n\n        if (\n            (this._props.trackState || this._props.visibilityAware) &&\n            !this._setCurrentTimer\n        ) {\n            this._setCurrentTimer = this._win().setTimeout(() => {\n                delete this._setCurrentTimer;\n\n                const changed: (WeakHTMLElement | undefined)[] = [];\n\n                if (this._current !== this._prevCurrent) {\n                    changed.push(this._current);\n                    changed.push(this._prevCurrent);\n                    this._prevCurrent = this._current;\n                }\n\n                for (const weak of changed) {\n                    const el = weak?.get();\n\n                    if (el && this._allElements?.get(el) === this) {\n                        const props = this._props;\n\n                        if (\n                            el &&\n                            (props.visibilityAware !== undefined ||\n                                props.trackState)\n                        ) {\n                            const state = this.getState(el);\n\n                            if (state) {\n                                el.dispatchEvent(new MoverStateEvent(state));\n                            }\n                        }\n                    }\n                }\n            });\n        }\n    }\n\n    getCurrent(): HTMLElement | null {\n        return this._current?.get() || null;\n    }\n\n    findNextTabbable(\n        currentElement?: HTMLElement,\n        referenceElement?: HTMLElement,\n        isBackward?: boolean,\n        ignoreAccessibility?: boolean\n    ): Types.NextTabbable | null {\n        const container = this.getElement();\n        const currentIsDummy =\n            container &&\n            (\n                currentElement as HTMLElementWithDummyContainer\n            )?.__tabsterDummyContainer?.get() === container;\n\n        if (!container) {\n            return null;\n        }\n\n        let next: HTMLElement | null | undefined = null;\n        let outOfDOMOrder = false;\n        let uncontrolled: HTMLElement | null | undefined;\n\n        if (\n            this._props.tabbable ||\n            currentIsDummy ||\n            (currentElement && !dom.nodeContains(container, currentElement))\n        ) {\n            const findProps: Types.FindNextProps = {\n                currentElement,\n                referenceElement,\n                container,\n                ignoreAccessibility,\n                useActiveModalizer: true,\n            };\n\n            const findPropsOut: Types.FindFocusableOutputProps = {};\n\n            next = this._tabster.focusable[\n                isBackward ? \"findPrev\" : \"findNext\"\n            ](findProps, findPropsOut);\n\n            outOfDOMOrder = !!findPropsOut.outOfDOMOrder;\n            uncontrolled = findPropsOut.uncontrolled;\n        }\n\n        return {\n            element: next,\n            uncontrolled,\n            outOfDOMOrder,\n        };\n    }\n\n    acceptElement(\n        element: HTMLElement,\n        state: Types.FocusableAcceptElementState\n    ): number | undefined {\n        if (!FocusedElementState.isTabbing) {\n            return state.currentCtx?.excludedFromMover\n                ? NodeFilter.FILTER_REJECT\n                : undefined;\n        }\n\n        const {\n            memorizeCurrent,\n            visibilityAware,\n            hasDefault = true,\n        } = this._props;\n        const moverElement = this.getElement();\n\n        if (\n            moverElement &&\n            (memorizeCurrent || visibilityAware || hasDefault) &&\n            (!dom.nodeContains(moverElement, state.from) ||\n                (\n                    state.from as HTMLElementWithDummyContainer\n                ).__tabsterDummyContainer?.get() === moverElement)\n        ) {\n            let found: HTMLElement | undefined | null;\n\n            if (memorizeCurrent) {\n                const current = this._current?.get();\n\n                if (current && state.acceptCondition(current)) {\n                    found = current;\n                }\n            }\n\n            if (!found && hasDefault) {\n                found = this._tabster.focusable.findDefault({\n                    container: moverElement,\n                    useActiveModalizer: true,\n                });\n            }\n\n            if (!found && visibilityAware) {\n                found = this._tabster.focusable.findElement({\n                    container: moverElement,\n                    useActiveModalizer: true,\n                    isBackward: state.isBackward,\n                    acceptCondition: (el) => {\n                        const id = getElementUId(this._win, el);\n                        const visibility = this._visible[id];\n\n                        return (\n                            moverElement !== el &&\n                            !!this._allElements?.get(el) &&\n                            state.acceptCondition(el) &&\n                            (visibility === Types.Visibilities.Visible ||\n                                (visibility ===\n                                    Types.Visibilities.PartiallyVisible &&\n                                    (visibilityAware ===\n                                        Types.Visibilities.PartiallyVisible ||\n                                        !this._fullyVisible)))\n                        );\n                    },\n                });\n            }\n\n            if (found) {\n                state.found = true;\n                state.foundElement = found;\n                state.rejectElementsFrom = moverElement;\n                state.skippedFocusable = true;\n                return NodeFilter.FILTER_ACCEPT;\n            }\n        }\n\n        return undefined;\n    }\n\n    private _onIntersection = (entries: IntersectionObserverEntry[]): void => {\n        for (const entry of entries) {\n            const el = entry.target as HTMLElement;\n            const id = getElementUId(this._win, el);\n\n            let newVisibility: Types.Visibility;\n            let fullyVisible = this._fullyVisible;\n\n            if (entry.intersectionRatio >= 0.25) {\n                newVisibility =\n                    entry.intersectionRatio >= 0.75\n                        ? Types.Visibilities.Visible\n                        : Types.Visibilities.PartiallyVisible;\n\n                if (newVisibility === Types.Visibilities.Visible) {\n                    fullyVisible = id;\n                }\n            } else {\n                newVisibility = Types.Visibilities.Invisible;\n            }\n\n            if (this._visible[id] !== newVisibility) {\n                if (newVisibility === undefined) {\n                    delete this._visible[id];\n\n                    if (fullyVisible === id) {\n                        delete this._fullyVisible;\n                    }\n                } else {\n                    this._visible[id] = newVisibility;\n                    this._fullyVisible = fullyVisible;\n                }\n\n                const state = this.getState(el);\n\n                if (state) {\n                    el.dispatchEvent(new MoverStateEvent(state));\n                }\n            }\n        }\n    };\n\n    private _observeState(): void {\n        const element = this.getElement();\n\n        if (\n            this._unobserve ||\n            !element ||\n            typeof MutationObserver === \"undefined\"\n        ) {\n            return;\n        }\n\n        const win = this._win();\n        const allElements = (this._allElements = new WeakMap());\n        const tabsterFocusable = this._tabster.focusable;\n        let updateQueue: MoverUpdateQueueItem[] = (this._updateQueue = []);\n\n        const observer = dom.createMutationObserver(\n            (mutations: MutationRecord[]) => {\n                for (const mutation of mutations) {\n                    const target = mutation.target;\n                    const removed = mutation.removedNodes;\n                    const added = mutation.addedNodes;\n\n                    if (mutation.type === \"attributes\") {\n                        if (mutation.attributeName === \"tabindex\") {\n                            updateQueue.push({\n                                element: target as HTMLElement,\n                                type: _moverUpdateAttr,\n                            });\n                        }\n                    } else {\n                        for (let i = 0; i < removed.length; i++) {\n                            updateQueue.push({\n                                element: removed[\n                                    i\n                                ] as HTMLElement as HTMLElement,\n                                type: _moverUpdateRemove,\n                            });\n                        }\n\n                        for (let i = 0; i < added.length; i++) {\n                            updateQueue.push({\n                                element: added[i] as HTMLElement,\n                                type: _moverUpdateAdd,\n                            });\n                        }\n                    }\n                }\n\n                requestUpdate();\n            }\n        );\n\n        const setElement = (element: HTMLElement, remove?: boolean): void => {\n            const current = allElements.get(element);\n\n            if (current && remove) {\n                this._intersectionObserver?.unobserve(element);\n                allElements.delete(element);\n            }\n\n            if (!current && !remove) {\n                allElements.set(element, this);\n                this._intersectionObserver?.observe(element);\n            }\n        };\n\n        const updateElement = (element: HTMLElement): void => {\n            const isFocusable = tabsterFocusable.isFocusable(element);\n            const current = allElements.get(element);\n\n            if (current) {\n                if (!isFocusable) {\n                    setElement(element, true);\n                }\n            } else {\n                if (isFocusable) {\n                    setElement(element);\n                }\n            }\n        };\n\n        const addNewElements = (element: HTMLElement): void => {\n            const { mover } = getMoverGroupper(element);\n\n            if (mover && mover !== this) {\n                if (\n                    mover.getElement() === element &&\n                    tabsterFocusable.isFocusable(element)\n                ) {\n                    setElement(element);\n                } else {\n                    return;\n                }\n            }\n\n            const walker = createElementTreeWalker(\n                win.document,\n                element,\n                (node: Node): number => {\n                    const { mover, groupper } = getMoverGroupper(\n                        node as HTMLElement\n                    );\n\n                    if (mover && mover !== this) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    const groupperFirstFocusable = groupper?.getFirst(true);\n\n                    if (\n                        groupper &&\n                        groupper.getElement() !== node &&\n                        groupperFirstFocusable &&\n                        groupperFirstFocusable !== node\n                    ) {\n                        return NodeFilter.FILTER_REJECT;\n                    }\n\n                    if (tabsterFocusable.isFocusable(node as HTMLElement)) {\n                        setElement(node as HTMLElement);\n                    }\n\n                    return NodeFilter.FILTER_SKIP;\n                }\n            );\n\n            if (walker) {\n                walker.currentNode = element;\n\n                while (walker.nextNode()) {\n                    /* Iterating for the sake of calling processNode() callback. */\n                }\n            }\n        };\n\n        const removeWalk = (element: HTMLElement): void => {\n            const current = allElements.get(element);\n\n            if (current) {\n                setElement(element, true);\n            }\n\n            for (\n                let el = dom.getFirstElementChild(element);\n                el;\n                el = dom.getNextElementSibling(el)\n            ) {\n                removeWalk(el as HTMLElement);\n            }\n        };\n\n        const requestUpdate = () => {\n            if (!this._updateTimer && updateQueue.length) {\n                this._updateTimer = win.setTimeout(() => {\n                    delete this._updateTimer;\n\n                    for (const { element, type } of updateQueue) {\n                        switch (type) {\n                            case _moverUpdateAttr:\n                                updateElement(element);\n                                break;\n                            case _moverUpdateAdd:\n                                addNewElements(element);\n                                break;\n                            case _moverUpdateRemove:\n                                removeWalk(element);\n                                break;\n                        }\n                    }\n\n                    updateQueue = this._updateQueue = [];\n                }, 0);\n            }\n        };\n\n        const getMoverGroupper = (\n            element: HTMLElement\n        ): { mover?: Mover; groupper?: Types.Groupper } => {\n            const ret: {\n                mover?: Mover;\n                groupper?: Types.Groupper;\n            } = {};\n\n            for (\n                let el: HTMLElement | null = element;\n                el;\n                el = dom.getParentElement(el)\n            ) {\n                const toe = getTabsterOnElement(this._tabster, el);\n\n                if (toe) {\n                    if (toe.groupper && !ret.groupper) {\n                        ret.groupper = toe.groupper;\n                    }\n\n                    if (toe.mover) {\n                        ret.mover = toe.mover as Mover;\n                        break;\n                    }\n                }\n            }\n\n            return ret;\n        };\n\n        updateQueue.push({ element, type: _moverUpdateAdd });\n        requestUpdate();\n\n        observer.observe(element, {\n            childList: true,\n            subtree: true,\n            attributes: true,\n            attributeFilter: [\"tabindex\"],\n        });\n\n        this._unobserve = () => {\n            observer.disconnect();\n        };\n    }\n\n    getState(element: HTMLElement): Types.MoverElementState | undefined {\n        const id = getElementUId(this._win, element);\n\n        if (id in this._visible) {\n            const visibility =\n                this._visible[id] || Types.Visibilities.Invisible;\n            const isCurrent = this._current\n                ? this._current.get() === element\n                : undefined;\n\n            return {\n                isCurrent,\n                visibility,\n            };\n        }\n\n        return undefined;\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction validateMoverProps(props: Types.MoverProps): void {\n    // TODO: Implement validation.\n}\n\n/**\n * Calculates distance between two rectangles.\n *\n * @param ax1 first rectangle left\n * @param ay1 first rectangle top\n * @param ax2 first rectangle right\n * @param ay2 first rectangle bottom\n * @param bx1 second rectangle left\n * @param by1 second rectangle top\n * @param bx2 second rectangle right\n * @param by2 second rectangle bottom\n * @returns number, shortest distance between the rectangles.\n */\nfunction getDistance(\n    ax1: number,\n    ay1: number,\n    ax2: number,\n    ay2: number,\n    bx1: number,\n    by1: number,\n    bx2: number,\n    by2: number\n): number {\n    const xDistance = ax2 < bx1 ? bx1 - ax2 : bx2 < ax1 ? ax1 - bx2 : 0;\n    const yDistance = ay2 < by1 ? by1 - ay2 : by2 < ay1 ? ay1 - by2 : 0;\n\n    return xDistance === 0\n        ? yDistance\n        : yDistance === 0\n        ? xDistance\n        : Math.sqrt(xDistance * xDistance + yDistance * yDistance);\n}\n\nexport class MoverAPI implements Types.MoverAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _movers: Record<string, Mover>;\n    private _ignoredInputTimer: number | undefined;\n    private _ignoredInputResolve: ((value: boolean) => void) | undefined;\n\n    constructor(tabster: Types.TabsterCore, getWindow: Types.GetWindow) {\n        this._tabster = tabster;\n        this._win = getWindow;\n        this._movers = {};\n\n        tabster.queueInit(this._init);\n    }\n\n    private _init = (): void => {\n        const win = this._win();\n\n        win.addEventListener(\"keydown\", this._onKeyDown, true);\n        win.addEventListener(MoverMoveFocusEventName, this._onMoveFocus);\n        win.addEventListener(\n            MoverMemorizedElementEventName,\n            this._onMemorizedElement\n        );\n\n        this._tabster.focusedElement.subscribe(this._onFocus);\n    };\n\n    dispose(): void {\n        const win = this._win();\n\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        this._ignoredInputResolve?.(false);\n\n        if (this._ignoredInputTimer) {\n            win.clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        win.removeEventListener(\"keydown\", this._onKeyDown, true);\n        win.removeEventListener(MoverMoveFocusEventName, this._onMoveFocus);\n        win.removeEventListener(\n            MoverMemorizedElementEventName,\n            this._onMemorizedElement\n        );\n\n        Object.keys(this._movers).forEach((moverId) => {\n            if (this._movers[moverId]) {\n                this._movers[moverId].dispose();\n                delete this._movers[moverId];\n            }\n        });\n    }\n\n    createMover(\n        element: HTMLElement,\n        props: Types.MoverProps,\n        sys: Types.SysProps | undefined\n    ): Types.Mover {\n        if (__DEV__) {\n            validateMoverProps(props);\n        }\n\n        const newMover = new Mover(\n            this._tabster,\n            element,\n            this._onMoverDispose,\n            props,\n            sys\n        );\n        this._movers[newMover.id] = newMover;\n        return newMover;\n    }\n\n    private _onMoverDispose = (mover: Mover) => {\n        delete this._movers[mover.id];\n    };\n\n    private _onFocus = (element: HTMLElement | undefined): void => {\n        // When something in the app gets focused, we are making sure that\n        // the relevant context Mover is aware of it.\n        // Looking for the relevant context Mover from the currently\n        // focused element parent, not from the element itself, because the\n        // Mover element itself cannot be its own current (but might be\n        // current for its parent Mover).\n        let currentFocusableElement = element;\n        let deepestFocusableElement = element;\n\n        for (\n            let el: HTMLElement | null | undefined =\n                dom.getParentElement(element);\n            el;\n            el = dom.getParentElement(el)\n        ) {\n            // We go through all Movers up from the focused element and\n            // set their current element to the deepest focusable of that\n            // Mover.\n            const mover = getTabsterOnElement(this._tabster, el)?.mover;\n\n            if (mover) {\n                mover.setCurrent(deepestFocusableElement);\n                currentFocusableElement = undefined;\n            }\n\n            if (\n                !currentFocusableElement &&\n                this._tabster.focusable.isFocusable(el)\n            ) {\n                currentFocusableElement = deepestFocusableElement = el;\n            }\n        }\n    };\n\n    moveFocus(\n        fromElement: HTMLElement,\n        key: Types.MoverKey\n    ): HTMLElement | null {\n        return this._moveFocus(fromElement, key);\n    }\n\n    private _moveFocus(\n        fromElement: HTMLElement,\n        key: Types.MoverKey,\n        relatedEvent?: KeyboardEvent\n    ): HTMLElement | null {\n        const tabster = this._tabster;\n        const ctx = RootAPI.getTabsterContext(tabster, fromElement, {\n            checkRtl: true,\n        });\n\n        if (\n            !ctx ||\n            !ctx.mover ||\n            ctx.excludedFromMover ||\n            (relatedEvent && ctx.ignoreKeydown(relatedEvent))\n        ) {\n            return null;\n        }\n\n        const mover = ctx.mover;\n        const container = mover.getElement();\n\n        if (ctx.groupperBeforeMover) {\n            const groupper = ctx.groupper;\n\n            if (groupper && !groupper.isActive(true)) {\n                // For the cases when we have Mover/Active Groupper/Inactive Groupper, we need to check\n                // the grouppers between the current element and the current mover.\n                for (\n                    let el: HTMLElement | null | undefined =\n                        dom.getParentElement(groupper.getElement());\n                    el && el !== container;\n                    el = dom.getParentElement(el)\n                ) {\n                    if (\n                        getTabsterOnElement(tabster, el)?.groupper?.isActive(\n                            true\n                        )\n                    ) {\n                        return null;\n                    }\n                }\n            } else {\n                return null;\n            }\n        }\n\n        if (!container) {\n            return null;\n        }\n\n        const focusable = tabster.focusable;\n        const moverProps = mover.getProps();\n        const direction = moverProps.direction || Types.MoverDirections.Both;\n        const isBoth = direction === Types.MoverDirections.Both;\n        const isVertical =\n            isBoth || direction === Types.MoverDirections.Vertical;\n        const isHorizontal =\n            isBoth || direction === Types.MoverDirections.Horizontal;\n        const isGridLinear = direction === Types.MoverDirections.GridLinear;\n        const isGrid = isGridLinear || direction === Types.MoverDirections.Grid;\n        const isCyclic = moverProps.cyclic;\n\n        let next: HTMLElement | null | undefined;\n        let scrollIntoViewArg: boolean | undefined;\n\n        let focusedElementRect: DOMRect;\n        let focusedElementX1 = 0;\n        let focusedElementX2 = 0;\n\n        if (isGrid) {\n            focusedElementRect = fromElement.getBoundingClientRect();\n            focusedElementX1 = Math.ceil(focusedElementRect.left);\n            focusedElementX2 = Math.floor(focusedElementRect.right);\n        }\n\n        if (ctx.rtl) {\n            if (key === Types.MoverKeys.ArrowRight) {\n                key = Types.MoverKeys.ArrowLeft;\n            } else if (key === Types.MoverKeys.ArrowLeft) {\n                key = Types.MoverKeys.ArrowRight;\n            }\n        }\n\n        if (\n            (key === Types.MoverKeys.ArrowDown && isVertical) ||\n            (key === Types.MoverKeys.ArrowRight && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findNext({\n                currentElement: fromElement,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n\n                if (!isGridLinear && focusedElementX2 > nextElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findFirst({\n                    container,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (\n            (key === Types.MoverKeys.ArrowUp && isVertical) ||\n            (key === Types.MoverKeys.ArrowLeft && (isHorizontal || isGrid))\n        ) {\n            next = focusable.findPrev({\n                currentElement: fromElement,\n                container,\n                useActiveModalizer: true,\n            });\n\n            if (next && isGrid) {\n                const nextElementX2 = Math.floor(\n                    next.getBoundingClientRect().right\n                );\n\n                if (!isGridLinear && nextElementX2 > focusedElementX1) {\n                    next = undefined;\n                }\n            } else if (!next && isCyclic) {\n                next = focusable.findLast({\n                    container,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (key === Types.MoverKeys.Home) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: fromElement,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== fromElement &&\n                            focusedElementX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findFirst({\n                    container,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (key === Types.MoverKeys.End) {\n            if (isGrid) {\n                focusable.findElement({\n                    container,\n                    currentElement: fromElement,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left ?? 0\n                        );\n\n                        if (\n                            el !== fromElement &&\n                            focusedElementX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n\n                        next = el;\n                        return false;\n                    },\n                });\n            } else {\n                next = focusable.findLast({\n                    container,\n                    useActiveModalizer: true,\n                });\n            }\n        } else if (key === Types.MoverKeys.PageUp) {\n            focusable.findElement({\n                currentElement: fromElement,\n                container,\n                useActiveModalizer: true,\n                isBackward: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the first column move forward and preserve previous column\n            if (isGrid && next) {\n                const firstColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 < nextElementX1 ||\n                            firstColumnX1 >= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            scrollIntoViewArg = false;\n        } else if (key === Types.MoverKeys.PageDown) {\n            focusable.findElement({\n                currentElement: fromElement,\n                container,\n                useActiveModalizer: true,\n                acceptCondition: (el) => {\n                    if (!focusable.isFocusable(el)) {\n                        return false;\n                    }\n\n                    if (\n                        isElementVerticallyVisibleInContainer(\n                            this._win,\n                            el,\n                            mover.visibilityTolerance\n                        )\n                    ) {\n                        next = el;\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            // will be on the last column move backwards and preserve previous column\n            if (isGrid && next) {\n                const lastColumnX1 = Math.ceil(\n                    next.getBoundingClientRect().left\n                );\n                focusable.findElement({\n                    currentElement: next,\n                    container,\n                    useActiveModalizer: true,\n                    isBackward: true,\n                    acceptCondition: (el) => {\n                        if (!focusable.isFocusable(el)) {\n                            return false;\n                        }\n\n                        const nextElementX1 = Math.ceil(\n                            el.getBoundingClientRect().left\n                        );\n                        if (\n                            focusedElementX1 > nextElementX1 ||\n                            lastColumnX1 <= nextElementX1\n                        ) {\n                            return true;\n                        }\n                        next = el;\n                        return false;\n                    },\n                });\n            }\n\n            scrollIntoViewArg = true;\n        } else if (isGrid) {\n            const isBackward = key === Types.MoverKeys.ArrowUp;\n            const ax1 = focusedElementX1;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay1 = Math.ceil(focusedElementRect!.top);\n            const ax2 = focusedElementX2;\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const ay2 = Math.floor(focusedElementRect!.bottom);\n            let targetElement: HTMLElement | undefined;\n            let lastDistance: number | undefined;\n            let lastIntersection = 0;\n\n            focusable.findAll({\n                container,\n                currentElement: fromElement,\n                isBackward,\n                onElement: (el) => {\n                    // Find element which has maximal intersection with the focused element horizontally,\n                    // or the closest one.\n                    const rect = el.getBoundingClientRect();\n\n                    const bx1 = Math.ceil(rect.left);\n                    const by1 = Math.ceil(rect.top);\n                    const bx2 = Math.floor(rect.right);\n                    const by2 = Math.floor(rect.bottom);\n\n                    if (\n                        (isBackward && ay1 < by2) ||\n                        (!isBackward && ay2 > by1)\n                    ) {\n                        // Only consider elements which are below/above curretly focused.\n                        return true;\n                    }\n\n                    const xIntersectionWidth =\n                        Math.ceil(Math.min(ax2, bx2)) -\n                        Math.floor(Math.max(ax1, bx1));\n                    const minWidth = Math.ceil(Math.min(ax2 - ax1, bx2 - bx1));\n\n                    if (\n                        xIntersectionWidth > 0 &&\n                        minWidth >= xIntersectionWidth\n                    ) {\n                        // Element intersects with the focused element on X axis.\n                        const intersection = xIntersectionWidth / minWidth;\n\n                        if (intersection > lastIntersection) {\n                            targetElement = el;\n                            lastIntersection = intersection;\n                        }\n                    } else if (lastIntersection === 0) {\n                        // If we didn't have intersection, try just the closest one.\n                        const distance = getDistance(\n                            ax1,\n                            ay1,\n                            ax2,\n                            ay2,\n                            bx1,\n                            by1,\n                            bx2,\n                            by2\n                        );\n\n                        if (\n                            lastDistance === undefined ||\n                            distance < lastDistance\n                        ) {\n                            lastDistance = distance;\n                            targetElement = el;\n                        }\n                    } else if (lastIntersection > 0) {\n                        // Element doesn't intersect, but we had intersection already, stop search.\n                        return false;\n                    }\n\n                    return true;\n                },\n            });\n\n            next = targetElement;\n        }\n\n        if (\n            next &&\n            (!relatedEvent ||\n                (relatedEvent &&\n                    container.dispatchEvent(\n                        new TabsterMoveFocusEvent({\n                            by: \"mover\",\n                            owner: container,\n                            next,\n                            relatedEvent,\n                        })\n                    )))\n        ) {\n            if (scrollIntoViewArg !== undefined) {\n                scrollIntoView(this._win, next, scrollIntoViewArg);\n            }\n\n            if (relatedEvent) {\n                relatedEvent.preventDefault();\n                relatedEvent.stopImmediatePropagation();\n            }\n\n            nativeFocus(next);\n\n            return next;\n        }\n\n        return null;\n    }\n\n    private _onKeyDown = async (event: KeyboardEvent): Promise<void> => {\n        if (this._ignoredInputTimer) {\n            this._win().clearTimeout(this._ignoredInputTimer);\n            delete this._ignoredInputTimer;\n        }\n\n        this._ignoredInputResolve?.(false);\n\n        // Give a chance to other listeners to handle the event (for example,\n        // to scroll instead of moving focus).\n        if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {\n            return;\n        }\n\n        const key = event.key;\n        let moverKey: Types.MoverKey | undefined;\n\n        if (key === Keys.ArrowDown) {\n            moverKey = Types.MoverKeys.ArrowDown;\n        } else if (key === Keys.ArrowRight) {\n            moverKey = Types.MoverKeys.ArrowRight;\n        } else if (key === Keys.ArrowUp) {\n            moverKey = Types.MoverKeys.ArrowUp;\n        } else if (key === Keys.ArrowLeft) {\n            moverKey = Types.MoverKeys.ArrowLeft;\n        } else if (key === Keys.PageDown) {\n            moverKey = Types.MoverKeys.PageDown;\n        } else if (key === Keys.PageUp) {\n            moverKey = Types.MoverKeys.PageUp;\n        } else if (key === Keys.Home) {\n            moverKey = Types.MoverKeys.Home;\n        } else if (key === Keys.End) {\n            moverKey = Types.MoverKeys.End;\n        }\n\n        if (!moverKey) {\n            return;\n        }\n\n        const focused = this._tabster.focusedElement.getFocusedElement();\n\n        if (!focused || (await this._isIgnoredInput(focused, key))) {\n            return;\n        }\n\n        this._moveFocus(focused, moverKey, event);\n    };\n\n    private _onMoveFocus = (e: MoverMoveFocusEvent): void => {\n        const element = e.composedPath()[0] as HTMLElement | null | undefined;\n        const key = e.detail?.key;\n\n        if (element && key !== undefined && !e.defaultPrevented) {\n            this._moveFocus(element, key);\n            e.stopImmediatePropagation();\n        }\n    };\n\n    private _onMemorizedElement = (e: MoverMemorizedElementEvent): void => {\n        const target = e.composedPath()[0] as HTMLElement | null | undefined;\n        let memorizedElement = e.detail?.memorizedElement;\n\n        if (target) {\n            const ctx = RootAPI.getTabsterContext(this._tabster, target);\n            const mover = ctx?.mover;\n\n            if (mover) {\n                if (\n                    memorizedElement &&\n                    !dom.nodeContains(mover.getElement(), memorizedElement)\n                ) {\n                    memorizedElement = undefined;\n                }\n\n                mover.setCurrent(memorizedElement);\n\n                e.stopImmediatePropagation();\n            }\n        }\n    };\n\n    private async _isIgnoredInput(\n        element: HTMLElement,\n        key: string\n    ): Promise<boolean> {\n        if (\n            element.getAttribute(\"aria-expanded\") === \"true\" &&\n            element.hasAttribute(\"aria-activedescendant\")\n        ) {\n            // It is likely a combobox with expanded options and arrow keys are\n            // controlled by it.\n            return true;\n        }\n\n        if (matchesSelector(element, _inputSelector)) {\n            let selectionStart = 0;\n            let selectionEnd = 0;\n            let textLength = 0;\n            let asyncRet: Promise<boolean> | undefined;\n\n            if (element.tagName === \"INPUT\" || element.tagName === \"TEXTAREA\") {\n                const type = (element as HTMLInputElement).type;\n                const value = (element as HTMLInputElement).value;\n\n                textLength = (value || \"\").length;\n\n                if (type === \"email\" || type === \"number\") {\n                    // For these types Chromium doesn't provide selectionStart and selectionEnd.\n                    // Hence the ugly workaround to find if the caret position is changed with\n                    // the keypress.\n                    // TODO: Have a look at range, week, time, time, date, datetime-local.\n                    if (textLength) {\n                        const selection = dom.getSelection(element);\n\n                        if (selection) {\n                            const initialLength = selection.toString().length;\n                            const isBackward =\n                                key === Keys.ArrowLeft || key === Keys.ArrowUp;\n\n                            selection.modify(\n                                \"extend\",\n                                isBackward ? \"backward\" : \"forward\",\n                                \"character\"\n                            );\n\n                            if (initialLength !== selection.toString().length) {\n                                // The caret is moved, so, we're not on the edge of the value.\n                                // Restore original selection.\n                                selection.modify(\n                                    \"extend\",\n                                    isBackward ? \"forward\" : \"backward\",\n                                    \"character\"\n                                );\n\n                                return true;\n                            } else {\n                                textLength = 0;\n                            }\n                        }\n                    }\n                } else {\n                    const selStart = (element as HTMLInputElement)\n                        .selectionStart;\n\n                    if (selStart === null) {\n                        // Do not ignore not text editable inputs like checkboxes and radios (but ignore hidden).\n                        return type === \"hidden\";\n                    }\n\n                    selectionStart = selStart || 0;\n                    selectionEnd =\n                        (element as HTMLInputElement).selectionEnd || 0;\n                }\n            } else if (element.contentEditable === \"true\") {\n                asyncRet = new (getPromise(this._win))((resolve) => {\n                    this._ignoredInputResolve = (value: boolean) => {\n                        delete this._ignoredInputResolve;\n                        resolve(value);\n                    };\n\n                    const win = this._win();\n\n                    if (this._ignoredInputTimer) {\n                        win.clearTimeout(this._ignoredInputTimer);\n                    }\n\n                    const {\n                        anchorNode: prevAnchorNode,\n                        focusNode: prevFocusNode,\n                        anchorOffset: prevAnchorOffset,\n                        focusOffset: prevFocusOffset,\n                    } = dom.getSelection(element) || {};\n\n                    // Get selection gives incorrect value if we call it syncronously onKeyDown.\n                    this._ignoredInputTimer = win.setTimeout(() => {\n                        delete this._ignoredInputTimer;\n\n                        const {\n                            anchorNode,\n                            focusNode,\n                            anchorOffset,\n                            focusOffset,\n                        } = dom.getSelection(element) || {};\n\n                        if (\n                            anchorNode !== prevAnchorNode ||\n                            focusNode !== prevFocusNode ||\n                            anchorOffset !== prevAnchorOffset ||\n                            focusOffset !== prevFocusOffset\n                        ) {\n                            this._ignoredInputResolve?.(false);\n                            return;\n                        }\n\n                        selectionStart = anchorOffset || 0;\n                        selectionEnd = focusOffset || 0;\n                        textLength = element.textContent?.length || 0;\n\n                        if (anchorNode && focusNode) {\n                            if (\n                                dom.nodeContains(element, anchorNode) &&\n                                dom.nodeContains(element, focusNode)\n                            ) {\n                                if (anchorNode !== element) {\n                                    let anchorFound = false;\n\n                                    const addOffsets = (\n                                        node: ChildNode\n                                    ): boolean => {\n                                        if (node === anchorNode) {\n                                            anchorFound = true;\n                                        } else if (node === focusNode) {\n                                            return true;\n                                        }\n\n                                        const nodeText = node.textContent;\n\n                                        if (\n                                            nodeText &&\n                                            !dom.getFirstChild(node)\n                                        ) {\n                                            const len = nodeText.length;\n\n                                            if (anchorFound) {\n                                                if (focusNode !== anchorNode) {\n                                                    selectionEnd += len;\n                                                }\n                                            } else {\n                                                selectionStart += len;\n                                                selectionEnd += len;\n                                            }\n                                        }\n\n                                        let stop = false;\n\n                                        for (\n                                            let e = dom.getFirstChild(node);\n                                            e && !stop;\n                                            e = e.nextSibling\n                                        ) {\n                                            stop = addOffsets(e);\n                                        }\n\n                                        return stop;\n                                    };\n\n                                    addOffsets(element);\n                                }\n                            }\n                        }\n\n                        this._ignoredInputResolve?.(true);\n                    }, 0);\n                });\n            }\n\n            if (asyncRet && !(await asyncRet)) {\n                return true;\n            }\n\n            if (selectionStart !== selectionEnd) {\n                return true;\n            }\n\n            if (\n                selectionStart > 0 &&\n                (key === Keys.ArrowLeft ||\n                    key === Keys.ArrowUp ||\n                    key === Keys.Home)\n            ) {\n                return true;\n            }\n\n            if (\n                selectionStart < textLength &&\n                (key === Keys.ArrowRight ||\n                    key === Keys.ArrowDown ||\n                    key === Keys.End)\n            ) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport {\n    createElementTreeWalker,\n    getInstanceContext,\n    HTMLElementWithUID,\n    InstanceContext,\n    WeakHTMLElement,\n} from \"./Utils\";\nimport { dom } from \"./DOMAPI\";\n\nexport function observeMutations(\n    doc: Document,\n    tabster: Types.TabsterCore,\n    updateTabsterByAttribute: (\n        tabster: Types.TabsterCore,\n        element: HTMLElementWithUID,\n        dispose?: boolean\n    ) => void,\n    syncState: boolean\n): () => void {\n    if (typeof MutationObserver === \"undefined\") {\n        return () => {\n            /* Noop */\n        };\n    }\n\n    const getWindow = tabster.getWindow;\n\n    let elementByUId: InstanceContext[\"elementByUId\"] | undefined;\n\n    const onMutation = (mutations: MutationRecord[]) => {\n        const removedNodes = new Set<Node>();\n\n        for (const mutation of mutations) {\n            const target = mutation.target;\n            const removed = mutation.removedNodes;\n            const added = mutation.addedNodes;\n\n            if (mutation.type === \"attributes\") {\n                if (mutation.attributeName === Types.TabsterAttributeName) {\n                    // removedNodes helps to make sure we are not recreating things\n                    // for the removed elements.\n                    // For some reason, if we do removeChild() and setAttribute() on the\n                    // removed child in the same tick, both the child removal and the attribute\n                    // change will be present in the mutation records. And the attribute change\n                    // will follow the child removal.\n                    // So, we remember the removed nodes and ignore attribute changes for them.\n                    if (!removedNodes.has(target)) {\n                        updateTabsterByAttribute(\n                            tabster,\n                            target as HTMLElement\n                        );\n                    }\n                }\n            } else {\n                for (let i = 0; i < removed.length; i++) {\n                    const removedNode = removed[i];\n                    removedNodes.add(removedNode);\n                    updateTabsterElements(removedNode, true);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n\n                for (let i = 0; i < added.length; i++) {\n                    updateTabsterElements(added[i]);\n                    tabster._dummyObserver.domChanged?.(target as HTMLElement);\n                }\n            }\n        }\n\n        removedNodes.clear();\n\n        tabster.modalizer?.hiddenUpdate();\n    };\n\n    function updateTabsterElements(node: Node, removed?: boolean): void {\n        if (!elementByUId) {\n            elementByUId = getInstanceContext(getWindow).elementByUId;\n        }\n\n        processNode(node as HTMLElement, removed);\n\n        const walker = createElementTreeWalker(\n            doc,\n            node,\n            (element: Node): number => {\n                return processNode(element as HTMLElement, removed);\n            }\n        );\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n\n    function processNode(element: HTMLElement, removed?: boolean): number {\n        if (!element.getAttribute) {\n            // It might actually be a text node.\n            return NodeFilter.FILTER_SKIP;\n        }\n\n        const uid = (element as HTMLElementWithUID).__tabsterElementUID;\n\n        if (uid && elementByUId) {\n            if (removed) {\n                delete elementByUId[uid];\n            } else {\n                elementByUId[uid] ??= new WeakHTMLElement(getWindow, element);\n            }\n        }\n\n        if (\n            getTabsterOnElement(tabster, element) ||\n            element.hasAttribute(Types.TabsterAttributeName)\n        ) {\n            updateTabsterByAttribute(tabster, element, removed);\n        }\n\n        return NodeFilter.FILTER_SKIP;\n    }\n\n    const observer = dom.createMutationObserver(onMutation);\n\n    if (syncState) {\n        updateTabsterElements(getWindow().document.body);\n    }\n\n    observer.observe(doc, {\n        childList: true,\n        subtree: true,\n        attributes: true,\n        attributeFilter: [Types.TabsterAttributeName],\n    });\n\n    return () => {\n        observer.disconnect();\n    };\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"../Instance\";\nimport * as Types from \"../Types\";\nimport {\n    documentContains,\n    getElementUId,\n    getPromise,\n    WeakHTMLElement,\n} from \"../Utils\";\nimport { Subscribable } from \"./Subscribable\";\n\nconst _conditionCheckTimeout = 100;\n\ninterface ObservedElementInfo {\n    element: WeakHTMLElement;\n    prevNames?: string[];\n}\n\ninterface ObservedWaiting {\n    timer?: number;\n    conditionTimer?: number;\n    request?: Types.ObservedElementAsyncRequest<HTMLElement | null>;\n    resolve?: (value: HTMLElement | null) => void;\n    reject?: () => void;\n}\n\nexport class ObservedElementAPI\n    extends Subscribable<HTMLElement, Types.ObservedElementDetails>\n    implements Types.ObservedElementAPI\n{\n    private _win: Types.GetWindow;\n    private _tabster: Types.TabsterCore;\n    private _waiting: Record<string, ObservedWaiting> = {};\n    private _lastRequestFocusId = 0;\n    private _observedById: { [uid: string]: ObservedElementInfo } = {};\n    private _observedByName: {\n        [name: string]: { [uid: string]: ObservedElementInfo };\n    } = {};\n    private _currentRequest:\n        | Types.ObservedElementAsyncRequest<HTMLElement | null>\n        | undefined;\n    private _currentRequestTimestamp = 0;\n\n    constructor(tabster: Types.TabsterCore) {\n        super();\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(() => {\n            this._tabster.focusedElement.subscribe(this._onFocus);\n        });\n    }\n\n    dispose(): void {\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        for (const key of Object.keys(this._waiting)) {\n            this._rejectWaiting(key);\n        }\n\n        this._observedById = {};\n        this._observedByName = {};\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (e) {\n            const current = this._currentRequest;\n\n            if (current) {\n                const delta = Date.now() - this._currentRequestTimestamp;\n                const settleTime = 300;\n\n                if (delta >= settleTime) {\n                    // Giving some time for the focus to settle before\n                    // automatically cancelling the current request on focus change.\n                    delete this._currentRequest;\n                    current.cancel();\n                }\n            }\n        }\n    };\n\n    private _rejectWaiting(key: string, shouldResolve?: boolean): void {\n        const w = this._waiting[key];\n\n        if (w) {\n            const win = this._win();\n\n            if (w.timer) {\n                win.clearTimeout(w.timer);\n            }\n\n            if (w.conditionTimer) {\n                win.clearTimeout(w.conditionTimer);\n            }\n\n            if (!shouldResolve && w.reject) {\n                w.reject();\n            } else if (shouldResolve && w.resolve) {\n                w.resolve(null);\n            }\n\n            delete this._waiting[key];\n        }\n    }\n\n    private _isObservedNamesUpdated(cur: string[], prev?: string[]) {\n        if (!prev || cur.length !== prev.length) {\n            return true;\n        }\n        for (let i = 0; i < cur.length; ++i) {\n            if (cur[i] !== prev[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns existing element by observed name\n     *\n     * @param observedName An observed name\n     * @param accessibility Optionally, return only if the element is accessible or focusable\n     * @returns HTMLElement | null\n     */\n    getElement(\n        observedName: string,\n        accessibility?: Types.ObservedElementAccesibility\n    ): HTMLElement | null {\n        const o = this._observedByName[observedName];\n\n        if (o) {\n            for (const uid of Object.keys(o)) {\n                let el = o[uid].element.get() || null;\n                if (el) {\n                    if (\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Accessible &&\n                            !this._tabster.focusable.isAccessible(el)) ||\n                        (accessibility ===\n                            Types.ObservedElementAccesibilities.Focusable &&\n                            !this._tabster.focusable.isFocusable(el, true))\n                    ) {\n                        el = null;\n                    }\n                } else {\n                    delete o[uid];\n                    delete this._observedById[uid];\n                }\n\n                return el;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Waits for the element to appear in the DOM and returns it.\n     *\n     * @param observedName An observed name\n     * @param timeout Wait no longer than this timeout\n     * @param accessibility Optionally, wait for the element to also become accessible or focusable before returning it\n     * @returns Promise<HTMLElement | null>\n     */\n    waitElement(\n        observedName: string,\n        timeout: number,\n        accessibility?: Types.ObservedElementAccesibility\n    ): Types.ObservedElementAsyncRequest<HTMLElement | null> {\n        const el = this.getElement(observedName, accessibility);\n\n        if (el) {\n            return {\n                result: getPromise(this._win).resolve(el),\n                cancel: () => {\n                    /**/\n                },\n            };\n        }\n\n        let prefix: string;\n\n        if (accessibility === Types.ObservedElementAccesibilities.Accessible) {\n            prefix = \"a\";\n        } else if (\n            accessibility === Types.ObservedElementAccesibilities.Focusable\n        ) {\n            prefix = \"f\";\n        } else {\n            prefix = \"_\";\n        }\n\n        const key = prefix + observedName;\n        let w = this._waiting[key];\n\n        if (w && w.request) {\n            return w.request;\n        }\n\n        w = this._waiting[key] = {\n            timer: this._win().setTimeout(() => {\n                if (w.conditionTimer) {\n                    this._win().clearTimeout(w.conditionTimer);\n                }\n\n                delete this._waiting[key];\n\n                if (w.resolve) {\n                    w.resolve(null);\n                }\n            }, timeout),\n        };\n\n        const promise = new (getPromise(this._win))<HTMLElement | null>(\n            (resolve, reject) => {\n                w.resolve = resolve;\n                w.reject = reject;\n            }\n        );\n\n        w.request = {\n            result: promise,\n            cancel: () => {\n                this._rejectWaiting(key, true);\n            },\n        };\n\n        if (accessibility && this.getElement(observedName)) {\n            // If the observed element is alread in DOM, but not accessible yet,\n            // we need to run the wait logic.\n            this._waitConditional(observedName);\n        }\n\n        return w.request;\n    }\n\n    requestFocus(\n        observedName: string,\n        timeout: number\n    ): Types.ObservedElementAsyncRequest<boolean> {\n        const requestId = ++this._lastRequestFocusId;\n        const currentRequestFocus = this._currentRequest;\n\n        if (currentRequestFocus) {\n            currentRequestFocus.cancel();\n        }\n\n        const request = this.waitElement(\n            observedName,\n            timeout,\n            Types.ObservedElementAccesibilities.Focusable\n        );\n\n        this._currentRequest = request;\n        this._currentRequestTimestamp = Date.now();\n\n        request.result.finally(() => {\n            if (this._currentRequest === request) {\n                delete this._currentRequest;\n            }\n        });\n\n        return {\n            result: request.result.then((element) =>\n                this._lastRequestFocusId === requestId && element\n                    ? this._tabster.focusedElement.focus(element, true)\n                    : false\n            ),\n            cancel: () => {\n                request.cancel();\n            },\n        };\n    }\n\n    onObservedElementUpdate = (element: HTMLElement): void => {\n        const observed = getTabsterOnElement(this._tabster, element)?.observed;\n        const uid = getElementUId(this._win, element);\n        let info: ObservedElementInfo | undefined = this._observedById[uid];\n\n        if (observed && documentContains(element.ownerDocument, element)) {\n            if (!info) {\n                info = this._observedById[uid] = {\n                    element: new WeakHTMLElement(this._win, element),\n                };\n            }\n\n            observed.names.sort();\n            const observedNames = observed.names;\n            const prevNames = info.prevNames; // prevNames are already sorted\n\n            if (this._isObservedNamesUpdated(observedNames, prevNames)) {\n                if (prevNames) {\n                    prevNames.forEach((prevName) => {\n                        const obn = this._observedByName[prevName];\n\n                        if (obn && obn[uid]) {\n                            if (Object.keys(obn).length > 1) {\n                                delete obn[uid];\n                            } else {\n                                delete this._observedByName[prevName];\n                            }\n                        }\n                    });\n                }\n\n                info.prevNames = observedNames;\n            }\n\n            observedNames.forEach((observedName) => {\n                let obn = this._observedByName[observedName];\n\n                if (!obn) {\n                    obn = this._observedByName[observedName] = {};\n                }\n\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                obn[uid] = info!;\n\n                this._waitConditional(observedName);\n            });\n        } else if (info) {\n            const prevNames = info.prevNames;\n\n            if (prevNames) {\n                prevNames.forEach((prevName) => {\n                    const obn = this._observedByName[prevName];\n\n                    if (obn && obn[uid]) {\n                        if (Object.keys(obn).length > 1) {\n                            delete obn[uid];\n                        } else {\n                            delete this._observedByName[prevName];\n                        }\n                    }\n                });\n            }\n\n            delete this._observedById[uid];\n        }\n    };\n\n    private _waitConditional(observedName: string): void {\n        const waitingElementKey = \"_\" + observedName;\n        const waitingAccessibleElementKey = \"a\" + observedName;\n        const waitingFocusableElementKey = \"f\" + observedName;\n        const waitingElement = this._waiting[waitingElementKey];\n        const waitingAccessibleElement =\n            this._waiting[waitingAccessibleElementKey];\n        const waitingFocusableElement =\n            this._waiting[waitingFocusableElementKey];\n        const win = this._win();\n\n        const resolve = (\n            element: HTMLElement,\n            key: string,\n            waiting: ObservedWaiting,\n            accessibility: Types.ObservedElementAccesibility\n        ) => {\n            const observed = getTabsterOnElement(\n                this._tabster,\n                element\n            )?.observed;\n\n            if (!observed || !observed.names.includes(observedName)) {\n                return;\n            }\n\n            if (waiting.timer) {\n                win.clearTimeout(waiting.timer);\n            }\n\n            delete this._waiting[key];\n\n            if (waiting.resolve) {\n                waiting.resolve(element);\n            }\n\n            this.trigger(element, {\n                names: [observedName],\n                details: observed.details,\n                accessibility,\n            });\n        };\n\n        if (waitingElement) {\n            const element = this.getElement(observedName);\n\n            if (element && documentContains(element.ownerDocument, element)) {\n                resolve(\n                    element,\n                    waitingElementKey,\n                    waitingElement,\n                    Types.ObservedElementAccesibilities.Any\n                );\n            }\n        }\n\n        if (\n            waitingAccessibleElement &&\n            !waitingAccessibleElement.conditionTimer\n        ) {\n            const resolveAccessible = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isAccessible(element)\n                ) {\n                    resolve(\n                        element,\n                        waitingAccessibleElementKey,\n                        waitingAccessibleElement,\n                        Types.ObservedElementAccesibilities.Accessible\n                    );\n                } else {\n                    waitingAccessibleElement.conditionTimer = win.setTimeout(\n                        resolveAccessible,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveAccessible();\n        }\n\n        if (\n            waitingFocusableElement &&\n            !waitingFocusableElement.conditionTimer\n        ) {\n            const resolveFocusable = () => {\n                const element = this.getElement(observedName);\n\n                if (\n                    element &&\n                    documentContains(element.ownerDocument, element) &&\n                    this._tabster.focusable.isFocusable(element, true)\n                ) {\n                    resolve(\n                        element,\n                        waitingFocusableElementKey,\n                        waitingFocusableElement,\n                        Types.ObservedElementAccesibilities.Focusable\n                    );\n                } else {\n                    waitingFocusableElement.conditionTimer = win.setTimeout(\n                        resolveFocusable,\n                        _conditionCheckTimeout\n                    );\n                }\n            };\n\n            resolveFocusable();\n        }\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport * as Types from \"./Types\";\nimport { getBoundingRect } from \"./Utils\";\n\ninterface WindowWithOutlineStyle extends Window {\n    __tabsterOutline?: {\n        style?: HTMLStyleElement;\n        elements?: Types.OutlineElements;\n    };\n}\n\nconst defaultProps: Types.OutlineProps = {\n    areaClass: \"tabster-focus-outline-area\",\n    outlineClass: \"tabster-focus-outline\",\n    outlineColor: \"#ff4500\",\n    outlineWidth: 2,\n    zIndex: 2147483647,\n};\n\nlet _props: Types.OutlineProps = defaultProps;\n\nclass OutlinePosition {\n    public left: number;\n    public top: number;\n    public right: number;\n    public bottom: number;\n\n    constructor(left: number, top: number, right: number, bottom: number) {\n        this.left = left;\n        this.top = top;\n        this.right = right;\n        this.bottom = bottom;\n    }\n\n    public equalsTo(other: OutlinePosition): boolean {\n        return (\n            this.left === other.left &&\n            this.top === other.top &&\n            this.right === other.right &&\n            this.bottom === other.bottom\n        );\n    }\n\n    public clone(): OutlinePosition {\n        return new OutlinePosition(\n            this.left,\n            this.top,\n            this.right,\n            this.bottom\n        );\n    }\n}\n\nexport class OutlineAPI implements Types.OutlineAPI {\n    private _tabster: Types.TabsterCore;\n    private _win: Types.GetWindow;\n    private _updateTimer: number | undefined;\n    private _outlinedElement: HTMLElement | undefined;\n    private _curPos: OutlinePosition | undefined;\n    private _isVisible = false;\n    private _curOutlineElements: Types.OutlineElements | undefined;\n    private _allOutlineElements: Types.OutlineElements[] = [];\n    private _fullScreenElement: HTMLElement | undefined;\n    private _fullScreenEventName: string | undefined;\n    private _fullScreenElementName: string | undefined;\n\n    constructor(tabster: Types.TabsterCore) {\n        this._tabster = tabster;\n        this._win = tabster.getWindow;\n\n        tabster.queueInit(this._init);\n\n        if (typeof document !== \"undefined\") {\n            if (\"onfullscreenchange\" in document) {\n                this._fullScreenEventName = \"fullscreenchange\";\n                this._fullScreenElementName = \"fullscreenElement\";\n            } else if (\"onwebkitfullscreenchange\" in document) {\n                this._fullScreenEventName = \"webkitfullscreenchange\";\n                this._fullScreenElementName = \"webkitFullscreenElement\";\n            } else if (\"onmozfullscreenchange\" in document) {\n                this._fullScreenEventName = \"mozfullscreenchange\";\n                this._fullScreenElementName = \"mozFullScreenElement\";\n            } else if (\"onmsfullscreenchange\" in document) {\n                this._fullScreenEventName = \"msfullscreenchange\";\n                this._fullScreenElementName = \"msFullscreenElement\";\n            }\n        }\n    }\n\n    private _init = (): void => {\n        this._tabster.keyboardNavigation.subscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.subscribe(this._onFocus);\n\n        const win = this._win();\n\n        win.addEventListener(\"scroll\", this._onScroll, true); // Capture!\n\n        if (this._fullScreenEventName) {\n            win.document.addEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n    };\n\n    setup(props?: Partial<Types.OutlineProps>): void {\n        _props = { ..._props, ...props };\n\n        const win = this._win() as WindowWithOutlineStyle;\n\n        if (!win.__tabsterOutline) {\n            win.__tabsterOutline = {};\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(win.document, _props);\n        }\n\n        if (!props || !props.areaClass) {\n            win.document.body.classList.add(defaultProps.areaClass);\n        } else {\n            win.document.body.classList.remove(defaultProps.areaClass);\n        }\n    }\n\n    dispose(): void {\n        const win = this._win();\n\n        if (this._updateTimer) {\n            win.clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._tabster.keyboardNavigation.unsubscribe(\n            this._onKeyboardNavigationStateChanged\n        );\n        this._tabster.focusedElement.unsubscribe(this._onFocus);\n\n        win.removeEventListener(\"scroll\", this._onScroll, true);\n\n        if (this._fullScreenEventName) {\n            win.document.removeEventListener(\n                this._fullScreenEventName,\n                this._onFullScreenChanged\n            );\n        }\n\n        this._allOutlineElements.forEach((outlineElements) =>\n            this._removeDOM(outlineElements.container)\n        );\n        this._allOutlineElements = [];\n\n        delete this._outlinedElement;\n        delete this._curPos;\n        delete this._curOutlineElements;\n        delete this._fullScreenElement;\n    }\n\n    private _onFullScreenChanged = (e: Event): void => {\n        if (!this._fullScreenElementName || !e.target) {\n            return;\n        }\n\n        const target = (e.target as Document).body || (e.target as HTMLElement);\n        const outlineElements = this._getDOM(target);\n\n        if (target.ownerDocument && outlineElements) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const fsElement: HTMLElement | null = (target.ownerDocument as any)[\n                this._fullScreenElementName\n            ];\n\n            if (fsElement) {\n                fsElement.appendChild(outlineElements.container);\n                this._fullScreenElement = fsElement;\n            } else {\n                target.ownerDocument.body.appendChild(\n                    outlineElements.container\n                );\n                this._fullScreenElement = undefined;\n            }\n        }\n    };\n\n    private _onKeyboardNavigationStateChanged = (): void => {\n        this._onFocus(this._tabster.focusedElement.getFocusedElement());\n    };\n\n    private _shouldShowCustomOutline(element: HTMLElement): boolean {\n        const tabsterOnElement = getTabsterOnElement(this._tabster, element);\n\n        if (\n            tabsterOnElement &&\n            tabsterOnElement.outline &&\n            tabsterOnElement.outline.isIgnored\n        ) {\n            return false;\n        }\n\n        for (let i: HTMLElement | null = element; i; i = i.parentElement) {\n            if (i.classList && i.classList.contains(_props.areaClass)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private _onFocus = (e: HTMLElement | undefined): void => {\n        if (!this._updateElement(e) && this._isVisible) {\n            this._setVisibility(false);\n        }\n    };\n\n    private _updateElement(e: HTMLElement | undefined): boolean {\n        this._outlinedElement = undefined;\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        this._curPos = undefined;\n\n        if (!this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n            return false;\n        }\n\n        if (e) {\n            // TODO: It's hard (and not necessary) to come up with every possible\n            // condition when there should be no outline, it's better to add an\n            // API to customize the ignores.\n            if (e.tagName === \"INPUT\") {\n                const inputType = (e as HTMLInputElement).type;\n                const outlinedInputTypes = {\n                    button: true,\n                    checkbox: true,\n                    file: true,\n                    image: true,\n                    radio: true,\n                    range: true,\n                    reset: true,\n                    submit: true,\n                };\n\n                if (!(inputType in outlinedInputTypes)) {\n                    return false;\n                }\n            } else if (\n                e.tagName === \"TEXTAREA\" ||\n                e.contentEditable === \"true\" ||\n                e.tagName === \"IFRAME\"\n            ) {\n                return false;\n            }\n\n            if (!this._shouldShowCustomOutline(e)) {\n                return false;\n            }\n\n            if (this._tabster.keyboardNavigation.isNavigatingWithKeyboard()) {\n                this._outlinedElement = e;\n                this._updateOutline();\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    private _onScroll = (e: UIEvent): void => {\n        if (\n            !this._outlinedElement ||\n            !OutlineAPI._isParentChild(\n                e.target as HTMLElement,\n                this._outlinedElement\n            )\n        ) {\n            return;\n        }\n\n        this._curPos = undefined;\n\n        this._setOutlinePosition();\n    };\n\n    private _updateOutline(): void {\n        this._setOutlinePosition();\n\n        if (this._updateTimer) {\n            this._win().clearTimeout(this._updateTimer);\n            this._updateTimer = undefined;\n        }\n\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        this._updateTimer = this._win().setTimeout(() => {\n            this._updateTimer = undefined;\n            this._updateOutline();\n        }, 30);\n    }\n\n    private _setVisibility(visible: boolean): void {\n        this._isVisible = visible;\n\n        if (this._curOutlineElements) {\n            if (visible) {\n                this._curOutlineElements.container.classList.add(\n                    `${_props.outlineClass}_visible`\n                );\n            } else {\n                this._curOutlineElements.container.classList.remove(\n                    `${_props.outlineClass}_visible`\n                );\n                this._curPos = undefined;\n            }\n        }\n    }\n\n    private _setOutlinePosition(): void {\n        if (!this._outlinedElement) {\n            return;\n        }\n\n        let boundingRect = getBoundingRect(this._win, this._outlinedElement);\n\n        const position = new OutlinePosition(\n            boundingRect.left,\n            boundingRect.top,\n            boundingRect.right,\n            boundingRect.bottom\n        );\n\n        if (this._curPos && position.equalsTo(this._curPos)) {\n            return;\n        }\n\n        const outlineElements = this._getDOM(this._outlinedElement);\n        const win =\n            this._outlinedElement.ownerDocument &&\n            this._outlinedElement.ownerDocument.defaultView;\n\n        if (!outlineElements || !win) {\n            return;\n        }\n\n        if (this._curOutlineElements !== outlineElements) {\n            this._setVisibility(false);\n            this._curOutlineElements = outlineElements;\n        }\n\n        this._curPos = position;\n\n        const p = position.clone();\n        let hasAbsolutePositionedParent = false;\n        let hasFixedPositionedParent = false;\n\n        const container = outlineElements.container;\n        const scrollingElement =\n            container &&\n            container.ownerDocument &&\n            (container.ownerDocument.scrollingElement as HTMLElement);\n\n        if (!scrollingElement) {\n            return;\n        }\n\n        for (\n            let parent = this._outlinedElement.parentElement;\n            parent && parent.nodeType === Node.ELEMENT_NODE;\n            parent = parent.parentElement\n        ) {\n            // The element might be partially visible within its scrollable parent,\n            // reduce the bounding rect if this is the case.\n\n            if (parent === this._fullScreenElement) {\n                break;\n            }\n\n            boundingRect = getBoundingRect(this._win, parent);\n\n            const win =\n                parent.ownerDocument && parent.ownerDocument.defaultView;\n\n            if (!win) {\n                return;\n            }\n\n            const computedStyle = win.getComputedStyle(parent);\n            const position = computedStyle.position;\n\n            if (position === \"absolute\") {\n                hasAbsolutePositionedParent = true;\n            } else if (position === \"fixed\" || position === \"sticky\") {\n                hasFixedPositionedParent = true;\n            }\n\n            if (computedStyle.overflow === \"visible\") {\n                continue;\n            }\n\n            if (\n                (!hasAbsolutePositionedParent && !hasFixedPositionedParent) ||\n                computedStyle.overflow === \"hidden\"\n            ) {\n                if (boundingRect.left > p.left) {\n                    p.left = boundingRect.left;\n                }\n                if (boundingRect.top > p.top) {\n                    p.top = boundingRect.top;\n                }\n                if (boundingRect.right < p.right) {\n                    p.right = boundingRect.right;\n                }\n                if (boundingRect.bottom < p.bottom) {\n                    p.bottom = boundingRect.bottom;\n                }\n            }\n        }\n\n        const allRect = getBoundingRect(this._win, scrollingElement);\n        const allWidth = allRect.left + allRect.right;\n        const allHeight = allRect.top + allRect.bottom;\n        const ow = _props.outlineWidth;\n\n        p.left = p.left > ow ? p.left - ow : 0;\n        p.top = p.top > ow ? p.top - ow : 0;\n        p.right = p.right < allWidth - ow ? p.right + ow : allWidth;\n        p.bottom = p.bottom < allHeight - ow ? p.bottom + ow : allHeight;\n\n        const width = p.right - p.left;\n        const height = p.bottom - p.top;\n\n        if (width > ow * 2 && height > ow * 2) {\n            const leftBorderNode = outlineElements.left;\n            const topBorderNode = outlineElements.top;\n            const rightBorderNode = outlineElements.right;\n            const bottomBorderNode = outlineElements.bottom;\n            const sx =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageXOffset;\n            const sy =\n                this._fullScreenElement || hasFixedPositionedParent\n                    ? 0\n                    : win.pageYOffset;\n\n            container.style.position = hasFixedPositionedParent\n                ? \"fixed\"\n                : \"absolute\";\n\n            container.style.background = _props.outlineColor;\n\n            leftBorderNode.style.width =\n                rightBorderNode.style.width =\n                topBorderNode.style.height =\n                bottomBorderNode.style.height =\n                    _props.outlineWidth + \"px\";\n\n            leftBorderNode.style.left =\n                topBorderNode.style.left =\n                bottomBorderNode.style.left =\n                    p.left + sx + \"px\";\n            rightBorderNode.style.left = p.left + sx + width - ow + \"px\";\n\n            leftBorderNode.style.top =\n                rightBorderNode.style.top =\n                topBorderNode.style.top =\n                    p.top + sy + \"px\";\n            bottomBorderNode.style.top = p.top + sy + height - ow + \"px\";\n\n            leftBorderNode.style.height = rightBorderNode.style.height =\n                height + \"px\";\n\n            topBorderNode.style.width = bottomBorderNode.style.width =\n                width + \"px\";\n\n            this._setVisibility(true);\n        } else {\n            this._setVisibility(false);\n        }\n    }\n\n    private _getDOM(\n        contextElement: HTMLElement\n    ): Types.OutlineElements | undefined {\n        const doc = contextElement.ownerDocument;\n        const win = (doc && doc.defaultView) as WindowWithOutlineStyle;\n\n        if (!doc || !win || !win.__tabsterOutline) {\n            return undefined;\n        }\n\n        if (!win.__tabsterOutline.style) {\n            win.__tabsterOutline.style = appendStyles(doc, _props);\n        }\n\n        if (!win.__tabsterOutline.elements) {\n            const outlineElements: Types.OutlineElements = {\n                container: doc.createElement(\"div\"),\n                left: doc.createElement(\"div\"),\n                top: doc.createElement(\"div\"),\n                right: doc.createElement(\"div\"),\n                bottom: doc.createElement(\"div\"),\n            };\n\n            outlineElements.container.className = _props.outlineClass;\n            outlineElements.left.className = `${_props.outlineClass}__left`;\n            outlineElements.top.className = `${_props.outlineClass}__top`;\n            outlineElements.right.className = `${_props.outlineClass}__right`;\n            outlineElements.bottom.className = `${_props.outlineClass}__bottom`;\n\n            outlineElements.container.appendChild(outlineElements.left);\n            outlineElements.container.appendChild(outlineElements.top);\n            outlineElements.container.appendChild(outlineElements.right);\n            outlineElements.container.appendChild(outlineElements.bottom);\n\n            doc.body.appendChild(outlineElements.container);\n\n            win.__tabsterOutline.elements = outlineElements;\n\n            // TODO: Make a garbage collector to remove the references\n            // to the outlines which are nowhere in the DOM anymore.\n            this._allOutlineElements.push(outlineElements);\n        }\n\n        return win.__tabsterOutline.elements;\n    }\n\n    private _removeDOM(contextElement: HTMLElement): void {\n        const win = (contextElement.ownerDocument &&\n            contextElement.ownerDocument.defaultView) as WindowWithOutlineStyle;\n        const outline = win && win.__tabsterOutline;\n\n        if (!outline) {\n            return;\n        }\n\n        if (outline.style && outline.style.parentNode) {\n            outline.style.parentNode.removeChild(outline.style);\n\n            delete outline.style;\n        }\n\n        const outlineElements = outline && outline.elements;\n\n        if (outlineElements) {\n            if (outlineElements.container.parentNode) {\n                outlineElements.container.parentNode.removeChild(\n                    outlineElements.container\n                );\n            }\n\n            delete outline.elements;\n        }\n    }\n\n    private static _isParentChild(\n        parent: HTMLElement,\n        child: HTMLElement\n    ): boolean {\n        return (\n            child === parent ||\n            // tslint:disable-next-line:no-bitwise\n            !!(\n                parent.compareDocumentPosition(child) &\n                document.DOCUMENT_POSITION_CONTAINED_BY\n            )\n        );\n    }\n}\n\nfunction appendStyles(\n    document: HTMLDocument,\n    props: Types.OutlineProps\n): HTMLStyleElement {\n    const style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    style.appendChild(document.createTextNode(getOutlineStyles(props)));\n    document.head.appendChild(style);\n    return style;\n}\n\nfunction getOutlineStyles(props: Types.OutlineProps): string {\n    return `\n.${props.areaClass} *, .${props.areaClass} *:focus {\noutline: none !important;\n}\n\n.${props.outlineClass} {\ndisplay: none;\nposition: absolute;\nwidth: 0;\nheight: 0;\nleft: 0;\ntop: 0;\nz-index: ${props.zIndex};\n}\n\n.${props.outlineClass}.${props.outlineClass}_visible {\ndisplay: block;\n}\n\n.${props.outlineClass}__left,\n.${props.outlineClass}__top,\n.${props.outlineClass}__right,\n.${props.outlineClass}__bottom {\nposition: absolute;\nbackground: inherit;\n}`;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport * as Types from \"./Types\";\n\n/**\n * Allows default or user focus behaviour on the DOM subtree\n * i.e. Tabster will not control focus events within an uncontrolled area\n */\nexport class UncontrolledAPI implements Types.UncontrolledAPI {\n    private _isUncontrolledCompletely?: (\n        element: HTMLElement,\n        completely: boolean\n    ) => boolean | undefined;\n\n    constructor(\n        isUncontrolledCompletely?: (\n            element: HTMLElement,\n            completely: boolean\n        ) => boolean | undefined\n    ) {\n        this._isUncontrolledCompletely = isUncontrolledCompletely;\n    }\n\n    isUncontrolledCompletely(\n        element: HTMLElement,\n        completely: boolean\n    ): boolean {\n        const isUncontrolledCompletely = this._isUncontrolledCompletely?.(\n            element,\n            completely\n        );\n        // If isUncontrolledCompletely callback is not defined or returns undefined, then the default\n        // behaviour is to return the uncontrolled.completely value from the element.\n        return isUncontrolledCompletely === undefined\n            ? completely\n            : isUncontrolledCompletely;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getTabsterOnElement } from \"./Instance\";\nimport type {\n    RestorerAPI as RestorerAPIType,\n    GetWindow,\n    Restorer as RestorerInterface,\n    RestorerProps,\n    KeyboardNavigationState,\n    FocusedElementState,\n    TabsterCore,\n} from \"./Types\";\nimport { RestorerTypes, AsyncFocusSources } from \"./Types\";\nimport {\n    RestorerRestoreFocusEventName,\n    RestorerRestoreFocusEvent,\n} from \"./Events\";\nimport { TabsterPart, WeakHTMLElement } from \"./Utils\";\nimport { dom } from \"./DOMAPI\";\n\nconst HISOTRY_DEPTH = 10;\n\nclass Restorer extends TabsterPart<RestorerProps> implements RestorerInterface {\n    private _hasFocus = false;\n\n    constructor(\n        tabster: TabsterCore,\n        element: HTMLElement,\n        props: RestorerProps\n    ) {\n        super(tabster, element, props);\n\n        if (this._props.type === RestorerTypes.Source) {\n            const element = this._element?.get();\n            element?.addEventListener(\"focusout\", this._onFocusOut);\n            element?.addEventListener(\"focusin\", this._onFocusIn);\n\n            // set hasFocus when the instance is created, in case focus has already moved within it\n            this._hasFocus = dom.nodeContains(\n                element,\n                element && dom.getActiveElement(element.ownerDocument)\n            );\n        }\n    }\n\n    dispose(): void {\n        if (this._props.type === RestorerTypes.Source) {\n            const element = this._element?.get();\n            element?.removeEventListener(\"focusout\", this._onFocusOut);\n            element?.removeEventListener(\"focusin\", this._onFocusIn);\n\n            if (this._hasFocus) {\n                const doc = this._tabster.getWindow().document;\n                doc.body.dispatchEvent(new RestorerRestoreFocusEvent());\n            }\n        }\n    }\n\n    private _onFocusOut = (e: FocusEvent) => {\n        const element = this._element?.get();\n        if (element && e.relatedTarget === null) {\n            element.dispatchEvent(new RestorerRestoreFocusEvent());\n        }\n        if (\n            element &&\n            !dom.nodeContains(element, e.relatedTarget as HTMLElement | null)\n        ) {\n            this._hasFocus = false;\n        }\n    };\n\n    private _onFocusIn = () => {\n        this._hasFocus = true;\n    };\n}\n\nexport class RestorerAPI implements RestorerAPIType {\n    private _tabster: TabsterCore;\n    private _history: WeakHTMLElement<HTMLElement>[] = [];\n    private _keyboardNavState: KeyboardNavigationState;\n    private _focusedElementState: FocusedElementState;\n    private _getWindow: GetWindow;\n\n    constructor(tabster: TabsterCore) {\n        this._tabster = tabster;\n        this._getWindow = tabster.getWindow;\n        this._getWindow().addEventListener(\n            RestorerRestoreFocusEventName,\n            this._onRestoreFocus\n        );\n\n        this._keyboardNavState = tabster.keyboardNavigation;\n        this._focusedElementState = tabster.focusedElement;\n\n        this._focusedElementState.subscribe(this._onFocusIn);\n    }\n\n    dispose(): void {\n        const win = this._getWindow();\n        this._focusedElementState.unsubscribe(this._onFocusIn);\n\n        this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);\n\n        win.removeEventListener(\n            RestorerRestoreFocusEventName,\n            this._onRestoreFocus\n        );\n    }\n\n    private _onRestoreFocus = (e: Event) => {\n        this._focusedElementState.cancelAsyncFocus(AsyncFocusSources.Restorer);\n\n        // ShadowDOM will have shadowRoot as e.target.\n        const target = e.composedPath()[0];\n\n        if (target) {\n            this._focusedElementState.requestAsyncFocus(\n                AsyncFocusSources.Restorer,\n                () => this._restoreFocus(target as HTMLElement),\n                0\n            );\n        }\n    };\n\n    private _onFocusIn = (element: HTMLElement | undefined) => {\n        if (!element) {\n            return;\n        }\n\n        const tabsterAttribute = getTabsterOnElement(this._tabster, element);\n        if (\n            tabsterAttribute?.restorer?.getProps().type !== RestorerTypes.Target\n        ) {\n            return;\n        }\n\n        this._addToHistory(element);\n    };\n\n    private _addToHistory(element: HTMLElement) {\n        // Don't duplicate the top of history\n        if (this._history[this._history.length - 1]?.get() === element) {\n            return;\n        }\n\n        if (this._history.length > HISOTRY_DEPTH) {\n            this._history.shift();\n        }\n\n        this._history.push(\n            new WeakHTMLElement<HTMLElement>(this._getWindow, element)\n        );\n    }\n\n    private _restoreFocus = (source: HTMLElement) => {\n        // don't restore focus if focus isn't lost to body\n        const doc = this._getWindow().document;\n        if (dom.getActiveElement(doc) !== doc.body) {\n            return;\n        }\n\n        if (\n            // clicking on any empty space focuses body - this is can be a false positive\n            !this._keyboardNavState.isNavigatingWithKeyboard() &&\n            // Source no longer exists on DOM - always restore focus\n            dom.nodeContains(doc.body, source)\n        ) {\n            return;\n        }\n\n        let weakElement = this._history.pop();\n        while (\n            weakElement &&\n            !dom.nodeContains(doc.body, dom.getParentElement(weakElement.get()))\n        ) {\n            weakElement = this._history.pop();\n        }\n\n        weakElement?.get()?.focus();\n    };\n\n    public createRestorer(element: HTMLElement, props: RestorerProps) {\n        const restorer = new Restorer(this._tabster, element, props);\n        // Focus might already be on a restorer target when it gets created so the focusin will not do anything\n        if (\n            props.type === RestorerTypes.Target &&\n            dom.getActiveElement(element.ownerDocument) === element\n        ) {\n            this._addToHistory(element);\n        }\n\n        return restorer;\n    }\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nexport function getActiveElement(doc: Document): Element | null {\n    let activeElement = doc.activeElement;\n\n    while (activeElement?.shadowRoot?.activeElement) {\n        activeElement = activeElement.shadowRoot.activeElement;\n    }\n\n    return activeElement;\n}\n\nexport function nodeContains(\n    node: Node | null | undefined,\n    otherNode: Node | null | undefined\n): boolean {\n    if (!node || !otherNode) {\n        return false;\n    }\n\n    let currentNode: HTMLElement | Node | null | undefined = otherNode;\n\n    while (currentNode) {\n        if (currentNode === node) {\n            return true;\n        }\n\n        if (\n            typeof (currentNode as HTMLSlotElement).assignedElements !==\n                \"function\" &&\n            (currentNode as HTMLElement).assignedSlot?.parentNode\n        ) {\n            // Element is slotted\n            currentNode = (currentNode as HTMLElement).assignedSlot?.parentNode;\n        } else if (currentNode.nodeType === document.DOCUMENT_FRAGMENT_NODE) {\n            // Element is in shadow root\n            currentNode = (currentNode as ShadowRoot).host;\n        } else {\n            currentNode = currentNode.parentNode;\n        }\n    }\n\n    return false;\n}\n\nexport function getParentNode(\n    node: Node | null | undefined\n): ParentNode | null {\n    if (!node) {\n        return null;\n    }\n\n    if (\n        node.nodeType === Node.DOCUMENT_FRAGMENT_NODE &&\n        (node as ShadowRoot).host\n    ) {\n        return (node as ShadowRoot).host;\n    }\n\n    return node.parentNode;\n}\n\nexport function getParentElement(\n    element: HTMLElement | null | undefined\n): HTMLElement | null {\n    for (\n        let parentNode = getParentNode(element);\n        parentNode;\n        parentNode = getParentNode(parentNode)\n    ) {\n        if (parentNode.nodeType === Node.ELEMENT_NODE) {\n            return parentNode as HTMLElement;\n        }\n    }\n\n    return null;\n}\n\nexport function getFirstChild(node: Node | null | undefined): ChildNode | null {\n    if (!node) {\n        return null;\n    }\n\n    if ((node as Element).shadowRoot) {\n        const child = getFirstChild((node as Element).shadowRoot);\n\n        if (child) {\n            return child;\n        }\n\n        // If the attached shadowRoot has no children, just try ordinary children,\n        // that might come after.\n    }\n\n    return node.firstChild;\n}\n\nexport function getLastChild(node: Node | null | undefined): ChildNode | null {\n    if (!node) {\n        return null;\n    }\n\n    if (!node.lastChild && (node as Element).shadowRoot) {\n        return getLastChild((node as Element).shadowRoot);\n    }\n\n    return node.lastChild;\n}\n\nexport function getNextSibling(\n    node: Node | null | undefined\n): ChildNode | null {\n    return node?.nextSibling || null;\n}\n\nexport function getPreviousSibling(\n    node: Node | null | undefined\n): ChildNode | null {\n    if (!node) {\n        return null;\n    }\n\n    let sibling = node.previousSibling;\n\n    if (!sibling && node.parentElement?.shadowRoot) {\n        sibling = getLastChild(node.parentElement.shadowRoot);\n    }\n\n    return sibling;\n}\n\nexport function getFirstElementChild(\n    element: Element | null | undefined\n): Element | null {\n    let child = getFirstChild(element);\n\n    while (child && child.nodeType !== Node.ELEMENT_NODE) {\n        child = getNextSibling(child);\n    }\n\n    return child as Element | null;\n}\n\nexport function getLastElementChild(\n    element: Element | null | undefined\n): Element | null {\n    let child = getLastChild(element);\n\n    while (child && child.nodeType !== Node.ELEMENT_NODE) {\n        child = getPreviousSibling(child);\n    }\n\n    return child as Element | null;\n}\n\nexport function getNextElementSibling(\n    element: Element | null | undefined\n): Element | null {\n    let sibling = getNextSibling(element);\n\n    while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {\n        sibling = getNextSibling(sibling);\n    }\n\n    return sibling as Element | null;\n}\n\nexport function getPreviousElementSibling(\n    element: Element | null | undefined\n): Element | null {\n    let sibling = getPreviousSibling(element);\n\n    while (sibling && sibling.nodeType !== Node.ELEMENT_NODE) {\n        sibling = getPreviousSibling(sibling);\n    }\n\n    return sibling as Element | null;\n}\n\nexport function appendChild(parent: Node, child: Node): Node {\n    const shadowRoot = (parent as Element).shadowRoot;\n    return shadowRoot\n        ? shadowRoot.appendChild(child)\n        : parent.appendChild(child);\n}\n\nexport function insertBefore(\n    parent: Node,\n    child: Node,\n    referenceChild: Node | null\n): Node {\n    const shadowRoot = (parent as Element).shadowRoot;\n    return shadowRoot\n        ? shadowRoot.insertBefore(child, referenceChild)\n        : parent.insertBefore(child, referenceChild);\n}\n\ninterface ShadowRootWithGetSelection extends ShadowRoot {\n    getSelection?: typeof Window.prototype.getSelection;\n}\n\nexport function getSelection(ref: Node): Selection | null {\n    const win = ref.ownerDocument?.defaultView;\n\n    if (!win) {\n        return null;\n    }\n\n    for (let el: Node | null = ref; el; el = el.parentNode) {\n        if (el.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n            const tmp = el as ShadowRootWithGetSelection;\n\n            // ShadowRoot.getSelection() exists only in Chrome.\n            if (tmp.getSelection) {\n                return tmp.getSelection() || null;\n            }\n\n            break;\n        }\n    }\n\n    return win.getSelection() || null;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { getLastElementChild, nodeContains } from \"./DOMFunctions\";\n\nfunction getLastChild(container: HTMLElement): HTMLElement | undefined {\n    let lastChild: HTMLElement | null = null;\n\n    for (\n        let i = getLastElementChild(container);\n        i;\n        i = getLastElementChild(i)\n    ) {\n        lastChild = i as HTMLElement;\n    }\n\n    return lastChild || undefined;\n}\n\nexport class ShadowTreeWalker implements TreeWalker {\n    public readonly filter: NodeFilter | null;\n    public readonly root: Node;\n    public readonly whatToShow: number;\n\n    private _doc: Document;\n    private _walkerStack: TreeWalker[] = [];\n    private _currentNode: Node;\n    private _currentSetFor: Set<TreeWalker> = new Set();\n\n    constructor(\n        doc: Document,\n        root: Node,\n        whatToShow?: number,\n        filter?: NodeFilter | null\n    ) {\n        this._doc = doc;\n        this.root = root;\n        this.filter = filter ?? null;\n        this.whatToShow = whatToShow ?? NodeFilter.SHOW_ALL;\n        this._currentNode = root;\n\n        this._walkerStack.unshift(\n            doc.createTreeWalker(root, whatToShow, this._acceptNode)\n        );\n\n        const shadowRoot = (root as Element).shadowRoot;\n\n        if (shadowRoot) {\n            const walker = this._doc.createTreeWalker(\n                shadowRoot,\n                this.whatToShow,\n                { acceptNode: this._acceptNode }\n            );\n\n            this._walkerStack.unshift(walker);\n        }\n    }\n\n    private _acceptNode = (node: Node): number => {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n            const shadowRoot = (node as Element).shadowRoot;\n\n            if (shadowRoot) {\n                const walker = this._doc.createTreeWalker(\n                    shadowRoot,\n                    this.whatToShow,\n                    { acceptNode: this._acceptNode }\n                );\n\n                this._walkerStack.unshift(walker);\n\n                return NodeFilter.FILTER_ACCEPT;\n            } else {\n                if (typeof this.filter === \"function\") {\n                    return this.filter(node);\n                } else if (this.filter?.acceptNode) {\n                    return this.filter.acceptNode(node);\n                }\n            }\n        }\n\n        return NodeFilter.FILTER_SKIP;\n    };\n\n    public get currentNode(): Node {\n        return this._currentNode;\n    }\n\n    public set currentNode(node: Node) {\n        if (!nodeContains(this.root, node)) {\n            throw new Error(\n                \"Cannot set currentNode to a node that is not contained by the root node.\"\n            );\n        }\n\n        const walkers: TreeWalker[] = [];\n        let curNode: Node | null | undefined = node;\n        let currentWalkerCurrentNode = node;\n\n        this._currentNode = node;\n\n        while (curNode && curNode !== this.root) {\n            if (curNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n                const shadowRoot = curNode as ShadowRoot;\n\n                const walker = this._doc.createTreeWalker(\n                    shadowRoot,\n                    this.whatToShow,\n                    { acceptNode: this._acceptNode }\n                );\n\n                walkers.push(walker);\n\n                walker.currentNode = currentWalkerCurrentNode;\n\n                this._currentSetFor.add(walker);\n\n                curNode = currentWalkerCurrentNode = shadowRoot.host;\n            } else {\n                curNode = curNode.parentNode;\n            }\n        }\n\n        const walker = this._doc.createTreeWalker(this.root, this.whatToShow, {\n            acceptNode: this._acceptNode,\n        });\n\n        walkers.push(walker);\n\n        walker.currentNode = currentWalkerCurrentNode;\n\n        this._currentSetFor.add(walker);\n\n        this._walkerStack = walkers;\n    }\n\n    public firstChild(): Node | null {\n        if (__DEV__) {\n            throw new Error(\"Method not implemented.\");\n        }\n\n        return null;\n    }\n\n    public lastChild(): Node | null {\n        if (__DEV__) {\n            throw new Error(\"Method not implemented.\");\n        }\n\n        return null;\n    }\n\n    public nextNode(): Node | null {\n        const nextNode = this._walkerStack[0].nextNode();\n\n        if (nextNode) {\n            const shadowRoot = (nextNode as Element).shadowRoot;\n\n            if (shadowRoot) {\n                let nodeResult: number | undefined;\n\n                if (typeof this.filter === \"function\") {\n                    nodeResult = this.filter(nextNode);\n                } else if (this.filter?.acceptNode) {\n                    nodeResult = this.filter.acceptNode(nextNode);\n                }\n\n                if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n                    return nextNode;\n                }\n\n                // _acceptNode should have added new walker for this shadow,\n                // go in recursively.\n                return this.nextNode();\n            }\n\n            return nextNode;\n        } else {\n            if (this._walkerStack.length > 1) {\n                this._walkerStack.shift();\n\n                return this.nextNode();\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public previousNode(): Node | null {\n        const currentWalker = this._walkerStack[0];\n\n        if (currentWalker.currentNode === currentWalker.root) {\n            if (this._currentSetFor.has(currentWalker)) {\n                this._currentSetFor.delete(currentWalker);\n\n                if (this._walkerStack.length > 1) {\n                    this._walkerStack.shift();\n                    return this.previousNode();\n                } else {\n                    return null;\n                }\n            }\n\n            const lastChild = getLastChild(currentWalker.root as HTMLElement);\n\n            if (lastChild) {\n                currentWalker.currentNode = lastChild;\n\n                let nodeResult: number | undefined;\n\n                if (typeof this.filter === \"function\") {\n                    nodeResult = this.filter(lastChild);\n                } else if (this.filter?.acceptNode) {\n                    nodeResult = this.filter.acceptNode(lastChild);\n                }\n\n                if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n                    return lastChild;\n                }\n            }\n        }\n\n        const previousNode = currentWalker.previousNode();\n\n        if (previousNode) {\n            const shadowRoot = (previousNode as Element).shadowRoot;\n\n            if (shadowRoot) {\n                let nodeResult: number | undefined;\n\n                if (typeof this.filter === \"function\") {\n                    nodeResult = this.filter(previousNode);\n                } else if (this.filter?.acceptNode) {\n                    nodeResult = this.filter.acceptNode(previousNode);\n                }\n\n                if (nodeResult === NodeFilter.FILTER_ACCEPT) {\n                    return previousNode;\n                }\n\n                // _acceptNode should have added new walker for this shadow,\n                // go in recursively.\n                return this.previousNode();\n            }\n\n            return previousNode;\n        } else {\n            if (this._walkerStack.length > 1) {\n                this._walkerStack.shift();\n\n                return this.previousNode();\n            } else {\n                return null;\n            }\n        }\n    }\n\n    public nextSibling(): Node | null {\n        if (__DEV__) {\n            throw new Error(\"Method not implemented.\");\n        }\n\n        return null;\n    }\n\n    public previousSibling(): Node | null {\n        if (__DEV__) {\n            throw new Error(\"Method not implemented.\");\n        }\n\n        return null;\n    }\n\n    public parentNode(): Node | null {\n        if (__DEV__) {\n            throw new Error(\"Method not implemented.\");\n        }\n\n        return null;\n    }\n}\n\nexport function createShadowTreeWalker(\n    doc: Document,\n    root: Node,\n    whatToShow?: number,\n    filter?: NodeFilter | null\n) {\n    return new ShadowTreeWalker(doc, root, whatToShow, filter);\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { nodeContains } from \"./DOMFunctions\";\n\ninterface OverridenAttachShadow {\n    __origAttachShadow?: typeof Element.prototype.attachShadow;\n}\n\nexport class ShadowMutationObserver implements MutationObserver {\n    private static _shadowObservers: Set<ShadowMutationObserver> = new Set();\n\n    private _root?: Node;\n    private _options?: MutationObserverInit;\n    private _callback: MutationCallback;\n    private _observer: MutationObserver;\n    private _subObservers: Map<Node, MutationObserver>;\n    private _isObserving = false;\n\n    private static _overrideAttachShadow(\n        win: Window & typeof globalThis\n    ): void {\n        const origAttachShadow = win.Element.prototype.attachShadow;\n\n        if ((origAttachShadow as OverridenAttachShadow).__origAttachShadow) {\n            return;\n        }\n\n        Element.prototype.attachShadow = function (\n            this: Element,\n            options?: ShadowRootInit\n        ): ShadowRoot {\n            const shadowRoot = origAttachShadow.call(this, options);\n\n            for (const shadowObserver of ShadowMutationObserver._shadowObservers) {\n                shadowObserver._addSubObserver(shadowRoot);\n            }\n\n            return shadowRoot;\n        };\n\n        (\n            Element.prototype.attachShadow as OverridenAttachShadow\n        ).__origAttachShadow = origAttachShadow;\n    }\n\n    constructor(callback: MutationCallback) {\n        this._callback = callback;\n        this._observer = new MutationObserver(this._callbackWrapper);\n        this._subObservers = new Map();\n    }\n\n    private _callbackWrapper = (\n        mutations: MutationRecord[],\n        observer: MutationObserver\n    ): void => {\n        for (const mutation of mutations) {\n            if (mutation.type === \"childList\") {\n                const removed = mutation.removedNodes;\n                const added = mutation.addedNodes;\n\n                for (let i = 0; i < removed.length; i++) {\n                    this._walkShadows(removed[i], true);\n                }\n\n                for (let i = 0; i < added.length; i++) {\n                    this._walkShadows(added[i]);\n                }\n            }\n        }\n\n        this._callback(mutations, observer);\n    };\n\n    private _addSubObserver(shadowRoot: ShadowRoot): void {\n        if (\n            !this._options ||\n            !this._callback ||\n            this._subObservers.has(shadowRoot)\n        ) {\n            return;\n        }\n\n        if (this._options.subtree && nodeContains(this._root, shadowRoot)) {\n            const subObserver = new MutationObserver(this._callbackWrapper);\n\n            this._subObservers.set(shadowRoot, subObserver);\n\n            if (this._isObserving) {\n                subObserver.observe(shadowRoot, this._options);\n            }\n\n            this._walkShadows(shadowRoot);\n        }\n    }\n\n    public disconnect(): void {\n        this._isObserving = false;\n\n        delete this._options;\n\n        ShadowMutationObserver._shadowObservers.delete(this);\n\n        for (const subObserver of this._subObservers.values()) {\n            subObserver.disconnect();\n        }\n\n        this._subObservers.clear();\n\n        this._observer.disconnect();\n    }\n\n    public observe(target: Node, options?: MutationObserverInit): void {\n        const doc =\n            target.nodeType === Node.DOCUMENT_NODE\n                ? (target as Document)\n                : target.ownerDocument;\n        const win = doc?.defaultView as Window & typeof globalThis;\n\n        if (!doc || !win) {\n            return;\n        }\n\n        ShadowMutationObserver._overrideAttachShadow(win);\n        ShadowMutationObserver._shadowObservers.add(this);\n\n        this._root = target;\n        this._options = options;\n\n        this._isObserving = true;\n\n        this._observer.observe(target, options);\n\n        this._walkShadows(target);\n    }\n\n    private _walkShadows(target: Node, remove?: boolean): void {\n        const doc =\n            target.nodeType === Node.DOCUMENT_NODE\n                ? (target as Document)\n                : target.ownerDocument;\n\n        if (!doc) {\n            return;\n        }\n\n        if (target === doc) {\n            target = doc.body;\n        } else {\n            const shadowRoot = (target as Element).shadowRoot;\n\n            if (shadowRoot) {\n                this._addSubObserver(shadowRoot);\n                return;\n            }\n        }\n\n        const walker = doc.createTreeWalker(target, NodeFilter.SHOW_ELEMENT, {\n            acceptNode: (node) => {\n                if (node.nodeType === Node.ELEMENT_NODE) {\n                    if (remove) {\n                        const subObserver = this._subObservers.get(node);\n\n                        if (subObserver) {\n                            subObserver.disconnect();\n                            this._subObservers.delete(node);\n                        }\n                    } else {\n                        const shadowRoot = (node as Element).shadowRoot;\n\n                        if (shadowRoot) {\n                            this._addSubObserver(shadowRoot);\n                        }\n                    }\n                }\n\n                return NodeFilter.FILTER_SKIP;\n            },\n        });\n\n        walker.nextNode();\n    }\n\n    public takeRecords(): MutationRecord[] {\n        const records = this._observer.takeRecords();\n\n        for (const subObserver of this._subObservers.values()) {\n            records.push(...subObserver.takeRecords());\n        }\n\n        return records;\n    }\n}\n\nexport function createShadowMutationObserver(\n    callback: MutationCallback\n): MutationObserver {\n    return new ShadowMutationObserver(callback);\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nfunction shadowQuerySelector(\n    node: ParentNode,\n    selector: string,\n    all: boolean\n): Element[] {\n    // TODO: This is probably slow. Optimize to use each shadowRoot's querySelector/querySelectorAll\n    //       instead of walking the tree.\n\n    const elements: Element[] = [];\n\n    walk(node, selector);\n\n    return elements;\n\n    function walk(from: Node, selector: string): void {\n        let el: Element | null = null;\n\n        const walker = document.createTreeWalker(\n            from,\n            NodeFilter.SHOW_ELEMENT,\n            {\n                acceptNode: (n) => {\n                    if (n.nodeType === Node.ELEMENT_NODE) {\n                        if ((n as Element).matches(selector)) {\n                            el = n as Element;\n                            elements.push(el);\n                            return all\n                                ? NodeFilter.FILTER_SKIP\n                                : NodeFilter.FILTER_ACCEPT;\n                        }\n\n                        const shadowRoot = (n as Element).shadowRoot;\n\n                        if (shadowRoot) {\n                            walk(shadowRoot, selector);\n                            return !all && elements.length\n                                ? NodeFilter.FILTER_ACCEPT\n                                : NodeFilter.FILTER_SKIP;\n                        }\n                    }\n                    return NodeFilter.FILTER_SKIP;\n                },\n            }\n        );\n\n        walker.nextNode();\n    }\n}\n\nexport function querySelectorAll(\n    node: ParentNode,\n    selector: string\n): Element[] {\n    return shadowQuerySelector(node, selector, true);\n}\n\nexport function querySelector(\n    node: ParentNode,\n    selector: string\n): Element | null {\n    return shadowQuerySelector(node, selector, false)[0] || null;\n}\n\nexport function getElementById(doc: Document, id: string): HTMLElement | null {\n    return querySelector(doc, \"#\" + id) as HTMLElement | null;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\n// TODO: The functions below do not consider Shadow DOM slots yet. We will be adding\n// support for slots as the need arises.\n\nexport { createShadowTreeWalker as createTreeWalker } from \"./ShadowTreeWalker\";\nexport { createShadowMutationObserver as createMutationObserver } from \"./ShadowMutationObserver\";\nexport {\n    appendChild,\n    getActiveElement,\n    getFirstChild,\n    getFirstElementChild,\n    getLastChild,\n    getLastElementChild,\n    getNextElementSibling,\n    getNextSibling,\n    getParentElement,\n    getParentNode,\n    getPreviousElementSibling,\n    getPreviousSibling,\n    getSelection,\n    insertBefore,\n    nodeContains,\n} from \"./DOMFunctions\";\nexport {\n    getElementById,\n    querySelector,\n    querySelectorAll,\n} from \"./querySelector\";\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { CrossOriginAPI } from \"./CrossOrigin\";\nimport { DeloserAPI } from \"./Deloser\";\nimport { FocusableAPI } from \"./Focusable\";\nimport { FocusedElementState } from \"./State/FocusedElement\";\nimport { GroupperAPI } from \"./Groupper\";\nimport { getTabsterOnElement, updateTabsterByAttribute } from \"./Instance\";\nimport { KeyboardNavigationState } from \"./State/KeyboardNavigation\";\nimport { ModalizerAPI } from \"./Modalizer\";\nimport { MoverAPI } from \"./Mover\";\nimport { observeMutations } from \"./MutationEvent\";\nimport { ObservedElementAPI } from \"./State/ObservedElement\";\nimport { OutlineAPI } from \"./Outline\";\nimport { RootAPI, WindowWithTabsterInstance } from \"./Root\";\nimport * as Types from \"./Types\";\nimport * as Events from \"./Events\";\nimport { UncontrolledAPI } from \"./Uncontrolled\";\nimport {\n    cleanupFakeWeakRefs,\n    clearElementCache,\n    createElementTreeWalker,\n    createWeakMap,\n    disposeInstanceContext,\n    startFakeWeakRefsCleanup,\n    stopFakeWeakRefsCleanupAndClearStorage,\n    DummyInputObserver,\n} from \"./Utils\";\nimport { RestorerAPI } from \"./Restorer\";\nimport { dom, setDOMAPI } from \"./DOMAPI\";\nimport * as shadowDOMAPI from \"./Shadowdomize\";\n\nexport { Types };\nexport { Events };\nexport * from \"./AttributeHelpers\";\n\nclass Tabster implements Types.Tabster {\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    core: Types.TabsterCore;\n\n    constructor(tabster: Types.TabsterCore) {\n        this.keyboardNavigation = tabster.keyboardNavigation;\n        this.focusedElement = tabster.focusedElement;\n        this.focusable = tabster.focusable;\n        this.root = tabster.root;\n        this.uncontrolled = tabster.uncontrolled;\n        this.core = tabster;\n    }\n}\n\n/**\n * Extends Window to include an internal Tabster instance.\n */\nclass TabsterCore implements Types.TabsterCore {\n    private _storage: WeakMap<HTMLElement, Types.TabsterElementStorage>;\n    private _unobserve: (() => void) | undefined;\n    private _win: WindowWithTabsterInstance | undefined;\n    private _forgetMemorizedTimer: number | undefined;\n    private _forgetMemorizedElements: HTMLElement[] = [];\n    private _wrappers: Set<Tabster> = new Set<Tabster>();\n    private _initTimer: number | undefined;\n    private _initQueue: (() => void)[] = [];\n\n    _version: string = __VERSION__;\n    _noop = false;\n    controlTab: boolean;\n    rootDummyInputs: boolean;\n\n    // Core APIs\n    keyboardNavigation: Types.KeyboardNavigationState;\n    focusedElement: Types.FocusedElementState;\n    focusable: Types.FocusableAPI;\n    root: Types.RootAPI;\n    uncontrolled: Types.UncontrolledAPI;\n    internal: Types.InternalAPI;\n    _dummyObserver: Types.DummyInputObserver;\n\n    // Extended APIs\n    groupper?: Types.GroupperAPI;\n    mover?: Types.MoverAPI;\n    outline?: Types.OutlineAPI;\n    deloser?: Types.DeloserAPI;\n    modalizer?: Types.ModalizerAPI;\n    observedElement?: Types.ObservedElementAPI;\n    crossOrigin?: Types.CrossOriginAPI;\n    restorer?: Types.RestorerAPI;\n    getParent: (el: Node) => Node | null;\n\n    constructor(win: Window, props?: Types.TabsterCoreProps) {\n        this._storage = createWeakMap(win);\n        this._win = win;\n\n        const getWindow = this.getWindow;\n\n        if (props?.DOMAPI) {\n            setDOMAPI({ ...props.DOMAPI });\n        }\n\n        this.keyboardNavigation = new KeyboardNavigationState(getWindow);\n        this.focusedElement = new FocusedElementState(this, getWindow);\n        this.focusable = new FocusableAPI(this);\n        this.root = new RootAPI(this, props?.autoRoot);\n        this.uncontrolled = new UncontrolledAPI(\n            // TODO: Remove checkUncontrolledTrappingFocus in the next major version.\n            props?.checkUncontrolledCompletely ||\n                props?.checkUncontrolledTrappingFocus\n        );\n        this.controlTab = props?.controlTab ?? true;\n        this.rootDummyInputs = !!props?.rootDummyInputs;\n\n        this._dummyObserver = new DummyInputObserver(getWindow);\n\n        this.getParent = props?.getParent ?? dom.getParentNode;\n\n        this.internal = {\n            stopObserver: (): void => {\n                if (this._unobserve) {\n                    this._unobserve();\n                    delete this._unobserve;\n                }\n            },\n\n            resumeObserver: (syncState: boolean): void => {\n                if (!this._unobserve) {\n                    const doc = getWindow().document;\n                    this._unobserve = observeMutations(\n                        doc,\n                        this,\n                        updateTabsterByAttribute,\n                        syncState\n                    );\n                }\n            },\n        };\n\n        startFakeWeakRefsCleanup(getWindow);\n\n        // Gives a tick to the host app to initialize other tabster\n        // APIs before tabster starts observing attributes.\n        this.queueInit(() => {\n            this.internal.resumeObserver(true);\n        });\n    }\n\n    /**\n     * Merges external props with the current props. Not all\n     * props can/should be mergeable, so let's add more as we move on.\n     * @param props Tabster props\n     */\n    private _mergeProps(props?: Types.TabsterCoreProps) {\n        if (!props) {\n            return;\n        }\n\n        this.getParent = props.getParent ?? this.getParent;\n    }\n\n    createTabster(\n        noRefCount?: boolean,\n        props?: Types.TabsterCoreProps\n    ): Types.Tabster {\n        const wrapper = new Tabster(this);\n\n        if (!noRefCount) {\n            this._wrappers.add(wrapper);\n        }\n\n        this._mergeProps(props);\n\n        return wrapper;\n    }\n\n    disposeTabster(wrapper: Types.Tabster, allInstances?: boolean) {\n        if (allInstances) {\n            this._wrappers.clear();\n        } else {\n            this._wrappers.delete(wrapper);\n        }\n\n        if (this._wrappers.size === 0) {\n            this.dispose();\n        }\n    }\n\n    dispose(): void {\n        this.internal.stopObserver();\n\n        const win = this._win;\n\n        win?.clearTimeout(this._initTimer);\n        delete this._initTimer;\n        this._initQueue = [];\n\n        this._forgetMemorizedElements = [];\n\n        if (win && this._forgetMemorizedTimer) {\n            win.clearTimeout(this._forgetMemorizedTimer);\n            delete this._forgetMemorizedTimer;\n        }\n\n        this.outline?.dispose();\n        this.crossOrigin?.dispose();\n        this.deloser?.dispose();\n        this.groupper?.dispose();\n        this.mover?.dispose();\n        this.modalizer?.dispose();\n        this.observedElement?.dispose();\n        this.restorer?.dispose();\n\n        this.keyboardNavigation.dispose();\n        this.focusable.dispose();\n        this.focusedElement.dispose();\n        this.root.dispose();\n\n        this._dummyObserver.dispose();\n\n        stopFakeWeakRefsCleanupAndClearStorage(this.getWindow);\n        clearElementCache(this.getWindow);\n\n        this._storage = new WeakMap();\n        this._wrappers.clear();\n\n        if (win) {\n            disposeInstanceContext(win);\n            delete win.__tabsterInstance;\n            delete this._win;\n        }\n    }\n\n    storageEntry(\n        element: HTMLElement,\n        addremove?: boolean\n    ): Types.TabsterElementStorageEntry | undefined {\n        const storage = this._storage;\n        let entry = storage.get(element);\n\n        if (entry) {\n            if (addremove === false && Object.keys(entry).length === 0) {\n                storage.delete(element);\n            }\n        } else if (addremove === true) {\n            entry = {};\n            storage.set(element, entry);\n        }\n\n        return entry;\n    }\n\n    getWindow = () => {\n        if (!this._win) {\n            throw new Error(\"Using disposed Tabster.\");\n        }\n\n        return this._win;\n    };\n\n    forceCleanup(): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._forgetMemorizedElements.push(this._win.document.body);\n\n        if (this._forgetMemorizedTimer) {\n            return;\n        }\n\n        this._forgetMemorizedTimer = this._win.setTimeout(() => {\n            delete this._forgetMemorizedTimer;\n\n            for (\n                let el: HTMLElement | undefined =\n                    this._forgetMemorizedElements.shift();\n                el;\n                el = this._forgetMemorizedElements.shift()\n            ) {\n                clearElementCache(this.getWindow, el);\n                FocusedElementState.forgetMemorized(this.focusedElement, el);\n            }\n        }, 0);\n\n        cleanupFakeWeakRefs(this.getWindow, true);\n    }\n\n    queueInit(callback: () => void): void {\n        if (!this._win) {\n            return;\n        }\n\n        this._initQueue.push(callback);\n\n        if (!this._initTimer) {\n            this._initTimer = this._win?.setTimeout(() => {\n                delete this._initTimer;\n                this.drainInitQueue();\n            }, 0);\n        }\n    }\n\n    drainInitQueue(): void {\n        if (!this._win) {\n            return;\n        }\n\n        const queue = this._initQueue;\n        // Resetting the queue before calling the callbacks to avoid recursion.\n        this._initQueue = [];\n        queue.forEach((callback) => callback());\n    }\n}\n\nexport function forceCleanup(tabster: Types.Tabster): void {\n    // The only legit case for calling this method is when you've completely removed\n    // the application DOM and not going to add the new one for a while.\n    const tabsterCore = tabster.core;\n    tabsterCore.forceCleanup();\n}\n\n/**\n * Creates an instance of Tabster, returns the current window instance if it already exists.\n */\nexport function createTabster(\n    win: Window,\n    props?: Types.TabsterCoreProps\n): Types.Tabster {\n    let tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    if (tabster) {\n        return tabster.createTabster(false, props);\n    }\n\n    tabster = new TabsterCore(win, props);\n\n    (win as WindowWithTabsterInstance).__tabsterInstance = tabster;\n\n    return tabster.createTabster();\n}\n\n/**\n * Returns an instance of Tabster if it was created before or null.\n */\nexport function getTabster(win: Window): Types.Tabster | null {\n    const tabster = getCurrentTabster(win as WindowWithTabsterInstance);\n\n    return tabster ? tabster.createTabster(true) : null;\n}\n\nexport function getShadowDOMAPI(): Types.DOMAPI {\n    return shadowDOMAPI;\n}\n\n/**\n * Creates a new groupper instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getGroupper(tabster: Types.Tabster): Types.GroupperAPI {\n    const tabsterCore = tabster.core;\n\n    if (!tabsterCore.groupper) {\n        tabsterCore.groupper = new GroupperAPI(\n            tabsterCore,\n            tabsterCore.getWindow\n        );\n    }\n\n    return tabsterCore.groupper;\n}\n\n/**\n * Creates a new mover instance or returns an existing one\n * @param tabster Tabster instance\n */\nexport function getMover(tabster: Types.Tabster): Types.MoverAPI {\n    const tabsterCore = tabster.core;\n\n    if (!tabsterCore.mover) {\n        tabsterCore.mover = new MoverAPI(tabsterCore, tabsterCore.getWindow);\n    }\n\n    return tabsterCore.mover;\n}\n\nexport function getOutline(tabster: Types.Tabster): Types.OutlineAPI {\n    const tabsterCore = tabster.core;\n\n    if (!tabsterCore.outline) {\n        tabsterCore.outline = new OutlineAPI(tabsterCore);\n    }\n\n    return tabsterCore.outline;\n}\n\n/**\n * Creates a new new deloser instance or returns an existing one\n * @param tabster Tabster instance\n * @param props Deloser props\n */\nexport function getDeloser(\n    tabster: Types.Tabster,\n    props?: { autoDeloser: Types.DeloserProps }\n): Types.DeloserAPI {\n    const tabsterCore = tabster.core;\n\n    if (!tabsterCore.deloser) {\n        tabsterCore.deloser = new DeloserAPI(tabsterCore, props);\n    }\n\n    return tabsterCore.deloser;\n}\n\n/**\n * Creates a new modalizer instance or returns an existing one\n * @param tabster Tabster instance\n * @param alwaysAccessibleSelector When Modalizer is active, we put\n * aria-hidden to everything else to hide it from screen readers. This CSS\n * selector allows to exclude some elements from this behaviour. For example,\n * this could be used to exclude aria-live region with the application-wide\n * status announcements.\n * @param accessibleCheck An optional callback that will be called when\n * active Modalizer wants to hide an element that doesn't belong to it from\n * the screen readers by setting aria-hidden. Similar to alwaysAccessibleSelector\n * but allows to address the elements programmatically rather than with a selector.\n * If the callback returns true, the element will not receive aria-hidden.\n */\nexport function getModalizer(\n    tabster: Types.Tabster,\n    // @deprecated use accessibleCheck.\n    alwaysAccessibleSelector?: string,\n    accessibleCheck?: Types.ModalizerElementAccessibleCheck\n): Types.ModalizerAPI {\n    const tabsterCore = tabster.core;\n\n    if (!tabsterCore.modalizer) {\n        tabsterCore.modalizer = new ModalizerAPI(\n            tabsterCore,\n            alwaysAccessibleSelector,\n            accessibleCheck\n        );\n    }\n\n    return tabsterCore.modalizer;\n}\n\nexport function getObservedElement(\n    tabster: Types.Tabster\n): Types.ObservedElementAPI {\n    const tabsterCore = tabster.core;\n\n    if (!tabsterCore.observedElement) {\n        tabsterCore.observedElement = new ObservedElementAPI(tabsterCore);\n    }\n\n    return tabsterCore.observedElement;\n}\n\nexport function getCrossOrigin(tabster: Types.Tabster): Types.CrossOriginAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.crossOrigin) {\n        getDeloser(tabster);\n        getModalizer(tabster);\n        getMover(tabster);\n        getGroupper(tabster);\n        getOutline(tabster);\n        getObservedElement(tabster);\n        tabsterCore.crossOrigin = new CrossOriginAPI(tabsterCore);\n    }\n\n    return tabsterCore.crossOrigin;\n}\n\nexport function getInternal(tabster: Types.Tabster): Types.InternalAPI {\n    const tabsterCore = tabster.core;\n    return tabsterCore.internal;\n}\n\nexport function getRestorer(tabster: Types.Tabster): Types.RestorerAPI {\n    const tabsterCore = tabster.core;\n    if (!tabsterCore.restorer) {\n        tabsterCore.restorer = new RestorerAPI(tabsterCore);\n    }\n\n    return tabsterCore.restorer;\n}\n\nexport function disposeTabster(\n    tabster: Types.Tabster,\n    allInstances?: boolean\n): void {\n    tabster.core.disposeTabster(tabster, allInstances);\n}\n\n/**\n * Returns an instance of Tabster if it already exists on the window .\n * @param win window instance that could contain an Tabster instance.\n */\nexport function getCurrentTabster(win: Window): Types.TabsterCore | undefined {\n    return (win as WindowWithTabsterInstance).__tabsterInstance;\n}\n\n/**\n * Allows to make Tabster non operational. Intended for performance debugging (and other\n * kinds of debugging), you can switch Tabster off without changing the application code\n * that consumes it.\n * @param tabster a reference created by createTabster().\n * @param noop true if you want to make Tabster noop, false if you want to turn it back.\n */\nexport function makeNoOp(tabster: Types.Tabster, noop: boolean): void {\n    const core = tabster.core;\n\n    if (core._noop !== noop) {\n        core._noop = noop;\n\n        const processNode = (element: HTMLElement): number => {\n            if (!element.getAttribute) {\n                return NodeFilter.FILTER_SKIP;\n            }\n\n            if (\n                getTabsterOnElement(core, element) ||\n                element.hasAttribute(Types.TabsterAttributeName)\n            ) {\n                updateTabsterByAttribute(core, element);\n            }\n\n            return NodeFilter.FILTER_SKIP;\n        };\n\n        const doc = core.getWindow().document;\n        const body = doc.body;\n\n        processNode(body);\n\n        const walker = createElementTreeWalker(doc, body, processNode);\n\n        if (walker) {\n            while (walker.nextNode()) {\n                /* Iterating for the sake of calling processNode() callback. */\n            }\n        }\n    }\n}\n\nexport function isNoOp(tabster: Types.TabsterCore): boolean {\n    return (tabster as TabsterCore)._noop;\n}\n","/*!\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License.\n */\n\nimport { GroupperMoveFocusAction, MoverKey } from \"./Types\";\nimport {\n    GroupperMoveFocusEvent,\n    MoverMoveFocusEvent,\n    MoverMemorizedElementEvent,\n} from \"./Events\";\n\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new GroupperMoveFocusEvent(...)). */\nexport function dispatchGroupperMoveFocusEvent(\n    target: HTMLElement,\n    action: GroupperMoveFocusAction\n) {\n    return target.dispatchEvent(new GroupperMoveFocusEvent({ action }));\n}\n\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new MoverMoveFocusEvent(...)). */\nexport function dispatchMoverMoveFocusEvent(\n    target: HTMLElement,\n    key: MoverKey\n) {\n    return target.dispatchEvent(new MoverMoveFocusEvent({ key }));\n}\n\n/** @deprecated This function is obsolete, use native element.dispatchEvent(new MoverMemorizedElementEvent(...)). */\nexport function dispatchMoverMemorizedElementEvent(\n    target: HTMLElement,\n    memorizedElement: HTMLElement | undefined\n) {\n    return target.dispatchEvent(\n        new MoverMemorizedElementEvent({ memorizedElement })\n    );\n}\n"],"names":["TabsterAttributeName","TabsterDummyInputAttributeName","FocusableSelector","join","AsyncFocusSources","EscapeGroupper","Restorer","Deloser","ObservedElementAccesibilities","Any","Accessible","Focusable","RestoreFocusOrders","History","DeloserDefault","RootDefault","DeloserFirst","RootFirst","DeloserStrategies","Auto","Manual","Visibilities","Invisible","PartiallyVisible","Visible","RestorerTypes","Source","Target","MoverDirections","Both","Vertical","Horizontal","Grid","GridLinear","MoverKeys","ArrowUp","ArrowDown","ArrowLeft","ArrowRight","PageUp","PageDown","Home","End","GroupperTabbabilities","Unlimited","Limited","LimitedTrapFocus","GroupperMoveFocusActions","Enter","Escape","SysDummyInputsPositions","Inside","Outside","getTabsterOnElement","tabster","element","storageEntry","updateTabsterByAttribute","dispose","newAttrValue","_noop","undefined","getAttribute","Types","entry","newAttr","attr","string","newValue","JSON","parse","Error","object","e","__DEV__","console","error","tabsterOnElement","oldTabsterProps","newTabsterProps","key","Object","keys","root","onRoot","part","observedElement","onObservedElementUpdate","sys","deloser","setProps","createDeloser","createRoot","modalizer","createModalizer","restorer","createRestorer","focusable","groupper","createGroupper","mover","createMover","observed","uncontrolled","outline","length","TabsterFocusInEventName","TabsterFocusOutEventName","TabsterMoveFocusEventName","DeloserFocusLostEventName","DeloserRestoreFocusEventName","ModalizerActiveEventName","ModalizerInactiveEventName","ModalizerFocusInEventName","ModalizerFocusOutEventName","MoverStateEventName","MoverMoveFocusEventName","MoverMemorizedElementEventName","GroupperMoveFocusEventName","RestorerRestoreFocusEventName","RootFocusEventName","RootBlurEventName","CustomEvent_","CustomEvent","TabsterCustomEvent","constructor","type","detail","bubbles","cancelable","composed","details","TabsterFocusInEvent","TabsterFocusOutEvent","TabsterMoveFocusEvent","MoverStateEvent","MoverMoveFocusEvent","MoverMemorizedElementEvent","GroupperMoveFocusEvent","ModalizerActiveEvent","ModalizerInactiveEvent","DeloserFocusLostEvent","DeloserRestoreFocusEvent","RestorerRestoreFocusEvent","RootFocusEvent","RootBlurEvent","_createMutationObserver","callback","MutationObserver","_createTreeWalker","doc","whatToShow","filter","createTreeWalker","_getParentNode","node","parentNode","_getParentElement","parentElement","_nodeContains","parent","child","contains","_getActiveElement","activeElement","_querySelector","selector","querySelector","_querySelectorAll","Array","prototype","slice","call","querySelectorAll","_getElementById","id","getElementById","_getFirstChild","firstChild","_getLastChild","lastChild","_getNextSibling","nextSibling","_getPreviousSibling","previousSibling","_getFirstElementChild","firstElementChild","_getLastElementChild","lastElementChild","_getNextElementSibling","nextElementSibling","_getPreviousElementSibling","previousElementSibling","_appendChild","appendChild","_insertBefore","referenceChild","insertBefore","_getSelection","ref","ownerDocument","getSelection","dom","createMutationObserver","getParentNode","getParentElement","nodeContains","getActiveElement","getFirstChild","getLastChild","getNextSibling","getPreviousSibling","getFirstElementChild","getLastElementChild","getNextElementSibling","getPreviousElementSibling","setDOMAPI","domapi","_isBrokenIE11","_DOMRect","DOMRect","x","y","width","height","left","top","right","bottom","_uidCounter","document","NodeFilter","SHOW_ELEMENT","_updateDummyInputsTimeout","getInstanceContext","getWindow","win","ctx","__tabsterInstanceContext","elementByUId","basics","Promise","WeakRef","containerBoundingRectCache","lastContainerBoundingRectCacheId","fakeWeakRefs","fakeWeakRefsStarted","disposeInstanceContext","containerBoundingRectCacheTimer","clearTimeout","fakeWeakRefsTimer","createWeakMap","WeakMap","hasSubFocusable","FakeWeakRef","target","_target","deref","cleanup","fwr","forceRemove","documentContains","WeakHTMLElement","data","context","push","_ref","_data","get","getData","cleanupFakeWeakRefs","startFakeWeakRefsCleanup","getWeakRef","setTimeout","stopFakeWeakRefsCleanupAndClearStorage","createElementTreeWalker","acceptNode","nodeType","Node","ELEMENT_NODE","getBoundingRect","cacheId","__tabsterCacheId","cached","rect","scrollingElement","documentElement","clientWidth","clientHeight","r","getBoundingClientRect","Math","max","min","window","cId","isElementVerticallyVisibleInContainer","tolerance","container","getScrollableContainer","containerRect","elementRect","intersectionTolerance","topIntersection","bottomIntersection","totalIntersection","scrollIntoView","alignToTop","scrollTop","el","scrollWidth","scrollHeight","makeFocusIgnored","__shouldIgnoreFocus","shouldIgnoreFocus","getUId","wnd","rnd","Uint32Array","crypto","getRandomValues","msCrypto","i","random","srnd","toString","Date","now","getElementUId","uid","__tabsterElementUID","getWindowUId","__tabsterCrossOriginWindowUID","clearElementCache","wel","body","matchesSelector","matches","msMatchesSelector","webkitMatchesSelector","getPromise","_lastTabsterPartId","TabsterPart","props","_tabster","_element","_props","getElement","getProps","DummyInput","isOutside","fixedTarget","_fixedTarget","nativeFocus","input","onFocusIn","relatedTarget","_isBackward","useDefaultAction","onFocusOut","createElement","tabIndex","setAttribute","style","position","opacity","zIndex","setProperty","isFirst","_isPhantom","isPhantom","addEventListener","_focusIn","_focusOut","__tabsterDummyContainer","_disposeTimer","_clearDisposeTimeout","removeEventListener","removeChild","setTopLeft","isIn","current","previous","compareDocumentPosition","DOCUMENT_POSITION_FOLLOWING","DummyInputManagerPriorities","Root","Modalizer","Mover","Groupper","DummyInputManager","priority","outsideByDefault","callForDefaultAction","_instance","DummyInputManagerCore","_setHandlers","_onFocusIn","_onFocusOut","moveOut","backwards","moveOutWithDefaultAction","relatedEvent","getHandler","setTabbable","tabbable","moveWithPhantomDummy","moveOutOfElement","isBackward","dummy","tagName","isFocusable","potentialDummy","dummyFor","dispatchEvent","by","owner","next","addPhantomDummyWithTarget","sourceElement","targetElement","dummyParent","setDummyInputDebugValue","wrappers","what","map","w","DummyInputObserver","Set","WeakSet","_changedParents","has","add","_updateDummyInputsTimer","_win","_dummyElements","dummyElement","_dummyCallbacks","set","domChanged","_domChanged","remove","delete","_updateTimer","_updateQueue","clear","updatePositions","compute","_lastUpdateQueueTime","_scheduledUpdatePositions","scrollTopLeftCache","Map","setTopLeftCallbacks","manager","dummyInput","_onFocus","first","_firstDummy","last","_lastDummy","_ensurePosition","firstInput","lastInput","toFocus","_wrappers","wrapper","_getCurrent","_addTimer","_getWindow","_addTransformOffsets","_dummyObserver","_computeTransformOffsets","from","transformElements","_transformElements","newTransformElements","scrollLeft","scrollTopLeft","transform","getComputedStyle","_callForDefaultAction","instance","__tabsterDummy","forcedDummyPosition","dummyInputsPosition","_isOutside","_addDummyInputs","force","sort","a","b","firstDummyInput","lastDummyInput","elementParent","getAdjacentElement","prev","cur","adjacent","augmentAttribute","name","value","ret","aug","origVal","removeAttribute","origValue","isDisplayNone","elementDocument","computedStyle","defaultView","offsetParent","visibility","display","getTabsterAttribute","plain","stringify","mergeTabsterProps","newProps","setTabsterAttribute","update","_setInformativeStyle","weakElement","removeProperty","RootDummyManager","setFocused","_setFocused","keyboardNavigation","setNavigatingWithKeyboard","focusedElement","getFirstOrLastTabbable","ignoreAccessibility","blur","_onDummyInputFocus","onDispose","hasFocused","_setFocusedTimer","_isFocused","_dummyManager","event","getParent","rootElement","curElement","composedPath","_onDispose","_sys","controlTab","rootDummyInputs","addDummyInputs","KEYBORG_FOCUSIN","KEYBORG_FOCUSOUT","_add","_remove","dummyManager","RootAPI","autoRoot","_autoRootUnwait","_autoRoot","_autoRootWaiting","_autoRootCreate","_roots","queueInit","forEach","rootId","rootById","newRoot","_onRootDispose","_forceDummy","roots","getRootByUId","__tabsterInstance","getTabsterContext","options","checkRtl","referenceElement","drainInitQueue","excludedFromMover","groupperBeforeMover","modalizerInGroupper","dirRightToLeft","ignoreKeydown","dir","toLowerCase","excludeFromMover","curModalizer","curGroupper","curMover","isActive","tabbability","userId","activeId","assign","rootAPI","shouldIgnoreKeydown","rtl","getRoot","removed","_containerHistoryLength","DeloserItemBase","DeloserItem","_deloser","belongsTo","unshift","focusAvailable","available","findAvailable","deloserElement","focus","resetFocus","resolve","DeloserHistoryByRootBase","rootUId","getLength","_history","removeDeloser","c","hasDeloser","some","d","DeloserHistoryByRoot","unshiftToDeloser","item","splice","skip","result","resetQueue","DeloserHistory","process","DeloserAPI","getDeloser","historyByRoot","make","createInstance","hbr","h","snapshotIndex","buildElementSelector","withClass","withIndex","escapeRegExp","escapeReplaceValue","elementId","replace","className","split","cls","trim","index","buildSelector","DOCUMENT_FRAGMENT_NODE","isBody","_isActive","_snapshotIndex","focusFirst","focusDefault","preserveExisting","we","strategy","setActive","active","getActions","clearHistory","setSnapshot","pop","isVisible","restoreFocusOrder","findDefault","_findFirst","availableInHistory","_findInHistory","availableDefault","availableFirst","customFocusLostHandler","noSelectorCheck","els","isNavigatingWithKeyboard","findFirst","useActiveModalizer","stopImmediatePropagation","_restoreFocusTimer","_scheduleRestoreFocus","_activate","_deactivate","subscribe","_onRestoreFocus","autoDeloser","_autoDeloser","_autoDeloserInstance","unsubscribe","_curDeloser","_onDeloserDispose","getFocusedElement","pause","_isPaused","resume","restore","curDeloser","_inDeloser","_isRestoringFocus","restoreFocus","lastFocused","getLastFocusedElement","isManual","curDeloserElement","deloserAPI","autoDeloserProps","getHistory","forceRestoreFocus","Subscribable","_callbacks","_val","callbacks","indexOf","subscribeFirst","setVal","val","_callCallbacks","getVal","trigger","_transactionTimeout","_pingTimeout","_targetIdUp","CrossOriginTransactionTypes","Bootstrap","FocusElement","State","GetElement","RestoreFocusInDeloser","Ping","CrossOriginDeloserItem","trasactions","_transactions","deloserUId","reset","beginTransaction","RestoreFocusInDeloserTransaction","then","CrossOriginDeloserHistoryByRoot","transactions","CrossOriginTransaction","getOwner","knownTargets","timeout","sentTo","targetId","sendUp","ownerId","beginData","_knownTargets","_sentTo","_promise","reject","_resolve","_reject","getTargets","send","begin","selfResponse","targets","transaction","isResponse","timestamp","sentto","_isSelfResponding","endData","_sentCount","end","_send","_inProgress","_isDone","onResponse","inProgressId","BootstrapTransaction","shouldForward","makeResponse","FocusElementTransaction","shouldSelfRespond","GetElementTransaction","findElement","forwardResult","CrossOriginStates","Focused","Blurred","Observed","DeadWindow","KeyboardNavigation","Outline","StateTransaction","state","isSelfResponse","_makeFocusedResponse","_makeBlurredResponse","_makeObservedResponse","_makeDeadWindowResponse","_makeKeyboardNavigationResponse","_makeOutlineResponse","CrossOriginElement","ownerUId","observedName","observedDetails","focusOwner","focusOwnerTimestamp","history","historyItem","CrossOriginFocusedElementState","crossOrigin","isFocusedProgrammatically","CrossOriginObservedElementState","names","deadUId","removeTarget","ignoreKeyboardNavigationStateUpdate","origOutlineSetup","accessibility","getElementData","getDeloserUID","dataOut","isWaitElementResolved","isForwardResolved","isResolved","waitElement","forwardRet","deloserByUId","PingTransaction","CrossOriginTransactions","_ownerUId","transactionId","knownTarget","t","Transaction","_getTransactionClass","forwardTransaction","_owner","response","_dead","source","postMessage","_onMessage","setup","isSetUp","setSendUp","_onPageHide","_ping","_isDefaultSendUp","_onBrowserMessage","_pingTimer","_deadPromise","timer","withReject","_beginTransaction","catch","finally","deadWindows","all","focused","noFocusedProgrammaticallyFlag","noAccessibleCheck","_focus","focusById","focusByObservedName","elementData","requestFocus","requestId","_lastRequestFocusId","CrossOriginAPI","_onKeyboardNavigationStateChanged","_onObserved","_ctx","_outlineSetup","_blurTimer","_init","FocusableAPI","includeProgrammaticallyFocusable","noVisibleCheck","isAccessible","_isHidden","ignoreDisabled","ignoreAriaDisabled","_isDisabled","hasAttribute","attrVal","isAugmented","out","findLast","findNext","findPrev","acceptCondition","isDefault","findAll","_findElements","found","currentElement","modalizerId","onElement","elements","hasCustomCondition","acceptElementState","modalizerUserId","cachedGrouppers","walker","_acceptElement","prepareForNextElement","shouldContinueIfNotFound","foundElement","foundBackward","fromCtx","outOfDOMOrder","currentNode","FILTER_ACCEPT","skippedFocusable","previousNode","nextNode","FILTER_SKIP","FILTER_REJECT","rejectElementsFrom","currentCtx","fromMover","acceptElement","groupperElement","fromMoverElement","moverElement","Keys","Tab","Space","getUncontrolledCompletelyContainer","uncontrolledOnElement","isUncontrolledCompletely","completely","AsyncFocusIntentPriorityBySource","FocusedElementState","_onKeyDown","_setFocusedElement","_onChanged","originalEvent","ctrlKey","contentEditable","shiftKey","findNextTabbable","nextElement","uncontrolledCompletelyContainer","nextUncontrolled","preventDefault","_lastVal","lastCtx","asyncFocus","_asyncFocus","_lastResetElement","_nextVal","forgetMemorized","_focusFirstOrLast","focusLast","prevTabIndex","prevAriaHidden","_setOrRemoveAttribute","requestAsyncFocus","delay","currentAsyncFocus","cancelAsyncFocus","lastResetElement","nextVal","_validateFocusedElement","actualContainer","isTabbingTimer","_isTabbingTimer","isTabbing","callFindNext","parentCtx","currentScopeElement","newCurrent","findProps","findPropsOut","GroupperDummyManager","makeTabbable","_first","currentIsDummy","_shouldTabInside","groupperFirstFocusable","getFirst","isTabbable","noIfFirstIsFocused","isParentActive","g","orContainer","setFirst","parentCtxGroupper","parentGroupper","parentGroupperElement","getIsActive","GroupperAPI","_onMouseDown","_onMoveFocus","_grouppers","_updateCurrent","altKey","metaKey","handleKeyPress","action","defaultPrevented","_enterGroupper","_escapeGroupper","_current","groupperId","newGroupper","_onGroupperDispose","forgetCurrentGrouppers","includeTarget","checkTarget","newIds","isTarget","delegated","fromModalizer","moveFocus","KeyboardNavigationState","_keyborg","createKeyborg","_onChange","disposeKeyborg","_wasFocusedCounter","_ariaHidden","internalId","wasFocused","ModalizerDummyManager","dummyContainer","activeElements","_activeElements","_wasFocused","makeActive","_dispatchEvent","noIncrement","modalizerElement","isTrapped","allElements","eventDetail","ModalizerAPI","alwaysAccessibleSelector","accessibleCheck","_parts","_modalizers","focusedSince","m","f","augmentedMap","_augMap","currentIsOthersAccessible","isOthersAccessible","isAlwaysAccessible","_restoreModalizerFocusTimer","_restoreModalizerFocus","_aug","_alwaysAccessibleSelector","_accessibleCheck","_hiddenUpdateTimer","_onModalizerDispose","hiddenUpdate","_hiddenUpdate","elementFromModalizer","noFocusFirst","noFocusDefault","modalizerRoot","isNoFocusFirst","isNoFocusDefault","currentModalizer","parts","visibleElements","hiddenElements","alwaysAccessibleElements","activeModalizerElements","modalizerParts","allVisibleElements","newAugmented","newAugmentedMap","toggle","hide","walk","containsModalizer","containedByModalizer","elParent","outsideElement","DOCUMENT_POSITION_PRECEDING","_inputSelector","MoverDummyManager","getMemorized","memorized","_getMemorized","_onFocusDummyInput","_moverUpdateAdd","_moverUpdateAttr","_moverUpdateRemove","entries","newVisibility","fullyVisible","_fullyVisible","intersectionRatio","_visible","getState","visibilityTolerance","trackState","visibilityAware","_intersectionObserver","IntersectionObserver","_onIntersection","threshold","_observeState","memorizeCurrent","disconnect","_allElements","_unobserve","_setCurrentTimer","setCurrent","changed","_prevCurrent","weak","getCurrent","hasDefault","tabsterFocusable","updateQueue","observer","mutations","mutation","removedNodes","added","addedNodes","attributeName","requestUpdate","setElement","unobserve","observe","updateElement","addNewElements","getMoverGroupper","removeWalk","toe","childList","subtree","attributes","attributeFilter","isCurrent","getDistance","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","xDistance","yDistance","sqrt","MoverAPI","_onMemorizedElement","_movers","currentFocusableElement","deepestFocusableElement","_ignoredInputTimer","_ignoredInputResolve","moverKey","_isIgnoredInput","_moveFocus","memorizedElement","moverId","newMover","_onMoverDispose","fromElement","moverProps","direction","isBoth","isVertical","isHorizontal","isGridLinear","isGrid","isCyclic","cyclic","scrollIntoViewArg","focusedElementRect","focusedElementX1","focusedElementX2","ceil","floor","nextElementX1","nextElementX2","firstColumnX1","lastColumnX1","lastDistance","lastIntersection","xIntersectionWidth","minWidth","intersection","distance","selectionStart","selectionEnd","textLength","asyncRet","selection","initialLength","modify","selStart","anchorNode","prevAnchorNode","focusNode","prevFocusNode","anchorOffset","prevAnchorOffset","focusOffset","prevFocusOffset","textContent","anchorFound","addOffsets","nodeText","len","stop","observeMutations","syncState","onMutation","removedNode","updateTabsterElements","processNode","_conditionCheckTimeout","ObservedElementAPI","_currentRequest","delta","_currentRequestTimestamp","settleTime","cancel","info","_observedById","observedNames","prevNames","_isObservedNamesUpdated","prevName","obn","_observedByName","_waitConditional","_waiting","_rejectWaiting","shouldResolve","conditionTimer","o","prefix","request","promise","currentRequestFocus","waitingElementKey","waitingAccessibleElementKey","waitingFocusableElementKey","waitingElement","waitingAccessibleElement","waitingFocusableElement","waiting","includes","resolveAccessible","resolveFocusable","defaultProps","areaClass","outlineClass","outlineColor","outlineWidth","OutlinePosition","equalsTo","other","clone","OutlineAPI","_onScroll","_fullScreenEventName","_onFullScreenChanged","_fullScreenElementName","outlineElements","_getDOM","fsElement","_fullScreenElement","_updateElement","_isVisible","_setVisibility","_outlinedElement","_isParentChild","_curPos","_setOutlinePosition","__tabsterOutline","appendStyles","classList","_allOutlineElements","_removeDOM","_curOutlineElements","_shouldShowCustomOutline","isIgnored","inputType","outlinedInputTypes","button","checkbox","file","image","radio","range","submit","_updateOutline","visible","boundingRect","p","hasAbsolutePositionedParent","hasFixedPositionedParent","overflow","allRect","allWidth","allHeight","ow","leftBorderNode","topBorderNode","rightBorderNode","bottomBorderNode","sx","pageXOffset","sy","pageYOffset","background","contextElement","DOCUMENT_POSITION_CONTAINED_BY","createTextNode","getOutlineStyles","head","UncontrolledAPI","_isUncontrolledCompletely","HISOTRY_DEPTH","_hasFocus","RestorerAPI","_focusedElementState","_restoreFocus","tabsterAttribute","_addToHistory","_keyboardNavState","shift","shadowRoot","otherNode","assignedElements","assignedSlot","host","sibling","tmp","ShadowTreeWalker","_doc","_acceptNode","_walkerStack","SHOW_ALL","_currentNode","walkers","curNode","currentWalkerCurrentNode","_currentSetFor","nodeResult","currentWalker","createShadowTreeWalker","ShadowMutationObserver","_overrideAttachShadow","origAttachShadow","Element","attachShadow","__origAttachShadow","shadowObserver","_shadowObservers","_addSubObserver","_walkShadows","_callback","_observer","_callbackWrapper","_subObservers","_options","_root","subObserver","_isObserving","values","DOCUMENT_NODE","takeRecords","records","createShadowMutationObserver","shadowQuerySelector","n","Tabster","core","TabsterCore","__VERSION__","_storage","DOMAPI","checkUncontrolledCompletely","checkUncontrolledTrappingFocus","internal","stopObserver","resumeObserver","_mergeProps","createTabster","noRefCount","disposeTabster","allInstances","size","_initTimer","_initQueue","_forgetMemorizedElements","_forgetMemorizedTimer","addremove","storage","forceCleanup","queue","tabsterCore","getCurrentTabster","getTabster","getShadowDOMAPI","shadowDOMAPI","getGroupper","getMover","getOutline","getModalizer","getObservedElement","getCrossOrigin","getInternal","getRestorer","makeNoOp","noop","isNoOp","dispatchGroupperMoveFocusEvent","dispatchMoverMoveFocusEvent","dispatchMoverMemorizedElementEvent"],"mappings":";;;;;;AAAA;;;;AAKO,MAAMA,oBAAoB,GAAG,cAA7B;AACA,MAAMC,8BAA8B,GAAG,oBAAvC;AAEA,MAAMC,iBAAiB,gBAAG,CAC7B,SAD6B,EAE7B,wBAF6B,EAG7B,uBAH6B,EAI7B,wBAJ6B,EAK7B,0BAL6B,EAM7B,aAN6B,EAO7B,oBAP6B,EAQ7B,mBAR6B,EAS7B,iBAT6B,EAU7B,iBAV6B,EAW/BC,IAX+B,CAW1B,IAX0B,CAA1B;AA8HA,MAAMC,iBAAiB,GAAG;AAC7BC,EAAAA,cAAc,EAAE,CADa;AAE7BC,EAAAA,QAAQ,EAAE,CAFmB;AAG7BC,EAAAA,OAAO,EAAE;AAHoB,CAA1B;AAkFA,MAAMC,6BAA6B,GAAG;AACzCC,EAAAA,GAAG,EAAE,CADoC;AAEzCC,EAAAA,UAAU,EAAE,CAF6B;AAGzCC,EAAAA,SAAS,EAAE;AAH8B,CAAtC;AAoKA,MAAMC,kBAAkB,GAAG;AAC9BC,EAAAA,OAAO,EAAE,CADqB;AAE9BC,EAAAA,cAAc,EAAE,CAFc;AAG9BC,EAAAA,WAAW,EAAE,CAHiB;AAI9BC,EAAAA,YAAY,EAAE,CAJgB;AAK9BC,EAAAA,SAAS,EAAE;AALmB,CAA3B;AAWA,MAAMC,iBAAiB,GAAG;AAC7B;;;;AAIAC,EAAAA,IAAI,EAAE,CALuB;;AAM7B;;;;;;AAMAC,EAAAA,MAAM,EAAE;AAZqB,CAA1B;AAkRA,MAAMC,YAAY,GAAG;AACxBC,EAAAA,SAAS,EAAE,CADa;AAExBC,EAAAA,gBAAgB,EAAE,CAFM;AAGxBC,EAAAA,OAAO,EAAE;AAHe,CAArB;AAqBA,MAAMC,aAAa,GAAG;AACzBC,EAAAA,MAAM,EAAE,CADiB;AAEzBC,EAAAA,MAAM,EAAE;AAFiB,CAAtB;AAOA,MAAMC,eAAe,GAAG;AAC3BC,EAAAA,IAAI,EAAE,CADqB;AAE3BC,EAAAA,QAAQ,EAAE,CAFiB;AAG3BC,EAAAA,UAAU,EAAE,CAHe;AAI3BC,EAAAA,IAAI,EAAE,CAJqB;AAK3BC,EAAAA,UAAU,EAAE;AALe,CAAxB;AA0FA,MAAMC,SAAS,GAAG;AACrBC,EAAAA,OAAO,EAAE,CADY;AAErBC,EAAAA,SAAS,EAAE,CAFU;AAGrBC,EAAAA,SAAS,EAAE,CAHU;AAIrBC,EAAAA,UAAU,EAAE,CAJS;AAKrBC,EAAAA,MAAM,EAAE,CALa;AAMrBC,EAAAA,QAAQ,EAAE,CANW;AAOrBC,EAAAA,IAAI,EAAE,CAPe;AAQrBC,EAAAA,GAAG,EAAE;AARgB,CAAlB;AAmBA,MAAMC,qBAAqB,GAAG;AACjCC,EAAAA,SAAS,EAAE,CADsB;AAEjCC,EAAAA,OAAO,EAAE,CAFwB;AAGjCC,EAAAA,gBAAgB,EAAE,CAHe;;AAAA,CAA9B;AAqDA,MAAMC,wBAAwB,GAAG;AACpCC,EAAAA,KAAK,EAAE,CAD6B;AAEpCC,EAAAA,MAAM,EAAE;AAF4B,CAAjC;AA0EA,MAAMC,uBAAuB,GAAG;AACnC/B,EAAAA,IAAI,EAAE,CAD6B;AAEnCgC,EAAAA,MAAM,EAAE,CAF2B;AAGnCC,EAAAA,OAAO,EAAE,CAH0B;;AAAA,CAAhC;;;;;;;;;;;;;;;;;;;;ACj6BP;;;;SAOgBC,oBACZC,SACAC;;;AAEA,SAAO,MAAAD,OAAO,CAACE,YAAR,CAAqBD,OAArB,CAAA,UAAA,iBAAA,SAAA,MAA+BD,OAAtC;AACH;SAEeG,yBACZH,SACAC,SACAG;;;AAEA,QAAMC,YAAY,GACdD,OAAO,IAAIJ,OAAO,CAACM,KAAnB,GACMC,SADN,GAEMN,OAAO,CAACO,YAAR,CAAqBC,oBAArB,CAHV;AAKA,MAAIC,KAAK,GAAGV,OAAO,CAACE,YAAR,CAAqBD,OAArB,CAAZ;AACA,MAAIU,OAAJ;;AAEA,MAAIN,YAAJ,EAAkB;AACd,QAAIA,YAAY,MAAK,MAAAK,KAAK,SAAL,IAAAA,KAAK,WAAL,SAAA,GAAAA,KAAK,CAAEE,IAAP,UAAA,iBAAA,SAAA,MAAaC,MAAlB,CAAhB,EAA0C;AACtC,UAAI;AACA,cAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAL,CACbX,YADa,CAAjB;;AAIA,YAAI,OAAOS,QAAP,KAAoB,QAAxB,EAAkC;AAC9B,gBAAM,IAAIG,KAAJ,qCACkCZ,gBADlC,CAAN;AAGH;;AAEDM,QAAAA,OAAO,GAAG;AACNE,UAAAA,MAAM,EAAER,YADF;AAENa,UAAAA,MAAM,EAAEJ;AAFF,SAAV;AAIH,OAfD,CAeE,OAAOK,CAAP,EAAU;AACR,YAAIC,sCAAJ,EAAa;AACTC,UAAAA,OAAO,CAACC,KAAR,kCACqCH,GADrC,EAEIlB,OAFJ;AAIH;AACJ;AACJ,KAxBD,MAwBO;AACH;AACH;AACJ,GA5BD,MA4BO,IAAI,CAACS,KAAL,EAAY;AACf;AACH;;AAED,MAAI,CAACA,KAAL,EAAY;AACR;AACAA,IAAAA,KAAK,GAAGV,OAAO,CAACE,YAAR,CAAqBD,OAArB,EAA8B,IAA9B,CAAR;AACH;;AAED,MAAI,CAACS,KAAK,CAACV,OAAX,EAAoB;AAChBU,IAAAA,KAAK,CAACV,OAAN,GAAgB,EAAhB;AACH;;AAED,QAAMuB,gBAAgB,GAAGb,KAAK,CAACV,OAAN,IAAiB,EAA1C;AACA,QAAMwB,eAAe,GAAG,CAAA,MAAAd,KAAK,CAACE,IAAN,UAAA,iBAAA,SAAA,MAAYM,MAAZ,KAAsB,EAA9C;AACA,QAAMO,eAAe,GAAG,CAAAd,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAEO,MAAT,KAAmB,EAA3C;;AAEA,OAAK,MAAMQ,GAAX,IAAkBC,MAAM,CAACC,IAAP,CACdJ,eADc,CAAlB,EAE4C;AACxC,QAAI,CAACC,eAAe,CAACC,GAAD,CAApB,EAA2B;AACvB,UAAIA,GAAG,KAAK,MAAZ,EAAoB;AAChB,cAAMG,IAAI,GAAGN,gBAAgB,CAACG,GAAD,CAA7B;;AAEA,YAAIG,IAAJ,EAAU;AACN7B,UAAAA,OAAO,CAAC6B,IAAR,CAAaC,MAAb,CAAoBD,IAApB,EAA0B,IAA1B;AACH;AACJ;;AAED,cAAQH,GAAR;AACI,aAAK,SAAL;AACA,aAAK,MAAL;AACA,aAAK,UAAL;AACA,aAAK,WAAL;AACA,aAAK,UAAL;AACA,aAAK,OAAL;AACI;AACA,gBAAMK,IAAI,GAAGR,gBAAgB,CAACG,GAAD,CAA7B;;AACA,cAAIK,IAAJ,EAAU;AACNA,YAAAA,IAAI,CAAC3B,OAAL;AACA,mBAAOmB,gBAAgB,CAACG,GAAD,CAAvB;AACH;;AACD;;AAEJ,aAAK,UAAL;AACI,iBAAOH,gBAAgB,CAACG,GAAD,CAAvB;;AACA,cAAI1B,OAAO,CAACgC,eAAZ,EAA6B;AACzBhC,YAAAA,OAAO,CAACgC,eAAR,CAAwBC,uBAAxB,CACIhC,OADJ;AAGH;;AACD;;AAEJ,aAAK,WAAL;AACA,aAAK,SAAL;AACA,aAAK,cAAL;AACA,aAAK,KAAL;AACI,iBAAOsB,gBAAgB,CAACG,GAAD,CAAvB;AACA;AA7BR;AA+BH;AACJ;;AAED,OAAK,MAAMA,GAAX,IAAkBC,MAAM,CAACC,IAAP,CACdH,eADc,CAAlB,EAE4C;AACxC,UAAMS,GAAG,GAAGT,eAAe,CAACS,GAA5B;;AAEA,YAAQR,GAAR;AACI,WAAK,SAAL;AACI,YAAIH,gBAAgB,CAACY,OAArB,EAA8B;AAC1BZ,UAAAA,gBAAgB,CAACY,OAAjB,CAAyBC,QAAzB,CACIX,eAAe,CAACU,OADpB;AAGH,SAJD,MAIO;AACH,cAAInC,OAAO,CAACmC,OAAZ,EAAqB;AACjBZ,YAAAA,gBAAgB,CAACY,OAAjB,GACInC,OAAO,CAACmC,OAAR,CAAgBE,aAAhB,CACIpC,OADJ,EAEIwB,eAAe,CAACU,OAFpB,CADJ;AAKH,WAND,MAMO,IAAIf,sCAAJ,EAAa;AAChBC,YAAAA,OAAO,CAACC,KAAR,CACI,oEADJ;AAGH;AACJ;;AACD;;AAEJ,WAAK,MAAL;AACI,YAAIC,gBAAgB,CAACM,IAArB,EAA2B;AACvBN,UAAAA,gBAAgB,CAACM,IAAjB,CAAsBO,QAAtB,CACIX,eAAe,CAACI,IADpB;AAGH,SAJD,MAIO;AACHN,UAAAA,gBAAgB,CAACM,IAAjB,GAAwB7B,OAAO,CAAC6B,IAAR,CAAaS,UAAb,CACpBrC,OADoB,EAEpBwB,eAAe,CAACI,IAFI,EAGpBK,GAHoB,CAAxB;AAKH;;AACDlC,QAAAA,OAAO,CAAC6B,IAAR,CAAaC,MAAb,CAAoBP,gBAAgB,CAACM,IAArC;AACA;;AAEJ,WAAK,WAAL;AACI,YAAIN,gBAAgB,CAACgB,SAArB,EAAgC;AAC5BhB,UAAAA,gBAAgB,CAACgB,SAAjB,CAA2BH,QAA3B,CACIX,eAAe,CAACc,SADpB;AAGH,SAJD,MAIO;AACH,cAAIvC,OAAO,CAACuC,SAAZ,EAAuB;AACnBhB,YAAAA,gBAAgB,CAACgB,SAAjB,GACIvC,OAAO,CAACuC,SAAR,CAAkBC,eAAlB,CACIvC,OADJ,EAEIwB,eAAe,CAACc,SAFpB,EAGIL,GAHJ,CADJ;AAMH,WAPD,MAOO,IAAId,sCAAJ,EAAa;AAChBC,YAAAA,OAAO,CAACC,KAAR,CACI,wEADJ;AAGH;AACJ;;AACD;;AAEJ,WAAK,UAAL;AACI,YAAIC,gBAAgB,CAACkB,QAArB,EAA+B;AAC3BlB,UAAAA,gBAAgB,CAACkB,QAAjB,CAA0BL,QAA1B,CACIX,eAAe,CAACgB,QADpB;AAGH,SAJD,MAIO;AACH,cAAIzC,OAAO,CAACyC,QAAZ,EAAsB;AAClB,gBAAIhB,eAAe,CAACgB,QAApB,EAA8B;AAC1BlB,cAAAA,gBAAgB,CAACkB,QAAjB,GACIzC,OAAO,CAACyC,QAAR,CAAiBC,cAAjB,CACIzC,OADJ,EAEIwB,eAAe,CAACgB,QAFpB,CADJ;AAKH;AACJ,WARD,MAQO,IAAIrB,sCAAJ,EAAa;AAChBC,YAAAA,OAAO,CAACC,KAAR,CACI,sEADJ;AAGH;AACJ;;AAED;;AAEJ,WAAK,WAAL;AACIC,QAAAA,gBAAgB,CAACoB,SAAjB,GAA6BlB,eAAe,CAACkB,SAA7C;AACA;;AAEJ,WAAK,UAAL;AACI,YAAIpB,gBAAgB,CAACqB,QAArB,EAA+B;AAC3BrB,UAAAA,gBAAgB,CAACqB,QAAjB,CAA0BR,QAA1B,CACIX,eAAe,CAACmB,QADpB;AAGH,SAJD,MAIO;AACH,cAAI5C,OAAO,CAAC4C,QAAZ,EAAsB;AAClBrB,YAAAA,gBAAgB,CAACqB,QAAjB,GACI5C,OAAO,CAAC4C,QAAR,CAAiBC,cAAjB,CACI5C,OADJ,EAEIwB,eAAe,CAACmB,QAFpB,EAGIV,GAHJ,CADJ;AAMH,WAPD,MAOO,IAAId,sCAAJ,EAAa;AAChBC,YAAAA,OAAO,CAACC,KAAR,CACI,sEADJ;AAGH;AACJ;;AACD;;AAEJ,WAAK,OAAL;AACI,YAAIC,gBAAgB,CAACuB,KAArB,EAA4B;AACxBvB,UAAAA,gBAAgB,CAACuB,KAAjB,CAAuBV,QAAvB,CACIX,eAAe,CAACqB,KADpB;AAGH,SAJD,MAIO;AACH,cAAI9C,OAAO,CAAC8C,KAAZ,EAAmB;AACfvB,YAAAA,gBAAgB,CAACuB,KAAjB,GAAyB9C,OAAO,CAAC8C,KAAR,CAAcC,WAAd,CACrB9C,OADqB,EAErBwB,eAAe,CAACqB,KAFK,EAGrBZ,GAHqB,CAAzB;AAKH,WAND,MAMO,IAAId,sCAAJ,EAAa;AAChBC,YAAAA,OAAO,CAACC,KAAR,CACI,gEADJ;AAGH;AACJ;;AACD;;AAEJ,WAAK,UAAL;AACI,YAAItB,OAAO,CAACgC,eAAZ,EAA6B;AACzBT,UAAAA,gBAAgB,CAACyB,QAAjB,GAA4BvB,eAAe,CAACuB,QAA5C;AACAhD,UAAAA,OAAO,CAACgC,eAAR,CAAwBC,uBAAxB,CAAgDhC,OAAhD;AACH,SAHD,MAGO,IAAImB,sCAAJ,EAAa;AAChBC,UAAAA,OAAO,CAACC,KAAR,CACI,oFADJ;AAGH;;AACD;;AAEJ,WAAK,cAAL;AACIC,QAAAA,gBAAgB,CAAC0B,YAAjB,GAAgCxB,eAAe,CAACwB,YAAhD;AACA;;AAEJ,WAAK,SAAL;AACI,YAAIjD,OAAO,CAACkD,OAAZ,EAAqB;AACjB3B,UAAAA,gBAAgB,CAAC2B,OAAjB,GAA2BzB,eAAe,CAACyB,OAA3C;AACH,SAFD,MAEO,IAAI9B,sCAAJ,EAAa;AAChBC,UAAAA,OAAO,CAACC,KAAR,CACI,oEADJ;AAGH;;AACD;;AAEJ,WAAK,KAAL;AACIC,QAAAA,gBAAgB,CAACW,GAAjB,GAAuBT,eAAe,CAACS,GAAvC;AACA;;AAEJ;AACIb,QAAAA,OAAO,CAACC,KAAR,iBACoBI,uCADpB;AA3JR;AA+JH;;AAED,MAAIf,OAAJ,EAAa;AACTD,IAAAA,KAAK,CAACE,IAAN,GAAaD,OAAb;AACH,GAFD,MAEO;AACH,QAAIgB,MAAM,CAACC,IAAP,CAAYL,gBAAZ,EAA8B4B,MAA9B,KAAyC,CAA7C,EAAgD;AAC5C,aAAOzC,KAAK,CAACV,OAAb;AACA,aAAOU,KAAK,CAACE,IAAb;AACH;;AACDZ,IAAAA,OAAO,CAACE,YAAR,CAAqBD,OAArB,EAA8B,KAA9B;AACH;AACJ;;ACrSD;;;;;AAOA;;;AAIO,MAAMmD,uBAAuB,GAAG,iBAAhC;AACA,MAAMC,wBAAwB,GAAG,kBAAjC;AAGP;AACA;;AACO,MAAMC,yBAAyB,GAAG,mBAAlC;AAEP;;;;AAIO,MAAMC,yBAAyB,GAAG,4BAAlC;AAEP;;;;AAIO,MAAMC,4BAA4B,GAAG,+BAArC;AAEP;;;;AAGO,MAAMC,wBAAwB,GAAG,0BAAjC;AACA,MAAMC,0BAA0B,GAAG,4BAAnC;AACA,MAAMC,yBAAyB,GAAG,2BAAlC;AACA,MAAMC,0BAA0B,GAAG,4BAAnC;AAEP;;;;AAGO,MAAMC,mBAAmB,GAAG,qBAA5B;AAEP;;;AAIA;AACA;;AACO,MAAMC,uBAAuB,GAAG,yBAAhC;AAEP;;AACO,MAAMC,8BAA8B,GAAG,iCAAvC;AAEP;;;;AAIA;;;AAIA;AACA;;AACO,MAAMC,0BAA0B,GAAG,4BAAnC;AAEP;;;;AAIO,MAAMC,6BAA6B,GAAG,gCAAtC;AAEP;;;;AAGO,MAAMC,kBAAkB,GAAG,oBAA3B;AACA,MAAMC,iBAAiB,GAAG,mBAA1B;AAGP;AACA;;AACA,MAAMC,YAAY,GACd,OAAOC,WAAP,KAAuB,WAAvB,GACMA,WADN,GAEO;AACG;AACoB,CALlC;MAOsBC,2BAA8BF;AAMhDG,EAAAA,YAAYC,MAAcC;AACtB,UAAMD,IAAN,EAAY;AACRE,MAAAA,OAAO,EAAE,IADD;AAERC,MAAAA,UAAU,EAAE,IAFJ;AAGRC,MAAAA,QAAQ,EAAE,IAHF;AAIRH,MAAAA;AAJQ,KAAZ;AAOA,SAAKI,OAAL,GAAeJ,MAAf;AACH;;;MAUQK,4BAA4BR;AACrCC,EAAAA,YAAYE;AACR,UAAMrB,uBAAN,EAA+BqB,MAA/B;AACH;;;MAGQM,6BAA6BT;AACtCC,EAAAA,YAAYE;AACR,UAAMpB,wBAAN,EAAgCoB,MAAhC;AACH;;;MAGQO,8BAA8BV;AACvCC,EAAAA,YAAYE;AACR,UAAMnB,yBAAN,EAAiCmB,MAAjC;AACH;;;MAGQQ,wBAAwBX;AACjCC,EAAAA,YAAYE;AACR,UAAMZ,mBAAN,EAA2BY,MAA3B;AACH;;;MAKQS,4BAA4BZ;AACrCC,EAAAA,YAAYE;AACR,UAAMX,uBAAN,EAA+BW,MAA/B;AACH;;;MAOQU,mCAAmCb;AAC5CC,EAAAA,YAAYE;AACR,UAAMV,8BAAN,EAAsCU,MAAtC;AACH;;;MAOQW,+BAA+Bd;AACxCC,EAAAA,YAAYE;AACR,UAAMT,0BAAN,EAAkCS,MAAlC;AACH;;;MAQQY,6BAA6Bf;AACtCC,EAAAA,YAAYE;AACR,UAAMhB,wBAAN,EAAgCgB,MAAhC;AACH;;;MAGQa,+BAA+BhB;AACxCC,EAAAA,YAAYE;AACR,UAAMf,0BAAN,EAAkCe,MAAlC;AACH;;;MAGQc,8BAA8BjB;AACvCC,EAAAA,YAAYE;AACR,UAAMlB,yBAAN,EAAiCkB,MAAjC;AACH;;;MAGQe,iCAAiClB;AAC1CC,EAAAA;AACI,UAAMf,4BAAN;AACH;;;MAGQiC,kCAAkCnB;AAC3CC,EAAAA;AACI,UAAMN,6BAAN;AACH;;;MAOQyB,uBAAuBpB;AAChCC,EAAAA,YAAYE;AACR,UAAMP,kBAAN,EAA0BO,MAA1B;AACH;;;MAGQkB,sBAAsBrB;AAC/BC,EAAAA,YAAYE;AACR,UAAMN,iBAAN,EAAyBM,MAAzB;AACH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtNL;;;;AAOA,MAAMmB,uBAAuB,GAAIC,QAAD,IAC5B,IAAIC,gBAAJ,CAAqBD,QAArB,CADJ;;AAEA,MAAME,iBAAiB,GAAG,CACtBC,GADsB,EAEtBnE,IAFsB,EAGtBoE,UAHsB,EAItBC,MAJsB,KAKrBF,GAAG,CAACG,gBAAJ,CAAqBtE,IAArB,EAA2BoE,UAA3B,EAAuCC,MAAvC,CALL;;AAMA,MAAME,cAAc,GAAIC,IAAD,IACnBA,IAAI,GAAGA,IAAI,CAACC,UAAR,GAAqB,IAD7B;;AAEA,MAAMC,iBAAiB,GAAItG,OAAD,IACtBA,OAAO,GAAGA,OAAO,CAACuG,aAAX,GAA2B,IADtC;;AAEA,MAAMC,aAAa,GAAG,CAClBC,MADkB,EAElBC,KAFkB,KAGjB,CAAC,EAAEA,KAAK,KAAID,MAAM,SAAN,IAAAA,MAAM,WAAN,SAAA,GAAAA,MAAM,CAAEE,QAAR,CAAiBD,KAAjB,CAAJ,CAAP,CAHN;;AAIA,MAAME,iBAAiB,GAAIb,GAAD,IAAmBA,GAAG,CAACc,aAAjD;;AACA,MAAMC,cAAc,GAAG,CAAC9G,OAAD,EAAmB+G,QAAnB,KACnB/G,OAAO,CAACgH,aAAR,CAAsBD,QAAtB,CADJ;;AAEA,MAAME,iBAAiB,GAAG,CAACjH,OAAD,EAAsB+G,QAAtB,KACtBG,KAAK,CAACC,SAAN,CAAgBC,KAAhB,CAAsBC,IAAtB,CAA2BrH,OAAO,CAACsH,gBAAR,CAAyBP,QAAzB,CAA3B,EAA+D,CAA/D,CADJ;;AAEA,MAAMQ,eAAe,GAAG,CAACxB,GAAD,EAAgByB,EAAhB,KACpBzB,GAAG,CAAC0B,cAAJ,CAAmBD,EAAnB,CADJ;;AAEA,MAAME,cAAc,GAAItB,IAAD,IACnB,CAAAA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,SAAA,GAAAA,IAAI,CAAEuB,UAAN,KAAoB,IADxB;;AAEA,MAAMC,aAAa,GAAIxB,IAAD,IAClB,CAAAA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,SAAA,GAAAA,IAAI,CAAEyB,SAAN,KAAmB,IADvB;;AAEA,MAAMC,eAAe,GAAI1B,IAAD,IACpB,CAAAA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,SAAA,GAAAA,IAAI,CAAE2B,WAAN,KAAqB,IADzB;;AAEA,MAAMC,mBAAmB,GAAI5B,IAAD,IACxB,CAAAA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,SAAA,GAAAA,IAAI,CAAE6B,eAAN,KAAyB,IAD7B;;AAEA,MAAMC,qBAAqB,GACvBlI,OAD0B,IAET,CAAAA,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAEmI,iBAAT,KAA8B,IAFnD;;AAGA,MAAMC,oBAAoB,GACtBpI,OADyB,IAER,CAAAA,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAEqI,gBAAT,KAA6B,IAFlD;;AAGA,MAAMC,sBAAsB,GACxBtI,OAD2B,IAEV,CAAAA,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAEuI,kBAAT,KAA+B,IAFpD;;AAGA,MAAMC,0BAA0B,GAC5BxI,OAD+B,IAEd,CAAAA,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAEyI,sBAAT,KAAmC,IAFxD;;AAGA,MAAMC,YAAY,GAAG,CAACjC,MAAD,EAAeC,KAAf,KACjBD,MAAM,CAACkC,WAAP,CAAmBjC,KAAnB,CADJ;;AAEA,MAAMkC,aAAa,GAAG,CAClBnC,MADkB,EAElBC,KAFkB,EAGlBmC,cAHkB,KAIXpC,MAAM,CAACqC,YAAP,CAAoBpC,KAApB,EAA2BmC,cAA3B,CAJX;;AAKA,MAAME,aAAa,GAAIC,GAAD;;;AAClB,SAAA,CAAA,MAAAA,GAAG,CAACC,aAAJ,UAAA,iBAAA,SAAA,MAAmBC,cAAnB,KAAqC,IAArC;AAAyC,CAD7C;;AAGO,MAAMC,GAAG,GAAW;AACvBC,EAAAA,sBAAsB,EAAEzD,uBADD;AAEvBO,EAAAA,gBAAgB,EAAEJ,iBAFK;AAGvBuD,EAAAA,aAAa,EAAElD,cAHQ;AAIvBmD,EAAAA,gBAAgB,EAAEhD,iBAJK;AAKvBiD,EAAAA,YAAY,EAAE/C,aALS;AAMvBgD,EAAAA,gBAAgB,EAAE5C,iBANK;AAOvBI,EAAAA,aAAa,EAAEF,cAPQ;AAQvBQ,EAAAA,gBAAgB,EAAEL,iBARK;AASvBQ,EAAAA,cAAc,EAAEF,eATO;AAUvBkC,EAAAA,aAAa,EAAE/B,cAVQ;AAWvBgC,EAAAA,YAAY,EAAE9B,aAXS;AAYvB+B,EAAAA,cAAc,EAAE7B,eAZO;AAavB8B,EAAAA,kBAAkB,EAAE5B,mBAbG;AAcvB6B,EAAAA,oBAAoB,EAAE3B,qBAdC;AAevB4B,EAAAA,mBAAmB,EAAE1B,oBAfE;AAgBvB2B,EAAAA,qBAAqB,EAAEzB,sBAhBA;AAiBvB0B,EAAAA,yBAAyB,EAAExB,0BAjBJ;AAkBvBG,EAAAA,WAAW,EAAED,YAlBU;AAmBvBI,EAAAA,YAAY,EAAEF,aAnBS;AAoBvBM,EAAAA,YAAY,EAAEH;AApBS,CAApB;SAuBSkB,UAAUC;AACtB,OAAK,MAAMzI,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAYuI,MAAZ,CAAlB,EAA2D;AACtDf,IAAAA,GAAG,CAAC1H,GAAD,CAAH,GAAyCyI,MAAM,CAACzI,GAAD,CAA/C;AACJ;AACJ;;ACvFD;;;;;AAwDA,IAAI0I,aAAJ;;AAEA,MAAMC,QAAQ,GACV,OAAOC,OAAP,KAAmB,WAAnB,GACMA,OADN,GAEM;AAMI/F,EAAAA,YACIgG,GACAC,GACAC,OACAC;AAEA,SAAKC,IAAL,GAAYJ,CAAC,IAAI,CAAjB;AACA,SAAKK,GAAL,GAAWJ,CAAC,IAAI,CAAhB;AACA,SAAKK,KAAL,GAAa,CAACN,CAAC,IAAI,CAAN,KAAYE,KAAK,IAAI,CAArB,CAAb;AACA,SAAKK,MAAL,GAAc,CAACN,CAAC,IAAI,CAAN,KAAYE,MAAM,IAAI,CAAtB,CAAd;AACH;;CAnBf;;AAsBA,IAAIK,WAAW,GAAG,CAAlB;;AAEA,IAAI;AACA;AACA;AACA;AACAC,EAAAA,QAAQ,CAAC7E,gBAAT,CAA0B6E,QAA1B,EAAoCC,UAAU,CAACC,YAA/C;AACAd,EAAAA,aAAa,GAAG,KAAhB;AACH,CAND,CAME,OAAOjJ,CAAP,EAAU;AACRiJ,EAAAA,aAAa,GAAG,IAAhB;AACH;;AAED,MAAMe,yBAAyB,GAAG,GAAlC;SAQgBC,mBAAmBC;AAC/B,QAAMC,GAAG,GAAGD,SAAS,EAArB;AAEA,MAAIE,GAAG,GAAGD,GAAG,CAACE,wBAAd;;AAEA,MAAI,CAACD,GAAL,EAAU;AACNA,IAAAA,GAAG,GAAG;AACFE,MAAAA,YAAY,EAAE,EADZ;AAEFC,MAAAA,MAAM,EAAE;AACJC,QAAAA,OAAO,EAAEL,GAAG,CAACK,OAAJ,IAAepL,SADpB;AAEJqL,QAAAA,OAAO,EAAEN,GAAG,CAACM,OAAJ,IAAerL;AAFpB,OAFN;AAMFsL,MAAAA,0BAA0B,EAAE,EAN1B;AAOFC,MAAAA,gCAAgC,EAAE,CAPhC;AAQFC,MAAAA,YAAY,EAAE,EARZ;AASFC,MAAAA,mBAAmB,EAAE;AATnB,KAAN;AAYAV,IAAAA,GAAG,CAACE,wBAAJ,GAA+BD,GAA/B;AACH;;AAED,SAAOA,GAAP;AACH;SAEeU,uBAAuBX;AACnC,QAAMC,GAAG,GAAID,GAA6B,CAACE,wBAA3C;;AAEA,MAAID,GAAJ,EAAS;AACLA,IAAAA,GAAG,CAACE,YAAJ,GAAmB,EAAnB;AAEA,WAAOF,GAAG,CAACK,OAAX;AAEAL,IAAAA,GAAG,CAACM,0BAAJ,GAAiC,EAAjC;;AAEA,QAAIN,GAAG,CAACW,+BAAR,EAAyC;AACrCZ,MAAAA,GAAG,CAACa,YAAJ,CAAiBZ,GAAG,CAACW,+BAArB;AACH;;AAED,QAAIX,GAAG,CAACa,iBAAR,EAA2B;AACvBd,MAAAA,GAAG,CAACa,YAAJ,CAAiBZ,GAAG,CAACa,iBAArB;AACH;;AAEDb,IAAAA,GAAG,CAACQ,YAAJ,GAAmB,EAAnB;AAEA,WAAQT,GAA6B,CAACE,wBAAtC;AACH;AACJ;SAEea,cAAmCf;AAC/C,QAAMC,GAAG,GAAID,GAA6B,CAACE,wBAA3C;AACA,SAAO,KAAK,CAAAD,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEG,MAAL,CAAYY,OAAZ,KAAuBA,OAA5B,GAAP;AACH;SAEeC,gBAAgBtM;AAC5B,SAAO,CAAC,CAACA,OAAO,CAACgH,aAAR,CAAsBxG,iBAAtB,CAAT;AACH;;AAMD,MAAM+L,WAAN;AAKIjI,EAAAA,YAAYkI;AACR,SAAKC,OAAL,GAAeD,MAAf;AACH;;AAEDE,EAAAA,KAAK;AACD,WAAO,KAAKD,OAAZ;AACH;;AAEa,SAAPE,OAAO,CAACC,GAAD,EAAmBC,WAAnB;AACV,QAAI,CAACD,GAAG,CAACH,OAAT,EAAkB;AACd,aAAO,IAAP;AACH;;AAED,QACII,WAAW,IACX,CAACC,gBAAgB,CAACF,GAAG,CAACH,OAAJ,CAAYxD,aAAb,EAA4B2D,GAAG,CAACH,OAAhC,CAFrB,EAGE;AACE,aAAOG,GAAG,CAACH,OAAX;AACA,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH;;;;MAGQM;AAMTzI,EAAAA,YAAY8G,WAAsBpL,SAAYgN;AAC1C,UAAMC,OAAO,GAAG9B,kBAAkB,CAACC,SAAD,CAAlC;AAEA,QAAIpC,GAAJ;;AACA,QAAIiE,OAAO,CAACtB,OAAZ,EAAqB;AACjB3C,MAAAA,GAAG,GAAG,IAAIiE,OAAO,CAACtB,OAAZ,CAAoB3L,OAApB,CAAN;AACH,KAFD,MAEO;AACHgJ,MAAAA,GAAG,GAAG,IAAIuD,WAAJ,CAAgBvM,OAAhB,CAAN;AACAiN,MAAAA,OAAO,CAACnB,YAAR,CAAqBoB,IAArB,CAA0BlE,GAA1B;AACH;;AAED,SAAKmE,IAAL,GAAYnE,GAAZ;AACA,SAAKoE,KAAL,GAAaJ,IAAb;AACH;;AAEDK,EAAAA,GAAG;AACC,UAAMrE,GAAG,GAAG,KAAKmE,IAAjB;AACA,QAAInN,OAAJ;;AAEA,QAAIgJ,GAAJ,EAAS;AACLhJ,MAAAA,OAAO,GAAGgJ,GAAG,CAAC0D,KAAJ,EAAV;;AAEA,UAAI,CAAC1M,OAAL,EAAc;AACV,eAAO,KAAKmN,IAAZ;AACH;AACJ;;AAED,WAAOnN,OAAP;AACH;;AAEDsN,EAAAA,OAAO;AACH,WAAO,KAAKF,KAAZ;AACH;;;SAGWG,oBACZnC,WACAyB;AAEA,QAAMI,OAAO,GAAG9B,kBAAkB,CAACC,SAAD,CAAlC;AACA6B,EAAAA,OAAO,CAACnB,YAAR,GAAuBmB,OAAO,CAACnB,YAAR,CAAqB7F,MAArB,CAClB/E,CAAD,IAAO,CAACqL,WAAW,CAACI,OAAZ,CAAoBzL,CAApB,EAAsC2L,WAAtC,CADW,CAAvB;AAGH;SAEeW,yBAAyBpC;AACrC,QAAM6B,OAAO,GAAG9B,kBAAkB,CAACC,SAAD,CAAlC;;AAEA,MAAI,CAAC6B,OAAO,CAAClB,mBAAb,EAAkC;AAC9BkB,IAAAA,OAAO,CAAClB,mBAAR,GAA8B,IAA9B;AACAkB,IAAAA,OAAO,CAACtB,OAAR,GAAkB8B,UAAU,CAACR,OAAD,CAA5B;AACH;;AAED,MAAI,CAACA,OAAO,CAACd,iBAAb,EAAgC;AAC5Bc,IAAAA,OAAO,CAACd,iBAAR,GAA4Bf,SAAS,GAAGsC,UAAZ,CAAuB;AAC/CT,MAAAA,OAAO,CAACd,iBAAR,GAA4B7L,SAA5B;AACAiN,MAAAA,mBAAmB,CAACnC,SAAD,CAAnB;AACAoC,MAAAA,wBAAwB,CAACpC,SAAD,CAAxB;AACH,KAJ2B,EAIzB,IAAI,EAAJ,GAAS,IAJgB,CAA5B,CAD4B;AAM/B;AACJ;SAEeuC,uCACZvC;AAEA,QAAM6B,OAAO,GAAG9B,kBAAkB,CAACC,SAAD,CAAlC;AAEA6B,EAAAA,OAAO,CAAClB,mBAAR,GAA8B,KAA9B;;AAEA,MAAIkB,OAAO,CAACd,iBAAZ,EAA+B;AAC3Bf,IAAAA,SAAS,GAAGc,YAAZ,CAAyBe,OAAO,CAACd,iBAAjC;AACAc,IAAAA,OAAO,CAACd,iBAAR,GAA4B7L,SAA5B;AACA2M,IAAAA,OAAO,CAACnB,YAAR,GAAuB,EAAvB;AACH;AACJ;SAEe8B,wBACZ7H,KACAnE,MACAiM;AAEA;AACA,MAAIjM,IAAI,CAACkM,QAAL,KAAkBC,IAAI,CAACC,YAA3B,EAAyC;AACrC,WAAO1N,SAAP;AACH;;;AAGD,QAAM2F,MAAM,GAAIkE,aAAa,GACvB0D,UADuB,GAEtB;AAAEA,IAAAA;AAAF,GAFP;AAIA,SAAO1E,GAAG,CAACjD,gBAAJ,CACHH,GADG,EAEHnE,IAFG,EAGHoJ,UAAU,CAACC,YAHR,EAIHhF,MAJG;AAMH;AACA;AAAM;AAPH,GAAP;AASH;SAEegI,gBACZ7C,WACApL;AAEA,MAAIkO,OAAO,GAAGlO,OAAO,CAACmO,gBAAtB;AACA,QAAMlB,OAAO,GAAG9B,kBAAkB,CAACC,SAAD,CAAlC;AACA,QAAMgD,MAAM,GAAGF,OAAO,GAChBjB,OAAO,CAACrB,0BAAR,CAAmCsC,OAAnC,CADgB,GAEhB5N,SAFN;;AAIA,MAAI8N,MAAJ,EAAY;AACR,WAAOA,MAAM,CAACC,IAAd;AACH;;AAED,QAAMC,gBAAgB,GAClBtO,OAAO,CAACiJ,aAAR,IAAyBjJ,OAAO,CAACiJ,aAAR,CAAsBsF,eADnD;;AAGA,MAAI,CAACD,gBAAL,EAAuB;AACnB,WAAO,IAAIlE,QAAJ,EAAP;AACH;AAGD;;;AACA,MAAIM,IAAI,GAAG,CAAX;AACA,MAAIC,GAAG,GAAG,CAAV;AACA,MAAIC,KAAK,GAAG0D,gBAAgB,CAACE,WAA7B;AACA,MAAI3D,MAAM,GAAGyD,gBAAgB,CAACG,YAA9B;;AAEA,MAAIzO,OAAO,KAAKsO,gBAAhB,EAAkC;AAC9B,UAAMI,CAAC,GAAG1O,OAAO,CAAC2O,qBAAR,EAAV;AACAjE,IAAAA,IAAI,GAAGkE,IAAI,CAACC,GAAL,CAASnE,IAAT,EAAegE,CAAC,CAAChE,IAAjB,CAAP;AACAC,IAAAA,GAAG,GAAGiE,IAAI,CAACC,GAAL,CAASlE,GAAT,EAAc+D,CAAC,CAAC/D,GAAhB,CAAN;AACAC,IAAAA,KAAK,GAAGgE,IAAI,CAACE,GAAL,CAASlE,KAAT,EAAgB8D,CAAC,CAAC9D,KAAlB,CAAR;AACAC,IAAAA,MAAM,GAAG+D,IAAI,CAACE,GAAL,CAASjE,MAAT,EAAiB6D,CAAC,CAAC7D,MAAnB,CAAT;AACH;;AAED,QAAMwD,IAAI,GAAG,IAAIjE,QAAJ,CACTM,IAAI,GAAGE,KAAP,GAAeF,IAAf,GAAsB,CAAC,CADd,EAETC,GAAG,GAAGE,MAAN,GAAeF,GAAf,GAAqB,CAAC,CAFb,EAGTD,IAAI,GAAGE,KAAP,GAAeA,KAAK,GAAGF,IAAvB,GAA8B,CAHrB,EAITC,GAAG,GAAGE,MAAN,GAAeA,MAAM,GAAGF,GAAxB,GAA8B,CAJrB,CAAb;;AAOA,MAAI,CAACuD,OAAL,EAAc;AACVA,IAAAA,OAAO,GAAG,OAAO,EAAEjB,OAAO,CAACpB,gCAA3B;AACA7L,IAAAA,OAAO,CAACmO,gBAAR,GAA2BD,OAA3B;AACH;;AAEDjB,EAAAA,OAAO,CAACrB,0BAAR,CAAmCsC,OAAnC,IAA8C;AAC1CG,IAAAA,IAD0C;AAE1CrO,IAAAA;AAF0C,GAA9C;;AAKA,MAAI,CAACiN,OAAO,CAAChB,+BAAb,EAA8C;AAC1CgB,IAAAA,OAAO,CAAChB,+BAAR,GAA0C8C,MAAM,CAACrB,UAAP,CAAkB;AACxDT,MAAAA,OAAO,CAAChB,+BAAR,GAA0C3L,SAA1C;;AAEA,WAAK,MAAM0O,GAAX,IAAkBtN,MAAM,CAACC,IAAP,CAAYsL,OAAO,CAACrB,0BAApB,CAAlB,EAAmE;AAC/D,eAAOqB,OAAO,CAACrB,0BAAR,CAAmCoD,GAAnC,EAAwChP,OAAxC,CACFmO,gBADL;AAEH;;AAEDlB,MAAAA,OAAO,CAACrB,0BAAR,GAAqC,EAArC;AACH,KATyC,EASvC,EATuC,CAA1C;AAUH;;AAED,SAAOyC,IAAP;AACH;SAEeY,sCACZ7D,WACApL,SACAkP;AAEA,QAAMC,SAAS,GAAGC,sBAAsB,CAACpP,OAAD,CAAxC;;AACA,MAAI,CAACmP,SAAL,EAAgB;AACZ,WAAO,KAAP;AACH;;AAED,QAAME,aAAa,GAAGpB,eAAe,CAAC7C,SAAD,EAAY+D,SAAZ,CAArC;AACA,QAAMG,WAAW,GAAGtP,OAAO,CAAC2O,qBAAR,EAApB;AACA,QAAMY,qBAAqB,GAAGD,WAAW,CAAC7E,MAAZ,IAAsB,IAAIyE,SAA1B,CAA9B;AACA,QAAMM,eAAe,GAAGZ,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYQ,aAAa,CAAC1E,GAAd,GAAoB2E,WAAW,CAAC3E,GAA5C,CAAxB;AACA,QAAM8E,kBAAkB,GAAGb,IAAI,CAACC,GAAL,CACvB,CADuB,EAEvBS,WAAW,CAACzE,MAAZ,GAAqBwE,aAAa,CAACxE,MAFZ,CAA3B;AAIA,QAAM6E,iBAAiB,GAAGF,eAAe,GAAGC,kBAA5C;AAEA,SACIC,iBAAiB,KAAK,CAAtB,IAA2BA,iBAAiB,IAAIH,qBADpD;AAGH;SAyCeI,eACZvE,WACApL,SACA4P;AAEA;AACA;AACA,QAAMT,SAAS,GAAGC,sBAAsB,CAACpP,OAAD,CAAxC;;AAEA,MAAImP,SAAJ,EAAe;AACX,UAAME,aAAa,GAAGpB,eAAe,CAAC7C,SAAD,EAAY+D,SAAZ,CAArC;AACA,UAAMG,WAAW,GAAGtP,OAAO,CAAC2O,qBAAR,EAApB;;AAEA,QAAIiB,UAAJ,EAAgB;AACZT,MAAAA,SAAS,CAACU,SAAV,IAAuBP,WAAW,CAAC3E,GAAZ,GAAkB0E,aAAa,CAAC1E,GAAvD;AACH,KAFD,MAEO;AACHwE,MAAAA,SAAS,CAACU,SAAV,IAAuBP,WAAW,CAACzE,MAAZ,GAAqBwE,aAAa,CAACxE,MAA1D;AACH;AACJ;AACJ;SAEeuE,uBACZpP;AAEA,QAAM+F,GAAG,GAAG/F,OAAO,CAACiJ,aAApB;;AAEA,MAAIlD,GAAJ,EAAS;AACL,SACI,IAAI+J,EAAE,GAAuB3G,GAAG,CAACG,gBAAJ,CAAqBtJ,OAArB,CADjC,EAEI8P,EAFJ,EAGIA,EAAE,GAAG3G,GAAG,CAACG,gBAAJ,CAAqBwG,EAArB,CAHT,EAIE;AACE,UACIA,EAAE,CAACC,WAAH,GAAiBD,EAAE,CAACtB,WAApB,IACAsB,EAAE,CAACE,YAAH,GAAkBF,EAAE,CAACrB,YAFzB,EAGE;AACE,eAAOqB,EAAP;AACH;AACJ;;AAED,WAAO/J,GAAG,CAACwI,eAAX;AACH;;AAED,SAAO,IAAP;AACH;SAEe0B,iBAAiBjQ;AAC5BA,EAAAA,OAAwC,CAACkQ,mBAAzC,GAA+D,IAA/D;AACJ;SAEeC,kBAAkBnQ;AAC9B,SAAO,CAAC,CAAEA,OAAwC,CAACkQ,mBAAnD;AACH;SAEeE,OAAOC;AACnB,QAAMC,GAAG,GAAG,IAAIC,WAAJ,CAAgB,CAAhB,CAAZ;;AAEA,MAAIF,GAAG,CAACG,MAAJ,IAAcH,GAAG,CAACG,MAAJ,CAAWC,eAA7B,EAA8C;AAC1CJ,IAAAA,GAAG,CAACG,MAAJ,CAAWC,eAAX,CAA2BH,GAA3B;AACH,GAFD,MAEO,IAAID,GAAG,CAACK,QAAJ,IAAgBL,GAAG,CAACK,QAAJ,CAAaD,eAAjC,EAAkD;AACrDJ,IAAAA,GAAG,CAACK,QAAJ,CAAaD,eAAb,CAA6BH,GAA7B;AACH,GAFM,MAEA;AACH,SAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAAG,CAACpN,MAAxB,EAAgCyN,CAAC,EAAjC,EAAqC;AACjCL,MAAAA,GAAG,CAACK,CAAD,CAAH,GAAS,aAAa/B,IAAI,CAACgC,MAAL,EAAtB;AACH;AACJ;;AAED,QAAMC,IAAI,GAAa,EAAvB;;AAEA,OAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,GAAG,CAACpN,MAAxB,EAAgCyN,CAAC,EAAjC,EAAqC;AACjCE,IAAAA,IAAI,CAAC3D,IAAL,CAAUoD,GAAG,CAACK,CAAD,CAAH,CAAOG,QAAP,CAAgB,EAAhB,CAAV;AACH;;AAEDD,EAAAA,IAAI,CAAC3D,IAAL,CAAU,GAAV;AACA2D,EAAAA,IAAI,CAAC3D,IAAL,CAAU,CAAC,EAAEpC,WAAH,EAAgBgG,QAAhB,CAAyB,EAAzB,CAAV;AACAD,EAAAA,IAAI,CAAC3D,IAAL,CAAU,GAAV;AACA2D,EAAAA,IAAI,CAAC3D,IAAL,CAAU6D,IAAI,CAACC,GAAL,GAAWF,QAAX,CAAoB,EAApB,CAAV;AAEA,SAAOD,IAAI,CAACjU,IAAL,CAAU,EAAV,CAAP;AACH;SAEeqU,cACZ7F,WACApL;AAEA,QAAMiN,OAAO,GAAG9B,kBAAkB,CAACC,SAAD,CAAlC;AACA,MAAI8F,GAAG,GAAGlR,OAAO,CAACmR,mBAAlB;;AAEA,MAAI,CAACD,GAAL,EAAU;AACNA,IAAAA,GAAG,GAAGlR,OAAO,CAACmR,mBAAR,GAA8Bf,MAAM,CAAChF,SAAS,EAAV,CAA1C;AACH;;AAED,MACI,CAAC6B,OAAO,CAACzB,YAAR,CAAqB0F,GAArB,CAAD,IACApE,gBAAgB,CAAC9M,OAAO,CAACiJ,aAAT,EAAwBjJ,OAAxB,CAFpB,EAGE;AACEiN,IAAAA,OAAO,CAACzB,YAAR,CAAqB0F,GAArB,IAA4B,IAAInE,eAAJ,CAAoB3B,SAApB,EAA+BpL,OAA/B,CAA5B;AACH;;AAED,SAAOkR,GAAP;AACH;SASeE,aAAa/F;AACzB,MAAI6F,GAAG,GAAG7F,GAAG,CAACgG,6BAAd;;AAEA,MAAI,CAACH,GAAL,EAAU;AACNA,IAAAA,GAAG,GAAG7F,GAAG,CAACgG,6BAAJ,GAAoCjB,MAAM,CAAC/E,GAAD,CAAhD;AACH;;AAED,SAAO6F,GAAP;AACH;SAEeI,kBACZlG,WACA3E;AAEA,QAAMwG,OAAO,GAAG9B,kBAAkB,CAACC,SAAD,CAAlC;;AAEA,OAAK,MAAM3J,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAYsL,OAAO,CAACzB,YAApB,CAAlB,EAAqD;AACjD,UAAM+F,GAAG,GAAGtE,OAAO,CAACzB,YAAR,CAAqB/J,GAArB,CAAZ;AACA,UAAMqO,EAAE,GAAGyB,GAAG,IAAIA,GAAG,CAAClE,GAAJ,EAAlB;;AAEA,QAAIyC,EAAE,IAAIrJ,MAAV,EAAkB;AACd,UAAI,CAAC0C,GAAG,CAACI,YAAJ,CAAiB9C,MAAjB,EAAyBqJ,EAAzB,CAAL,EAAmC;AAC/B;AACH;AACJ;;AAED,WAAO7C,OAAO,CAACzB,YAAR,CAAqB/J,GAArB,CAAP;AACH;AACJ;;SAGeqL,iBACZ/G,KACA/F;AAEA,SAAOmJ,GAAG,CAACI,YAAJ,CAAiBxD,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEyL,IAAtB,EAA4BxR,OAA5B,CAAP;AACH;SAEeyR,gBACZzR,SACA+G;AAOA,QAAM2K,OAAO,GACT1R,OAAO,CAAC0R,OAAR,IACC1R,OAAkC,CAACyR,eADpC,IAECzR,OAAkC,CAAC2R,iBAFpC,IAGA3R,OAAO,CAAC4R,qBAJZ;AAMA,SAAOF,OAAO,IAAIA,OAAO,CAACrK,IAAR,CAAarH,OAAb,EAAsB+G,QAAtB,CAAlB;AACH;SAEe8K,WAAWzG;AACvB,QAAM6B,OAAO,GAAG9B,kBAAkB,CAACC,SAAD,CAAlC;;AACA,MAAI6B,OAAO,CAACxB,MAAR,CAAeC,OAAnB,EAA4B;AACxB,WAAOuB,OAAO,CAACxB,MAAR,CAAeC,OAAtB;AACH;;AAED,QAAM,IAAI1K,KAAJ,CAAU,qBAAV,CAAN;AACH;SAEeyM,WACZR;AAEA,SAAOA,OAAO,CAACxB,MAAR,CAAeE,OAAtB;AACH;AA6BD,IAAImG,kBAAkB,GAAG,CAAzB;MAEsBC;AASlBzN,EAAAA,YAAYvE,SAA4BC,SAAsBgS;AAC1D,UAAM5G,SAAS,GAAGrL,OAAO,CAACqL,SAA1B;AACA,SAAK6G,QAAL,GAAgBlS,OAAhB;AACA,SAAKmS,QAAL,GAAgB,IAAInF,eAAJ,CAAoB3B,SAApB,EAA+BpL,OAA/B,CAAhB;AACA,SAAKmS,MAAL,GAAc,EAAE,GAAGH;AAAL,KAAd;AACA,SAAKxK,EAAL,GAAU,MAAM,EAAEsK,kBAAlB;AACH;;AAEDM,EAAAA,UAAU;AACN,WAAO,KAAKF,QAAL,CAAc7E,GAAd,EAAP;AACH;;AAEDgF,EAAAA,QAAQ;AACJ,WAAO,KAAKF,MAAZ;AACH;;AAEDhQ,EAAAA,QAAQ,CAAC6P,KAAD;AACJ,SAAKG,MAAL,GAAc,EAAE,GAAGH;AAAL,KAAd;AACH;;;AAgBL;;;;MAGaM;AAeThO,EAAAA,YACI8G,WACAmH,WACAP,OACAhS,SACAwS;;;AAgGI,iBAAA,GAAYtR,CAAD;AACf,UAAI,KAAKuR,YAAT,EAAuB;AACnB,cAAMjG,MAAM,GAAG,KAAKiG,YAAL,CAAkBpF,GAAlB,EAAf;;AAEA,YAAIb,MAAJ,EAAY;AACRkG,UAAAA,mBAAW,CAAClG,MAAD,CAAX;AACH;;AAED;AACH;;AAED,YAAMmG,KAAK,GAAG,KAAKA,KAAnB;;AAEA,UAAI,KAAKC,SAAL,IAAkBD,KAAtB,EAA6B;AACzB,cAAME,aAAa,GAAG3R,CAAC,CAAC2R,aAAxB;AAEA,aAAKD,SAAL,CACI,IADJ,EAEI,KAAKE,WAAL,CAAiB,IAAjB,EAAuBH,KAAvB,EAA8BE,aAA9B,CAFJ,EAGIA,aAHJ;AAKH;AACJ,KAtBO;;AAwBA,kBAAA,GAAa3R,CAAD;AAChB,UAAI,KAAKuR,YAAT,EAAuB;AACnB;AACH;;AAED,WAAKM,gBAAL,GAAwB,KAAxB;AAEA,YAAMJ,KAAK,GAAG,KAAKA,KAAnB;;AAEA,UAAI,KAAKK,UAAL,IAAmBL,KAAvB,EAA8B;AAC1B,cAAME,aAAa,GAAG3R,CAAC,CAAC2R,aAAxB;AAEA,aAAKG,UAAL,CACI,IADJ,EAEI,KAAKF,WAAL,CAAiB,KAAjB,EAAwBH,KAAxB,EAA+BE,aAA/B,CAFJ,EAGIA,aAHJ;AAKH;AACJ,KAlBO;;AAtHJ,UAAMxH,GAAG,GAAGD,SAAS,EAArB;AACA,UAAMuH,KAAK,GAAGtH,GAAG,CAACN,QAAJ,CAAakI,aAAb,CAA2B,GAA3B,CAAd;AAEAN,IAAAA,KAAK,CAACO,QAAN,GAAiB,CAAjB;AACAP,IAAAA,KAAK,CAACQ,YAAN,CAAmB,MAAnB,EAA2B,MAA3B;AAEAR,IAAAA,KAAK,CAACQ,YAAN,CAAmB3S,8BAAnB,EAAyD,EAAzD;AACAmS,IAAAA,KAAK,CAACQ,YAAN,CAAmB,aAAnB,EAAkC,MAAlC;AAEA,UAAMC,KAAK,GAAGT,KAAK,CAACS,KAApB;AACAA,IAAAA,KAAK,CAACC,QAAN,GAAiB,OAAjB;AACAD,IAAAA,KAAK,CAAC5I,KAAN,GAAc4I,KAAK,CAAC3I,MAAN,GAAe,KAA7B;AACA2I,IAAAA,KAAK,CAACE,OAAN,GAAgB,OAAhB;AACAF,IAAAA,KAAK,CAACG,MAAN,GAAe,IAAf;AACAH,IAAAA,KAAK,CAACI,WAAN,CAAkB,oBAAlB,EAAwC,QAAxC;AAEAvD,IAAAA,gBAAgB,CAAC0C,KAAD,CAAhB;AAEA,SAAKA,KAAL,GAAaA,KAAb;AACA,SAAKc,OAAL,GAAezB,KAAK,CAACyB,OAArB;AACA,SAAKlB,SAAL,GAAiBA,SAAjB;AACA,SAAKmB,UAAL,GAAkB,MAAA1B,KAAK,CAAC2B,SAAN,UAAA,iBAAA,KAAA,GAAmB,KAArC;AACA,SAAKlB,YAAL,GAAoBD,WAApB;AAEAG,IAAAA,KAAK,CAACiB,gBAAN,CAAuB,SAAvB,EAAkC,KAAKC,QAAvC;AACAlB,IAAAA,KAAK,CAACiB,gBAAN,CAAuB,UAAvB,EAAmC,KAAKE,SAAxC;AAECnB,IAAAA,KAAuC,CAACoB,uBAAxC,GACG/T,OADH;;AAGD,QAAI,KAAK0T,UAAT,EAAqB;AACjB,WAAKM,aAAL,GAAqB3I,GAAG,CAACqC,UAAJ,CAAe;AAChC,eAAO,KAAKsG,aAAZ;AACA,aAAK7T,OAAL;AACH,OAHoB,EAGlB,CAHkB,CAArB;;AAKA,WAAK8T,oBAAL,GAA4B;AACxB,YAAI,KAAKD,aAAT,EAAwB;AACpB3I,UAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAK8H,aAAtB;AACA,iBAAO,KAAKA,aAAZ;AACH;;AAED,eAAO,KAAKC,oBAAZ;AACH,OAPD;AAQH;AACJ;;AAED9T,EAAAA,OAAO;;;AACH,QAAI,KAAK8T,oBAAT,EAA+B;AAC3B,WAAKA,oBAAL;AACH;;AAED,UAAMtB,KAAK,GAAG,KAAKA,KAAnB;;AAEA,QAAI,CAACA,KAAL,EAAY;AACR;AACH;;AAED,WAAO,KAAKF,YAAZ;AACA,WAAO,KAAKG,SAAZ;AACA,WAAO,KAAKI,UAAZ;AACA,WAAO,KAAKL,KAAZ;AAEAA,IAAAA,KAAK,CAACuB,mBAAN,CAA0B,SAA1B,EAAqC,KAAKL,QAA1C;AACAlB,IAAAA,KAAK,CAACuB,mBAAN,CAA0B,UAA1B,EAAsC,KAAKJ,SAA3C;AAEA,WAAQnB,KAAuC,CAACoB,uBAAhD;AAEA,UAAA5K,GAAG,CAACE,aAAJ,CAAkBsJ,KAAlB,CAAA,UAAA,iBAAA,SAAA,MAA0BwB,YAAYxB,MAAtC;AACH;;AAEDyB,EAAAA,UAAU,CAACzJ,GAAD,EAAcD,IAAd;;;AACN,UAAM0I,KAAK,GAAG,MAAA,KAAKT,KAAL,UAAA,iBAAA,SAAA,MAAYS,KAA1B;;AAEA,QAAIA,KAAJ,EAAW;AACPA,MAAAA,KAAK,CAACzI,GAAN,MAAeA,OAAf;AACAyI,MAAAA,KAAK,CAAC1I,IAAN,MAAgBA,QAAhB;AACH;AACJ;;AAEOoI,EAAAA,WAAW,CACfuB,IADe,EAEfC,OAFe,EAGfC,QAHe;AAKf,WAAOF,IAAI,IAAI,CAACE,QAAT,GACD,CAAC,KAAKd,OADL,GAED,CAAC,EACGc,QAAQ,IACRD,OAAO,CAACE,uBAAR,CAAgCD,QAAhC,IACIxG,IAAI,CAAC0G,2BAHZ,CAFP;AAOH;;;AAmDE,MAAMC,2BAA2B,GAAG;AACvCC,EAAAA,IAAI,EAAE,CADiC;AAEvCC,EAAAA,SAAS,EAAE,CAF4B;AAGvCC,EAAAA,KAAK,EAAE,CAHgC;AAIvCC,EAAAA,QAAQ,EAAE;AAJ6B,CAApC;MAOMC;AAMTzQ,EAAAA,YACIvE,SACAC,SACAgV,UACA/S,KACAgT,kBACAC;AAEA,SAAKhD,QAAL,GAAgBlS,OAAhB;AAEA,SAAKmV,SAAL,GAAiB,IAAIC,qBAAJ,CACbrV,OADa,EAEbC,OAFa,EAGb,IAHa,EAIbgV,QAJa,EAKb/S,GALa,EAMbgT,gBANa,EAObC,oBAPa,CAAjB;AASH;;AAESG,EAAAA,YAAY,CAClBzC,SADkB,EAElBI,UAFkB;AAIlB,SAAKsC,UAAL,GAAkB1C,SAAlB;AACA,SAAK2C,WAAL,GAAmBvC,UAAnB;AACH;;AAEDwC,EAAAA,OAAO,CAACC,SAAD;;;AACH,UAAA,KAAKN,SAAL,UAAA,iBAAA,SAAA,MAAgBK,QAAQC,UAAxB;AACH;;AAEDC,EAAAA,wBAAwB,CACpBD,SADoB,EAEpBE,YAFoB;;;AAIpB,UAAA,KAAKR,SAAL,UAAA,iBAAA,SAAA,MAAgBO,yBAAyBD,WAAWE,aAApD;AACH;;AAEDC,EAAAA,UAAU,CAACvB,IAAD;AACN,WAAOA,IAAI,GAAG,KAAKiB,UAAR,GAAqB,KAAKC,WAArC;AACH;;AAEDM,EAAAA,WAAW,CAACC,QAAD;;;AACP,UAAA,KAAKX,SAAL,UAAA,iBAAA,SAAA,MAAgBU,YAAY,MAAMC,SAAlC;AACH;;AAED3V,EAAAA,OAAO;AACH,QAAI,KAAKgV,SAAT,EAAoB;AAChB,WAAKA,SAAL,CAAehV,OAAf,CAAuB,IAAvB;;AACA,aAAO,KAAKgV,SAAZ;AACH;;AAED,WAAO,KAAKG,UAAZ;AACA,WAAO,KAAKC,WAAZ;AACH;;AAE0B,SAApBQ,oBAAoB,CACvBhW,OADuB,EAEvBC,OAFuB;AAGvBgW,EAAAA,gBAHuB;AAIvBC,EAAAA,UAJuB;AAKvBN,EAAAA,YALuB;AAAA;;AAQvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,UAAMO,KAAK,GAAe,IAAI5D,UAAJ,CAAevS,OAAO,CAACqL,SAAvB,EAAkC,IAAlC,EAAwC;AAC9DuI,MAAAA,SAAS,EAAE,IADmD;AAE9DF,MAAAA,OAAO,EAAE;AAFqD,KAAxC,CAA1B;AAKA,UAAMd,KAAK,GAAGuD,KAAK,CAACvD,KAApB;;AAEA,QAAIA,KAAJ,EAAW;AACP,UAAIlM,MAAJ;AACA,UAAIqC,YAAJ,CAFO;AAKP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,UAAI9I,OAAO,CAACmW,OAAR,KAAoB,MAAxB,EAAgC;AAC5B;AACA1P,QAAAA,MAAM,GAAGzG,OAAT;AACA8I,QAAAA,YAAY,GACPkN,gBAAgB,IAAIC,UAArB,IACC,CAACD,gBAAD,IAAqB,CAACC,UADvB,GAEO9M,GAAG,CAACU,oBAAJ,CACG7J,OADH,CAFP,GAKM,IANV;AAOH,OAVD,MAUO;AACH,YACIgW,gBAAgB,KACf,CAACC,UAAD,IACIA,UAAU,IACP,CAAClW,OAAO,CAAC2C,SAAR,CAAkB0T,WAAlB,CACGpW,OADH,EAEG,KAFH,EAGG,IAHH,EAIG,IAJH,CAHO,CADpB,EAUE;AACEyG,UAAAA,MAAM,GAAGzG,OAAT;AACA8I,UAAAA,YAAY,GAAGmN,UAAU,GAClBjW,OAAO,CAACmI,iBADU,GAEnB,IAFN;AAGH,SAfD,MAeO;AACH1B,UAAAA,MAAM,GAAG0C,GAAG,CAACG,gBAAJ,CAAqBtJ,OAArB,CAAT;AACA8I,UAAAA,YAAY,GACPkN,gBAAgB,IAAIC,UAArB,IACC,CAACD,gBAAD,IAAqB,CAACC,UADvB,GAEMjW,OAFN,GAGOmJ,GAAG,CAACY,qBAAJ,CACG/J,OADH,CAJX;AAOH;;AAED,YAAIqW,cAAJ;AACA,YAAIC,QAAJ;;AAEA,WAAG;AACC;AACA;AACA;AACA;AACAD,UAAAA,cAAc,GACTL,gBAAgB,IAAIC,UAArB,IACC,CAACD,gBAAD,IAAqB,CAACC,UADvB,GAEM9M,GAAG,CAACa,yBAAJ,CAA8BlB,YAA9B,CAFN,GAGMA,YAJV;AAOAwN,UAAAA,QAAQ,GAAG,MAAAD,cAAc,SAAd,IAAAA,cAAc,WAAd,SAAA,GAAAA,cAAc,CAAEtC,uBAAhB,UAAA,iBAAA,SAAA,MAAyC1G,KAApD;;AAEA,cAAIiJ,QAAQ,KAAKtW,OAAjB,EAA0B;AACtB8I,YAAAA,YAAY,GACPkN,gBAAgB,IAAIC,UAArB,IACC,CAACD,gBAAD,IAAqB,CAACC,UADvB,GAEMI,cAFN,GAGOlN,GAAG,CAACY,qBAAJ,CACGsM,cADH,CAJX;AAOH,WARD,MAQO;AACHC,YAAAA,QAAQ,GAAGhW,SAAX;AACH;AACJ,SAzBD,QAyBSgW,QAzBT;AA0BH;;AAED,UACI7P,MAAM,SAAN,IAAAA,MAAM,WAAN,SAAA,GAAAA,MAAM,CAAE8P,aAAR,CACI,IAAIxR,qBAAJ,CAA0B;AACtByR,QAAAA,EAAE,EAAE,MADkB;AAEtBC,QAAAA,KAAK,EAAEhQ,MAFe;AAGtBiQ,QAAAA,IAAI,EAAE,IAHgB;AAItBf,QAAAA;AAJsB,OAA1B,CADJ,CADJ,EASE;AACExM,QAAAA,GAAG,CAACL,YAAJ,CAAiBrC,MAAjB,EAAyBkM,KAAzB,EAAgC7J,YAAhC;AACA4J,QAAAA,mBAAW,CAACC,KAAD,CAAX;AACH;AACJ;AACJ;;AAE+B,SAAzBgE,yBAAyB,CAC5B5W,OAD4B,EAE5B6W,aAF4B,EAG5BX,UAH4B,EAI5BY,aAJ4B;AAM5B,UAAMX,KAAK,GAAe,IAAI5D,UAAJ,CACtBvS,OAAO,CAACqL,SADc,EAEtB,IAFsB,EAGtB;AACIuI,MAAAA,SAAS,EAAE,IADf;AAEIF,MAAAA,OAAO,EAAE;AAFb,KAHsB,EAOtBnT,SAPsB,EAQtB,IAAIyM,eAAJ,CAAoBhN,OAAO,CAACqL,SAA5B,EAAuCyL,aAAvC,CARsB,CAA1B;AAWA,UAAMlE,KAAK,GAAGuD,KAAK,CAACvD,KAApB;;AAEA,QAAIA,KAAJ,EAAW;AACP,UAAImE,WAAJ;AACA,UAAIhO,YAAJ;;AAEA,UAAIwD,eAAe,CAACsK,aAAD,CAAf,IAAkC,CAACX,UAAvC,EAAmD;AAC/Ca,QAAAA,WAAW,GAAGF,aAAd;AACA9N,QAAAA,YAAY,GAAGK,GAAG,CAACU,oBAAJ,CACX+M,aADW,CAAf;AAGH,OALD,MAKO;AACHE,QAAAA,WAAW,GAAG3N,GAAG,CAACG,gBAAJ,CAAqBsN,aAArB,CAAd;AACA9N,QAAAA,YAAY,GAAGmN,UAAU,GACnBW,aADmB,GAElBzN,GAAG,CAACY,qBAAJ,CACG6M,aADH,CAFP;AAKH;;AAED,UAAIE,WAAJ,EAAiB;AACb3N,QAAAA,GAAG,CAACL,YAAJ,CAAiBgO,WAAjB,EAA8BnE,KAA9B,EAAqC7J,YAArC;AACH;AACJ;AACJ;;;;AASL,SAASiO,uBAAT,CACIb,KADJ,EAEIc,QAFJ;;;AAII,QAAMC,IAAI,GAA2B;AACjC,OAAG,MAD8B;AAEjC,OAAG,WAF8B;AAGjC,OAAG,OAH8B;AAIjC,OAAG;AAJ8B,GAArC;AAOA,QAAAf,KAAK,CAACvD,KAAN,UAAA,iBAAA,SAAA,MAAaQ,aACT3S,gCACA,YACe0V,KAAK,CAACzC,SADrB,eAEiByC,KAAK,CAAC3D,WAFvB,EAGI,GAAGyE,QAAQ,CAACE,GAAT,CACEC,CAAD,QAAWF,IAAI,CAACE,CAAC,CAACnC,QAAH,eAA0BmC,CAAC,CAACrB,WAD5C,CAHP,EAMElZ,IANF,CAMO,IANP,EAFJ;AAUH;;MAEYwa;AAkBT9S,EAAAA,YAAY+G;AAhBJ,qBAAA,GAOJ,IAAIgM,GAAJ,EAPI;AASA,6BAAA,GAAuB,CAAvB;AACA,wBAAA,GAAiC,IAAIC,OAAJ,EAAjC;AAEA,uBAAA,GAAiD,EAAjD;AACA,wBAAA,GAAoD,IAAIjL,OAAJ,EAApD;;AAkDA,oBAAA,GAAe5F,MAAD;;;AAClB,UAAI,KAAK8Q,eAAL,CAAqBC,GAArB,CAAyB/Q,MAAzB,CAAJ,EAAsC;AAClC;AACH;;AAED,WAAK8Q,eAAL,CAAqBE,GAArB,CAAyBhR,MAAzB;;AAEA,UAAI,KAAKiR,uBAAT,EAAkC;AAC9B;AACH;;AAED,WAAKA,uBAAL,GAA+B,MAAA,KAAKC,IAAL,UAAA,iBAAA,SAAA,iBAAcjK,WAAW;AACpD,eAAO,KAAKgK,uBAAZ;;AAEA,aAAK,MAAM1O,GAAX,IAAkB,KAAK4O,cAAvB,EAAuC;AACnC,gBAAMC,YAAY,GAAG7O,GAAG,CAACqE,GAAJ,EAArB;;AAEA,cAAIwK,YAAJ,EAAkB;AACd,kBAAMjS,QAAQ,GAAG,KAAKkS,eAAL,CAAqBzK,GAArB,CAAyBwK,YAAzB,CAAjB;;AAEA,gBAAIjS,QAAJ,EAAc;AACV,oBAAMkR,WAAW,GAAG3N,GAAG,CAACE,aAAJ,CAAkBwO,YAAlB,CAApB;;AAEA,kBACI,CAACf,WAAD,IACA,KAAKS,eAAL,CAAqBC,GAArB,CAAyBV,WAAzB,CAFJ,EAGE;AACElR,gBAAAA,QAAQ;AACX;AACJ;AACJ;AACJ;;AAED,aAAK2R,eAAL,GAAuB,IAAID,OAAJ,EAAvB;AACH,SAAEpM,0BAvBH;AAwBH,KAnCO;;AA9CJ,SAAKyM,IAAL,GAAYtM,GAAZ;AACH;;AAEDoM,EAAAA,GAAG,CAACvB,KAAD,EAAqBtQ,QAArB;AACC,QAAI,CAAC,KAAKkS,eAAL,CAAqBN,GAArB,CAAyBtB,KAAzB,CAAD,IAAoC,KAAKyB,IAA7C,EAAmD;AAC/C,WAAKC,cAAL,CAAoB1K,IAApB,CAAyB,IAAIH,eAAJ,CAAoB,KAAK4K,IAAzB,EAA+BzB,KAA/B,CAAzB;;AACA,WAAK4B,eAAL,CAAqBC,GAArB,CAAyB7B,KAAzB,EAAgCtQ,QAAhC;;AACA,WAAKoS,UAAL,GAAkB,KAAKC,WAAvB;AACH;AACJ;;AAEDC,EAAAA,MAAM,CAAChC,KAAD;AACF,SAAK0B,cAAL,GAAsB,KAAKA,cAAL,CAAoB3R,MAApB,CAA4B+C,GAAD;AAC7C,YAAMhJ,OAAO,GAAGgJ,GAAG,CAACqE,GAAJ,EAAhB;AACA,aAAOrN,OAAO,IAAIA,OAAO,KAAKkW,KAA9B;AACH,KAHqB,CAAtB;;AAKA,SAAK4B,eAAL,CAAqBK,MAArB,CAA4BjC,KAA5B;;AAEA,QAAI,KAAK0B,cAAL,CAAoB1U,MAApB,KAA+B,CAAnC,EAAsC;AAClC,aAAO,KAAK8U,UAAZ;AACH;AACJ;;AAED7X,EAAAA,OAAO;;;AACH,UAAMkL,GAAG,GAAG,MAAA,KAAKsM,IAAL,UAAA,iBAAA,SAAA,gBAAZ;;AAEA,QAAI,KAAKS,YAAT,EAAuB;AACnB/M,MAAAA,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEa,YAAL,CAAkB,KAAKkM,YAAvB,CAAA;AACA,aAAO,KAAKA,YAAZ;AACH;;AAED,QAAI,KAAKV,uBAAT,EAAkC;AAC9BrM,MAAAA,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEa,YAAL,CAAkB,KAAKwL,uBAAvB,CAAA;AACA,aAAO,KAAKA,uBAAZ;AACH;;AAED,SAAKH,eAAL,GAAuB,IAAID,OAAJ,EAAvB;AACA,SAAKQ,eAAL,GAAuB,IAAIzL,OAAJ,EAAvB;AACA,SAAKuL,cAAL,GAAsB,EAAtB;;AACA,SAAKS,YAAL,CAAkBC,KAAlB;;AAEA,WAAO,KAAKN,UAAZ;AACA,WAAO,KAAKL,IAAZ;AACH;;AAuCDY,EAAAA,eAAe,CACXC,OADW;AAQX,QAAI,CAAC,KAAKb,IAAV,EAAgB;AACZ;AACA;AACA;AACH;;AAED,SAAKU,YAAL,CAAkBZ,GAAlB,CAAsBe,OAAtB;;AAEA,SAAKC,oBAAL,GAA4B1H,IAAI,CAACC,GAAL,EAA5B;;AAEA,SAAK0H,yBAAL;AACH;;AAEOA,EAAAA,yBAAyB;;;AAC7B,QAAI,KAAKN,YAAT,EAAuB;AACnB;AACH;;AAED,SAAKA,YAAL,GAAoB,MAAA,KAAKT,IAAL,UAAA,iBAAA,SAAA,iBAAcjK,WAAW;AACzC,aAAO,KAAK0K,YAAZ;AAGA;AACA;AACA;AACA;AACA;;AACA,UACI,KAAKK,oBAAL,GAA4BvN,yBAA5B,IACA6F,IAAI,CAACC,GAAL,EAFJ,EAGE;AACE;AACA,cAAM2H,kBAAkB,GAAG,IAAIC,GAAJ,EAA3B;AAKA,cAAMC,mBAAmB,GAAmB,EAA5C;;AAEA,aAAK,MAAML,OAAX,IAAsB,KAAKH,YAA3B,EAAyC;AACrCQ,UAAAA,mBAAmB,CAAC3L,IAApB,CAAyBsL,OAAO,CAACG,kBAAD,CAAhC;AACH;;AAED,aAAKN,YAAL,CAAkBC,KAAlB,GAbF;AAgBE;;;AACA,aAAK,MAAMlE,UAAX,IAAyByE,mBAAzB,EAA8C;AAC1CzE,UAAAA,UAAU;AACb,SAnBH;;;AAsBEuE,QAAAA,kBAAkB,CAACL,KAAnB;AACH,OA1BD,MA0BO;AACH,aAAKI,yBAAL;AACH;AACJ,OAAExN,0BAtCH;AAuCH;;;AAGL;;;;AAGA,MAAMkK,qBAAN;AAYI9Q,EAAAA,YACIvE,SACAC,SACA8Y,SACA9D,UACA/S,KACAgT,kBACAC;AAfI,kBAAA,GAAiC,EAAjC;AAEA,mBAAA,GAAa,KAAb;AAGA,2BAAA,GAAuC,IAAImC,GAAJ,EAAvC;;AAuJA,mBAAA,GAAa,CACjB0B,UADiB,EAEjB9C,UAFiB,EAGjBpD,aAHiB;AAKjB,WAAKmG,QAAL,CAAc,IAAd,EAAoBD,UAApB,EAAgC9C,UAAhC,EAA4CpD,aAA5C;AACH,KANO;;AAQA,oBAAA,GAAc,CAClBkG,UADkB,EAElB9C,UAFkB,EAGlBpD,aAHkB;AAKlB,WAAKmG,QAAL,CAAc,KAAd,EAAqBD,UAArB,EAAiC9C,UAAjC,EAA6CpD,aAA7C;AACH,KANO;;AAQR,gBAAA,GAAW4C,SAAD;;;AACN,YAAMwD,KAAK,GAAG,KAAKC,WAAnB;AACA,YAAMC,IAAI,GAAG,KAAKC,UAAlB;;AAEA,UAAIH,KAAK,IAAIE,IAAb,EAAmB;AACf;AACA;AACA;AACA,aAAKE,eAAL;;AAEA,cAAMC,UAAU,GAAGL,KAAK,CAACtG,KAAzB;AACA,cAAM4G,SAAS,GAAGJ,IAAI,CAACxG,KAAvB;AACA,cAAM3S,OAAO,GAAG,MAAA,KAAKkS,QAAL,UAAA,iBAAA,SAAA,MAAe7E,KAA/B;;AAEA,YAAIiM,UAAU,IAAIC,SAAd,IAA2BvZ,OAA/B,EAAwC;AACpC,cAAIwZ,OAAJ;;AAEA,cAAI/D,SAAJ,EAAe;AACX6D,YAAAA,UAAU,CAACpG,QAAX,GAAsB,CAAtB;AACAsG,YAAAA,OAAO,GAAGF,UAAV;AACH,WAHD,MAGO;AACHC,YAAAA,SAAS,CAACrG,QAAV,GAAqB,CAArB;AACAsG,YAAAA,OAAO,GAAGD,SAAV;AACH;;AAED,cAAIC,OAAJ,EAAa;AACT9G,YAAAA,mBAAW,CAAC8G,OAAD,CAAX;AACH;AACJ;AACJ;AACJ,KA9BD;AAgCA;;;;;;;AAKA,iCAAA,GAA2B,CACvB/D,SADuB,EAEvBE,YAFuB;;;AAIvB,YAAMsD,KAAK,GAAG,KAAKC,WAAnB;AACA,YAAMC,IAAI,GAAG,KAAKC,UAAlB;;AAEA,UAAIH,KAAK,IAAIE,IAAb,EAAmB;AACf;AACA;AACA;AACA,aAAKE,eAAL;;AAEA,cAAMC,UAAU,GAAGL,KAAK,CAACtG,KAAzB;AACA,cAAM4G,SAAS,GAAGJ,IAAI,CAACxG,KAAvB;AACA,cAAM3S,OAAO,GAAG,MAAA,KAAKkS,QAAL,UAAA,iBAAA,SAAA,MAAe7E,KAA/B;;AAEA,YAAIiM,UAAU,IAAIC,SAAd,IAA2BvZ,OAA/B,EAAwC;AACpC,cAAIwZ,OAAJ;;AAEA,cAAI/D,SAAJ,EAAe;AACX,gBACI,CAACwD,KAAK,CAAC1G,SAAP,IACA,KAAKN,QAAL,CAAcvP,SAAd,CAAwB0T,WAAxB,CACIpW,OADJ,EAEI,IAFJ,EAGI,IAHJ,EAII,IAJJ,CAFJ,EAQE;AACEwZ,cAAAA,OAAO,GAAGxZ,OAAV;AACH,aAVD,MAUO;AACHiZ,cAAAA,KAAK,CAAClG,gBAAN,GAAyB,IAAzB;AACAuG,cAAAA,UAAU,CAACpG,QAAX,GAAsB,CAAtB;AACAsG,cAAAA,OAAO,GAAGF,UAAV;AACH;AACJ,WAhBD,MAgBO;AACHH,YAAAA,IAAI,CAACpG,gBAAL,GAAwB,IAAxB;AACAwG,YAAAA,SAAS,CAACrG,QAAV,GAAqB,CAArB;AACAsG,YAAAA,OAAO,GAAGD,SAAV;AACH;;AAED,cACIC,OAAO,IACPxZ,OAAO,CAACuW,aAAR,CACI,IAAIxR,qBAAJ,CAA0B;AACtByR,YAAAA,EAAE,EAAE,MADkB;AAEtBC,YAAAA,KAAK,EAAEzW,OAFe;AAGtB0W,YAAAA,IAAI,EAAE,IAHgB;AAItBf,YAAAA;AAJsB,WAA1B,CADJ,CAFJ,EAUE;AACEjD,YAAAA,mBAAW,CAAC8G,OAAD,CAAX;AACH;AACJ;AACJ;AACJ,KAzDD;;AA2DA,oBAAA,GAAc,CAACV,OAAD,EAA6BhD,QAA7B;;;AACV,WAAK,MAAMqB,CAAX,IAAgB,KAAKsC,SAArB,EAAgC;AAC5B,YAAItC,CAAC,CAAC2B,OAAF,KAAcA,OAAlB,EAA2B;AACvB3B,UAAAA,CAAC,CAACrB,QAAF,GAAaA,QAAb;AACA;AACH;AACJ;;AAED,YAAM4D,OAAO,GAAG,KAAKC,WAAL,EAAhB;;AAEA,UAAID,OAAJ,EAAa;AACT,cAAMxG,QAAQ,GAAGwG,OAAO,CAAC5D,QAAR,GAAmB,CAAnB,GAAuB,CAAC,CAAzC;AAEA,YAAInD,KAAK,GAAG,MAAA,KAAKuG,WAAL,UAAA,iBAAA,SAAA,MAAkBvG,KAA9B;;AAEA,YAAIA,KAAJ,EAAW;AACPA,UAAAA,KAAK,CAACO,QAAN,GAAiBA,QAAjB;AACH;;AAEDP,QAAAA,KAAK,GAAG,MAAA,KAAKyG,UAAL,UAAA,iBAAA,SAAA,MAAiBzG,KAAzB;;AAEA,YAAIA,KAAJ,EAAW;AACPA,UAAAA,KAAK,CAACO,QAAN,GAAiBA,QAAjB;AACH;AACJ;;AAED,UAAI/R,sCAAJ,EAAa;AACT,aAAK+X,WAAL,IACInC,uBAAuB,CAAC,KAAKmC,WAAN,EAAmB,KAAKO,SAAxB,CAD3B;AAEA,aAAKL,UAAL,IACIrC,uBAAuB,CAAC,KAAKqC,UAAN,EAAkB,KAAKK,SAAvB,CAD3B;AAEH;AACJ,KAhCD;AA8CA;;;;;;AAIQ,wBAAA,GAAkB;AACtB,UAAI,KAAKG,SAAT,EAAoB;AAChB;AACH;;AAED,WAAKA,SAAL,GAAiB,KAAKC,UAAL,GAAkBnM,UAAlB,CAA6B;AAC1C,eAAO,KAAKkM,SAAZ;;AAEA,aAAKP,eAAL;;AAEA,YAAIlY,sCAAJ,EAAa;AACT,eAAK+X,WAAL,IACInC,uBAAuB,CAAC,KAAKmC,WAAN,EAAmB,KAAKO,SAAxB,CAD3B;AAEA,eAAKL,UAAL,IACIrC,uBAAuB,CAAC,KAAKqC,UAAN,EAAkB,KAAKK,SAAvB,CAD3B;AAEH;;AAED,aAAKK,oBAAL;AACH,OAbgB,EAad,CAbc,CAAjB;AAcH,KAnBO;;AAuEA,6BAAA,GAAuB;AAC3B,WAAK7H,QAAL,CAAc8H,cAAd,CAA6BxB,eAA7B,CACI,KAAKyB,wBADT;AAGH,KAJO;;AAMA,iCAAA,GACJrB,kBAD+B;;;AAM/B,YAAMsB,IAAI,GAAG,CAAA,MAAA,KAAKf,WAAL,UAAA,iBAAA,SAAA,MAAkBvG,KAAlB,MAA2B,MAAA,KAAKyG,UAAL,UAAA,iBAAA,SAAA,MAAiBzG,KAA5C,CAAb;AACA,YAAMuH,iBAAiB,GAAG,KAAKC,kBAA/B;AACA,YAAMC,oBAAoB,GAA6B,IAAI/C,GAAJ,EAAvD;AACA,UAAIxH,SAAS,GAAG,CAAhB;AACA,UAAIwK,UAAU,GAAG,CAAjB;;AAEA,YAAMhP,GAAG,GAAG,KAAKwO,UAAL,EAAZ;;AAEA,WACI,IAAI7Z,OAAO,GAAmCia,IADlD,EAEIja,OAAO,IAAIA,OAAO,CAAC8N,QAAR,KAAqBC,IAAI,CAACC,YAFzC,EAGIhO,OAAO,GAAGmJ,GAAG,CAACG,gBAAJ,CAAqBtJ,OAArB,CAHd,EAIE;AACE,YAAIsa,aAAa,GAAG3B,kBAAkB,CAACtL,GAAnB,CAAuBrN,OAAvB,CAApB,CADF;AAIE;;AACA,YAAIsa,aAAa,KAAKha,SAAtB,EAAiC;AAC7B,gBAAMia,SAAS,GAAGlP,GAAG,CAACmP,gBAAJ,CAAqBxa,OAArB,EAA8Bua,SAAhD;;AAEA,cAAIA,SAAS,IAAIA,SAAS,KAAK,MAA/B,EAAuC;AACnCD,YAAAA,aAAa,GAAG;AACZzK,cAAAA,SAAS,EAAE7P,OAAO,CAAC6P,SADP;AAEZwK,cAAAA,UAAU,EAAEra,OAAO,CAACqa;AAFR,aAAhB;AAIH;;AAED1B,UAAAA,kBAAkB,CAACZ,GAAnB,CAAuB/X,OAAvB,EAAgCsa,aAAa,IAAI,IAAjD;AACH;;AAED,YAAIA,aAAJ,EAAmB;AACfF,UAAAA,oBAAoB,CAAC3C,GAArB,CAAyBzX,OAAzB;;AAEA,cAAI,CAACka,iBAAiB,CAAC1C,GAAlB,CAAsBxX,OAAtB,CAAL,EAAqC;AACjCA,YAAAA,OAAO,CAAC4T,gBAAR,CACI,QADJ,EAEI,KAAKkG,oBAFT;AAIH;;AAEDjK,UAAAA,SAAS,IAAIyK,aAAa,CAACzK,SAA3B;AACAwK,UAAAA,UAAU,IAAIC,aAAa,CAACD,UAA5B;AACH;AACJ;;AAED,WAAK,MAAMvK,EAAX,IAAiBoK,iBAAjB,EAAoC;AAChC,YAAI,CAACE,oBAAoB,CAAC5C,GAArB,CAAyB1H,EAAzB,CAAL,EAAmC;AAC/BA,UAAAA,EAAE,CAACoE,mBAAH,CAAuB,QAAvB,EAAiC,KAAK4F,oBAAtC;AACH;AACJ;;AAED,WAAKK,kBAAL,GAA0BC,oBAA1B;AAEA,aAAO;;;AACH,cAAA,KAAKlB,WAAL,UAAA,iBAAA,SAAA,MAAkB9E,WAAWvE,WAAWwK,WAAxC;AACA,cAAA,KAAKjB,UAAL,UAAA,iBAAA,SAAA,MAAiBhF,WAAWvE,WAAWwK,WAAvC;AACH,OAHD;AAIH,KA/DO;;AA1XJ,UAAMvK,EAAE,GAAG9P,OAAO,CAACqN,GAAR,EAAX;;AAEA,QAAI,CAACyC,EAAL,EAAS;AACL,YAAM,IAAI9O,KAAJ,CAAU,YAAV,CAAN;AACH;;AAED,SAAKiR,QAAL,GAAgBlS,OAAhB;AACA,SAAK8Z,UAAL,GAAkB9Z,OAAO,CAACqL,SAA1B;AACA,SAAKqP,qBAAL,GAA6BvF,oBAA7B;AAEA,UAAMwF,QAAQ,GAAG5K,EAAE,CAAC6K,cAApB;;AAEA,KAACD,QAAQ,IAAI,IAAb,EAAmBjB,SAAnB,CAA6BvM,IAA7B,CAAkC;AAC9B4L,MAAAA,OAD8B;AAE9B9D,MAAAA,QAF8B;AAG9Bc,MAAAA,QAAQ,EAAE;AAHoB,KAAlC;;AAMA,QAAI4E,QAAJ,EAAc;AACV,UAAIvZ,sCAAJ,EAAa;AACT,aAAK+X,WAAL,IACInC,uBAAuB,CACnB,KAAKmC,WADc,EAEnBwB,QAAQ,CAACjB,SAFU,CAD3B;AAKA,aAAKL,UAAL,IACIrC,uBAAuB,CACnB,KAAKqC,UADc,EAEnBsB,QAAQ,CAACjB,SAFU,CAD3B;AAKH;;AAED,aAAOiB,QAAP;AACH;;AAED5K,IAAAA,EAAE,CAAC6K,cAAH,GAAoB,IAApB;AAGA;;AACA,UAAMC,mBAAmB,GAAG3Y,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAE4Y,mBAAjC;AACA,UAAM1E,OAAO,GAAGrG,EAAE,CAACqG,OAAnB;AACA,SAAK2E,UAAL,GAAkB,CAACF,mBAAD,GACZ,CAAC3F,gBAAgB,IACbkB,OAAO,KAAK,IADf,IAEGA,OAAO,KAAK,IAFf,IAGGA,OAAO,KAAK,OAHhB,KAIA,EAAEA,OAAO,KAAK,IAAZ,IAAoBA,OAAO,KAAK,IAAhC,IAAwCA,OAAO,KAAK,IAAtD,CALY,GAMZyE,mBAAmB,KAAKpa,uBAAA,CAA8BX,OAN5D;AAQA,SAAKqZ,WAAL,GAAmB,IAAI5G,UAAJ,CACf,KAAKuH,UADU,EAEf,KAAKiB,UAFU,EAGf;AACIrH,MAAAA,OAAO,EAAE;AADb,KAHe,EAMfzT,OANe,CAAnB;AASA,SAAKoZ,UAAL,GAAkB,IAAI9G,UAAJ,CACd,KAAKuH,UADS,EAEd,KAAKiB,UAFS,EAGd;AACIrH,MAAAA,OAAO,EAAE;AADb,KAHc,EAMdzT,OANc,CAAlB;AAUA;AACA;;AACA,UAAM6X,YAAY,GAAG,KAAKqB,WAAL,CAAiBvG,KAAtC;AACAkF,IAAAA,YAAY,IACR9X,OAAO,CAACga,cAAR,CAAuBtC,GAAvB,CAA2BI,YAA3B,EAAyC,KAAKkD,eAA9C,CADJ;AAGA,SAAK7B,WAAL,CAAiBtG,SAAjB,GAA6B,KAAK0C,UAAlC;AACA,SAAK4D,WAAL,CAAiBlG,UAAjB,GAA8B,KAAKuC,WAAnC;AACA,SAAK6D,UAAL,CAAgBxG,SAAhB,GAA4B,KAAK0C,UAAjC;AACA,SAAK8D,UAAL,CAAgBpG,UAAhB,GAA6B,KAAKuC,WAAlC;AAEA,SAAKrD,QAAL,GAAgBlS,OAAhB;;AACA,SAAK+a,eAAL;AACH;;AAED5a,EAAAA,OAAO,CAAC2Y,OAAD,EAA6BkC,KAA7B;;;AACH,UAAMhE,QAAQ,GAAI,KAAKyC,SAAL,GAAiB,KAAKA,SAAL,CAAexT,MAAf,CAC9BkR,CAAD,IAAOA,CAAC,CAAC2B,OAAF,KAAcA,OAAd,IAAyB,CAACkC,KADF,CAAnC;;AAIA,QAAI7Z,sCAAJ,EAAa;AACT,WAAK+X,WAAL,IACInC,uBAAuB,CAAC,KAAKmC,WAAN,EAAmBlC,QAAnB,CAD3B;AAEA,WAAKoC,UAAL,IACIrC,uBAAuB,CAAC,KAAKqC,UAAN,EAAkBpC,QAAlB,CAD3B;AAEH;;AAED,QAAIA,QAAQ,CAAC9T,MAAT,KAAoB,CAAxB,EAA2B;AACvB,aAAO,CAAC,MAAA,KAAKgP,QAAL,UAAA,iBAAA,SAAA,MAAe7E,KAAhB,EACFsN,cADL;;AAGA,WAAK,MAAM7K,EAAX,IAAiB,KAAKqK,kBAAtB,EAA0C;AACtCrK,QAAAA,EAAE,CAACoE,mBAAH,CAAuB,QAAvB,EAAiC,KAAK4F,oBAAtC;AACH;;AACD,WAAKK,kBAAL,CAAwB7B,KAAxB;;AAEA,YAAMjN,GAAG,GAAG,KAAKwO,UAAL,EAAZ;;AAEA,UAAI,KAAKD,SAAT,EAAoB;AAChBvO,QAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAK0N,SAAtB;AACA,eAAO,KAAKA,SAAZ;AACH;;AAED,YAAM/B,YAAY,GAAG,MAAA,KAAKqB,WAAL,UAAA,iBAAA,SAAA,MAAkBvG,KAAvC;AACAkF,MAAAA,YAAY,IAAI,KAAK5F,QAAL,CAAc8H,cAAd,CAA6B7B,MAA7B,CAAoCL,YAApC,CAAhB;AAEA,YAAA,KAAKqB,WAAL,UAAA,iBAAA,SAAA,MAAkB/Y,SAAlB;AACA,YAAA,KAAKiZ,UAAL,UAAA,iBAAA,SAAA,MAAiBjZ,SAAjB;AACH;AACJ;;AAEO6Y,EAAAA,QAAQ,CACZ3E,IADY,EAEZ0E,UAFY,EAGZ9C,UAHY,EAIZpD,aAJY;;;AAMZ,UAAM6G,OAAO,GAAG,KAAKC,WAAL,EAAhB;;AAEA,QACID,OAAO,KACN,CAACX,UAAU,CAAChG,gBAAZ,IAAgC,KAAK0H,qBAD/B,CADX,EAGE;AACE,YAAAf,OAAO,CAACZ,OAAR,CAAgBlD,UAAhB,CAA2BvB,IAA3B,CAAA,UAAA,iBAAA,SAAA,MACI0E,YACA9C,YACApD,cAHJ;AAKH;AACJ;;AAoJO8G,EAAAA,WAAW;AACf,SAAKF,SAAL,CAAewB,IAAf,CAAoB,CAACC,CAAD,EAAIC,CAAJ;AAChB,UAAID,CAAC,CAACpF,QAAF,KAAeqF,CAAC,CAACrF,QAArB,EAA+B;AAC3B,eAAOoF,CAAC,CAACpF,QAAF,GAAa,CAAC,CAAd,GAAkB,CAAzB;AACH;;AAED,aAAOoF,CAAC,CAAClG,QAAF,GAAamG,CAAC,CAACnG,QAAtB;AACH,KAND;;AAQA,WAAO,KAAKyE,SAAL,CAAe,CAAf,CAAP;AACH;;AA2BOJ,EAAAA,eAAe;;;AACnB,UAAMrZ,OAAO,GAAG,MAAA,KAAKkS,QAAL,UAAA,iBAAA,SAAA,MAAe7E,KAA/B;AACA,UAAM+N,eAAe,GAAG,MAAA,KAAKlC,WAAL,UAAA,iBAAA,SAAA,MAAkBvG,KAA1C;AACA,UAAM0I,cAAc,GAAG,MAAA,KAAKjC,UAAL,UAAA,iBAAA,SAAA,MAAiBzG,KAAxC;;AAEA,QAAI,CAAC3S,OAAD,IAAY,CAACob,eAAb,IAAgC,CAACC,cAArC,EAAqD;AACjD;AACH;;AAED,QAAI,KAAKP,UAAT,EAAqB;AACjB,YAAMQ,aAAa,GAAGnS,GAAG,CAACE,aAAJ,CAAkBrJ,OAAlB,CAAtB;;AAEA,UAAIsb,aAAJ,EAAmB;AACf,cAAMvT,WAAW,GAAGoB,GAAG,CAACQ,cAAJ,CAAmB3J,OAAnB,CAApB;;AAEA,YAAI+H,WAAW,KAAKsT,cAApB,EAAoC;AAChClS,UAAAA,GAAG,CAACL,YAAJ,CACIwS,aADJ,EAEID,cAFJ,EAGItT,WAHJ;AAKH;;AAED,YACIoB,GAAG,CAACa,yBAAJ,CAA8BhK,OAA9B,MAA2Cob,eAD/C,EAEE;AACEjS,UAAAA,GAAG,CAACL,YAAJ,CAAiBwS,aAAjB,EAAgCF,eAAhC,EAAiDpb,OAAjD;AACH;AACJ;AACJ,KApBD,MAoBO;AACH,UAAImJ,GAAG,CAACW,mBAAJ,CAAwB9J,OAAxB,MAAqCqb,cAAzC,EAAyD;AACrDlS,QAAAA,GAAG,CAACR,WAAJ,CAAgB3I,OAAhB,EAAyBqb,cAAzB;AACH;;AAED,YAAMlT,iBAAiB,GAAGgB,GAAG,CAACU,oBAAJ,CAAyB7J,OAAzB,CAA1B;;AAEA,UACImI,iBAAiB,IACjBA,iBAAiB,KAAKiT,eADtB,IAEAjT,iBAAiB,CAAC9B,UAHtB,EAIE;AACE8C,QAAAA,GAAG,CAACL,YAAJ,CACIX,iBAAiB,CAAC9B,UADtB,EAEI+U,eAFJ,EAGIjT,iBAHJ;AAKH;AACJ;AACJ;;;;SA0EWuB,eAAayF;AACzB,MAAItH,SAAS,GAAuB,IAApC;;AAEA,OACI,IAAI8I,CAAC,GAAGxH,GAAG,CAACW,mBAAJ,CAAwBqF,SAAxB,CADZ,EAEIwB,CAFJ,EAGIA,CAAC,GAAGxH,GAAG,CAACW,mBAAJ,CAAwB6G,CAAxB,CAHR,EAIE;AACE9I,IAAAA,SAAS,GAAG8I,CAAZ;AACH;;AAED,SAAO9I,SAAS,IAAIvH,SAApB;AACH;SAEeib,mBACZtB,MACAuB;AAEA,MAAIC,GAAG,GAAuBxB,IAA9B;AACA,MAAIyB,QAAQ,GAAuB,IAAnC;;AAEA,SAAOD,GAAG,IAAI,CAACC,QAAf,EAAyB;AACrBA,IAAAA,QAAQ,GACJF,IAAI,GACErS,GAAG,CAACa,yBAAJ,CAA8ByR,GAA9B,CADF,GAEEtS,GAAG,CAACY,qBAAJ,CAA0B0R,GAA1B,CAHV;AAKAA,IAAAA,GAAG,GAAGtS,GAAG,CAACG,gBAAJ,CAAqBmS,GAArB,CAAN;AACH;;AAED,SAAOC,QAAQ,IAAIpb,SAAnB;AACH;SAEeqb,iBACZ5b,SACAC,SACA4b,MACAC;;AAEA;AACA,QAAMpb,KAAK,GAAGV,OAAO,CAACE,YAAR,CAAqBD,OAArB,EAA8B,IAA9B,CAAd;AACA,MAAI8b,GAAG,GAAG,KAAV;;AAEA,MAAI,CAACrb,KAAK,CAACsb,GAAX,EAAgB;AACZ,QAAIF,KAAK,KAAKvb,SAAd,EAAyB;AACrB,aAAOwb,GAAP;AACH;;AAEDrb,IAAAA,KAAK,CAACsb,GAAN,GAAY,EAAZ;AACH;;AAED,MAAIF,KAAK,KAAKvb,SAAd,EAAyB;AACrB,QAAIsb,IAAI,IAAInb,KAAK,CAACsb,GAAlB,EAAuB;AACnB,YAAMC,OAAO,GAAGvb,KAAK,CAACsb,GAAN,CAAUH,IAAV,CAAhB;AAEA,aAAOnb,KAAK,CAACsb,GAAN,CAAUH,IAAV,CAAP;;AAEA,UAAII,OAAO,KAAK,IAAhB,EAAsB;AAClBhc,QAAAA,OAAO,CAACic,eAAR,CAAwBL,IAAxB;AACH,OAFD,MAEO;AACH5b,QAAAA,OAAO,CAACmT,YAAR,CAAqByI,IAArB,EAA2BI,OAA3B;AACH;;AAEDF,MAAAA,GAAG,GAAG,IAAN;AACH;AACJ,GAdD,MAcO;AACH,QAAII,SAAJ;;AAEA,QAAI,EAAEN,IAAI,IAAInb,KAAK,CAACsb,GAAhB,CAAJ,EAA0B;AACtBG,MAAAA,SAAS,GAAGlc,OAAO,CAACO,YAAR,CAAqBqb,IAArB,CAAZ;AACH;;AAED,QAAIM,SAAS,KAAK5b,SAAd,IAA2B4b,SAAS,KAAKL,KAA7C,EAAoD;AAChDpb,MAAAA,KAAK,CAACsb,GAAN,CAAUH,IAAV,IAAkBM,SAAlB;;AAEA,UAAIL,KAAK,KAAK,IAAd,EAAoB;AAChB7b,QAAAA,OAAO,CAACic,eAAR,CAAwBL,IAAxB;AACH,OAFD,MAEO;AACH5b,QAAAA,OAAO,CAACmT,YAAR,CAAqByI,IAArB,EAA2BC,KAA3B;AACH;;AAEDC,MAAAA,GAAG,GAAG,IAAN;AACH;AACJ;;AAED,MAAID,KAAK,KAAKvb,SAAV,IAAuBoB,MAAM,CAACC,IAAP,CAAYlB,KAAK,CAACsb,GAAlB,EAAuB7Y,MAAvB,KAAkC,CAA7D,EAAgE;AAC5D,WAAOzC,KAAK,CAACsb,GAAb;AACAhc,IAAAA,OAAO,CAACE,YAAR,CAAqBD,OAArB,EAA8B,KAA9B;AACH;;AAED,SAAO8b,GAAP;AACH;SAuBeK,cAAcnc;;;AAC1B,QAAMoc,eAAe,GAAGpc,OAAO,CAACiJ,aAAhC;AACA,QAAMoT,aAAa,GACf,MAAAD,eAAe,CAACE,WAAhB,UAAA,iBAAA,SAAA,MAA6B9B,iBAAiBxa,QADlD;;AAIA,MACIA,OAAO,CAACuc,YAAR,KAAyB,IAAzB,IACAH,eAAe,CAAC5K,IAAhB,KAAyBxR,OADzB,IAEA,CAAAqc,aAAa,SAAb,IAAAA,aAAa,WAAb,SAAA,GAAAA,aAAa,CAAEhJ,QAAf,MAA4B,OAHhC,EAIE;AACE,WAAO,IAAP;AACH;AAGD;;;AACA,MAAI,CAAAgJ,aAAa,SAAb,IAAAA,aAAa,WAAb,SAAA,GAAAA,aAAa,CAAEG,UAAf,MAA8B,QAAlC,EAA4C;AACxC,WAAO,IAAP;AACH;AAGD;;;AACA,MAAI,CAAAH,aAAa,SAAb,IAAAA,aAAa,WAAb,SAAA,GAAAA,aAAa,CAAEhJ,QAAf,MAA4B,OAAhC,EAAyC;AACrC,QAAIgJ,aAAa,CAACI,OAAd,KAA0B,MAA9B,EAAsC;AAClC,aAAO,IAAP;AACH;;AAED,QACI,CAAA,MAAAzc,OAAO,CAACuG,aAAR,UAAA,iBAAA,SAAA,MAAuBgW,YAAvB,MAAwC,IAAxC,IACAH,eAAe,CAAC5K,IAAhB,KAAyBxR,OAAO,CAACuG,aAFrC,EAGE;AACE,aAAO,IAAP;AACH;AACJ;;AAED,SAAO,KAAP;AACH;;ACt4DD;;;;SAcgBmW,oBACZ1K,OACA2K;AAEA,QAAMhc,IAAI,GAAGG,IAAI,CAAC8b,SAAL,CAAe5K,KAAf,CAAb;;AAEA,MAAI2K,KAAK,KAAK,IAAd,EAAoB;AAChB,WAAOhc,IAAP;AACH;;AAED,SAAO;AACH,KAACH,oBAAD,GAA8BG;AAD3B,GAAP;AAGH;AAED;;;;;;;;;SAQgBkc,kBACZ7K,OACA8K;AAEA,OAAK,MAAMrb,GAAX,IAAkBC,MAAM,CAACC,IAAP,CACdmb,QADc,CAAlB,EAE4C;AACxC,UAAMjB,KAAK,GAAGiB,QAAQ,CAACrb,GAAD,CAAtB;;AAEA,QAAIoa,KAAJ,EAAW;AACP;AACA7J,MAAAA,KAAK,CAACvQ,GAAD,CAAL,GAAaoa,KAAb;AACH,KAHD,MAGO;AACH,aAAO7J,KAAK,CAACvQ,GAAD,CAAZ;AACH;AACJ;AACJ;AAED;;;;;;;;;SAQgBsb,oBACZ/c,SACA8c,UACAE;AAEA,MAAIhL,KAAJ;;AAEA,MAAIgL,MAAJ,EAAY;AACR,UAAMrc,IAAI,GAAGX,OAAO,CAACO,YAAR,CAAqBC,oBAArB,CAAb;;AAEA,QAAIG,IAAJ,EAAU;AACN,UAAI;AACAqR,QAAAA,KAAK,GAAGlR,IAAI,CAACC,KAAL,CAAWJ,IAAX,CAAR;AACH,OAFD,CAEE,OAAOO,CAAP,EAAU;AACR,YAAIC,sCAAJ,EAAa;AACTC,UAAAA,OAAO,CAACC,KAAR,kCACqCH,GADrC,EAEIlB,OAFJ;AAIH;AACJ;AACJ;AACJ;;AAED,MAAI,CAACgS,KAAL,EAAY;AACRA,IAAAA,KAAK,GAAG,EAAR;AACH;;AAED6K,EAAAA,iBAAiB,CAAC7K,KAAD,EAAQ8K,QAAR,CAAjB;;AAEA,MAAIpb,MAAM,CAACC,IAAP,CAAYqQ,KAAZ,EAAmB9O,MAAnB,GAA4B,CAAhC,EAAmC;AAC/BlD,IAAAA,OAAO,CAACmT,YAAR,CACI3S,oBADJ,EAEIkc,mBAAmB,CAAC1K,KAAD,EAAQ,IAAR,CAFvB;AAIH,GALD,MAKO;AACHhS,IAAAA,OAAO,CAACic,eAAR,CAAwBzb,oBAAxB;AACH;AACJ;;ACrGD;;;;;AAuBA,SAASyc,sBAAT,CACIC,WADJ,EAEIhF,MAFJ,EAGI1Q,EAHJ;AAKI,MAAIrG,sCAAJ,EAAa;AACT,UAAMnB,OAAO,GAAGkd,WAAW,CAAC7P,GAAZ,EAAhB;;AAEA,QAAIrN,OAAJ,EAAa;AACT,UAAIkY,MAAJ,EAAY;AACRlY,QAAAA,OAAO,CAACoT,KAAR,CAAc+J,cAAd,CAA6B,gBAA7B;AACH,OAFD,MAEO;AACHnd,QAAAA,OAAO,CAACoT,KAAR,CAAcI,WAAd,CAA0B,gBAA1B,EAA4ChM,EAAE,GAAG,GAAjD;AACH;AACJ;AACJ;AACJ;;AAED,MAAM4V,gBAAN,SAA+BrI,iBAA/B;AAIIzQ,EAAAA,YACIvE,SACAC,SACAqd,YACApb;AAEA,UACIlC,OADJ,EAEIC,OAFJ,EAGI0U,2BAA2B,CAACC,IAHhC,EAII1S,GAJJ,EAKI3B,SALJ,EAMI,IANJ;;AAeI,2BAAA,GAAsByY,UAAD;;;AACzB,UAAIA,UAAU,CAAChG,gBAAf,EAAiC;AAC7B;AACA;AACA;AACA;AACA,aAAKuK,WAAL,CAAiB,KAAjB;AACH,OAND,MAMO;AACH;AACA,aAAKrL,QAAL,CAAcsL,kBAAd,CAAiCC,yBAAjC,CAA2D,IAA3D;;AAEA,cAAMxd,OAAO,GAAG,KAAKkS,QAAL,CAAc7E,GAAd,EAAhB;;AAEA,YAAIrN,OAAJ,EAAa;AACT,eAAKsd,WAAL,CAAiB,IAAjB;;AAEA,gBAAM9D,OAAO,GACT,KAAKvH,QAAL,CAAcwL,cAAd,CAA6BC,sBAA7B,CACI3E,UAAU,CAACtF,OADf,EAEI;AAAEtE,YAAAA,SAAS,EAAEnP,OAAb;AAAsB2d,YAAAA,mBAAmB,EAAE;AAA3C,WAFJ,CADJ;;AAMA,cAAInE,OAAJ,EAAa;AACT9G,YAAAA,mBAAW,CAAC8G,OAAD,CAAX;AACA;AACH;AACJ;;AAED,cAAAT,UAAU,CAACpG,KAAX,UAAA,iBAAA,SAAA,MAAkBiL,MAAlB;AACH;AACJ,KA9BO;;AANJ,SAAKvI,YAAL,CAAkB,KAAKwI,kBAAvB;;AAEA,SAAK5L,QAAL,GAAgBlS,OAAhB;AACA,SAAKud,WAAL,GAAmBD,UAAnB;AACH;;;;MAmCQ1I,aACD5C;AAWRzN,EAAAA,YACIvE,SACAC,SACA8d,WACA9L,OACA/P;AAEA,UAAMlC,OAAN,EAAeC,OAAf,EAAwBgS,KAAxB;AAXI,mBAAA,GAAa,KAAb;;AAkFA,oBAAA,GAAe+L,UAAD;;;AAClB,UAAI,KAAKC,gBAAT,EAA2B;AACvB,aAAK/L,QAAL,CAAc7G,SAAd,GAA0Bc,YAA1B,CAAuC,KAAK8R,gBAA5C;;AACA,eAAO,KAAKA,gBAAZ;AACH;;AAED,UAAI,KAAKC,UAAL,KAAoBF,UAAxB,EAAoC;AAChC;AACH;;AAED,YAAM/d,OAAO,GAAG,KAAKkS,QAAL,CAAc7E,GAAd,EAAhB;;AAEA,UAAIrN,OAAJ,EAAa;AACT,YAAI+d,UAAJ,EAAgB;AACZ,eAAKE,UAAL,GAAkB,IAAlB;AACA,gBAAA,KAAKC,aAAL,UAAA,iBAAA,SAAA,MAAoBrI,YAAY,MAAhC;AACA7V,UAAAA,OAAO,CAACuW,aAAR,CAAsB,IAAI9Q,cAAJ,CAAmB;AAAEzF,YAAAA;AAAF,WAAnB,CAAtB;AACH,SAJD,MAIO;AACH,eAAKge,gBAAL,GAAwB,KAAK/L,QAAL,CACnB7G,SADmB,GAEnBsC,UAFmB,CAER;;;AACR,mBAAO,KAAKsQ,gBAAZ;AAEA,iBAAKC,UAAL,GAAkB,KAAlB;AACA,kBAAA,KAAKC,aAAL,UAAA,iBAAA,SAAA,MAAoBrI,YAAY,KAAhC;AACA7V,YAAAA,OAAO,CAACuW,aAAR,CAAsB,IAAI7Q,aAAJ,CAAkB;AAAE1F,cAAAA;AAAF,aAAlB,CAAtB;AACH,WARmB,EAQjB,CARiB,CAAxB;AASH;AACJ;AACJ,KA7BO;;AA+BA,mBAAA,GAAcme,KAAD;AACjB,YAAMC,SAAS,GAAG,KAAKnM,QAAL,CAAcmM,SAAhC;;AACA,YAAMC,WAAW,GAAG,KAAKnM,QAAL,CAAc7E,GAAd,EAApB;;AACA,UAAIiR,UAAU,GAAGH,KAAK,CAACI,YAAN,GAAqB,CAArB,CAAjB;;AAEA,SAAG;AACC,YAAID,UAAU,KAAKD,WAAnB,EAAgC;AAC5B,eAAKf,WAAL,CAAiB,IAAjB;;AACA;AACH;;AAEDgB,QAAAA,UAAU,GACNA,UAAU,IAAKF,SAAS,CAACE,UAAD,CAD5B;AAEH,OARD,QAQSA,UART;AASH,KAdO;;AAgBA,oBAAA,GAAc;AAClB,WAAKhB,WAAL,CAAiB,KAAjB;AACH,KAFO;;AApHJ,SAAKkB,UAAL,GAAkBV,SAAlB;AAEA,UAAMzS,GAAG,GAAGtL,OAAO,CAACqL,SAApB;AACA,SAAK8F,GAAL,GAAWD,aAAa,CAAC5F,GAAD,EAAMrL,OAAN,CAAxB;AAEA,SAAKye,IAAL,GAAYxc,GAAZ;;AAEA,QAAIlC,OAAO,CAAC2e,UAAR,IAAsB3e,OAAO,CAAC4e,eAAlC,EAAmD;AAC/C,WAAKC,cAAL;AACH;;AAED,UAAMzH,CAAC,GAAG9L,GAAG,EAAb;AACA,UAAMtF,GAAG,GAAGoR,CAAC,CAACpM,QAAd;AAEAhF,IAAAA,GAAG,CAAC6N,gBAAJ,CAAqBiL,uBAArB,EAAsC,KAAKvJ,UAA3C;AACAvP,IAAAA,GAAG,CAAC6N,gBAAJ,CAAqBkL,wBAArB,EAAuC,KAAKvJ,WAA5C;;AAEA,SAAKwJ,IAAL;AACH;;AAEDH,EAAAA,cAAc;AACV,QAAI,CAAC,KAAKV,aAAV,EAAyB;AACrB,WAAKA,aAAL,GAAqB,IAAId,gBAAJ,CACjB,KAAKnL,QADY,EAEjB,KAAKC,QAFY,EAGjB,KAAKoL,WAHY,EAIjB,KAAKmB,IAJY,CAArB;AAMH;AACJ;;AAEDte,EAAAA,OAAO;;;AACH,SAAKqe,UAAL,CAAgB,IAAhB;;AAEA,UAAMnT,GAAG,GAAG,KAAK4G,QAAL,CAAc7G,SAAd,EAAZ;;AACA,UAAMrF,GAAG,GAAGsF,GAAG,CAACN,QAAhB;AAEAhF,IAAAA,GAAG,CAACmO,mBAAJ,CAAwB2K,uBAAxB,EAAyC,KAAKvJ,UAA9C;AACAvP,IAAAA,GAAG,CAACmO,mBAAJ,CAAwB4K,wBAAxB,EAA0C,KAAKvJ,WAA/C;;AAEA,QAAI,KAAKyI,gBAAT,EAA2B;AACvB3S,MAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAK8R,gBAAtB;AACA,aAAO,KAAKA,gBAAZ;AACH;;AAED,UAAA,KAAKE,aAAL,UAAA,iBAAA,SAAA,MAAoB/d,SAApB;;AACA,SAAK6e,OAAL;AACH;;AAEDtJ,EAAAA,wBAAwB,CAACO,UAAD,EAAsBN,YAAtB;AACpB,UAAMsJ,YAAY,GAAG,KAAKf,aAA1B;;AAEA,QAAIe,YAAJ,EAAkB;AACdA,MAAAA,YAAY,CAACvJ,wBAAb,CAAsCO,UAAtC,EAAkDN,YAAlD;AACH,KAFD,MAEO;AACH,YAAM7F,EAAE,GAAG,KAAKsC,UAAL,EAAX;;AAEA,UAAItC,EAAJ,EAAQ;AACJsN,QAAAA,gBAAgB,CAACrH,oBAAjB,CACI,KAAK9D,QADT,EAEInC,EAFJ,EAGI,IAHJ,EAIImG,UAJJ,EAKIN,YALJ;AAOH;AACJ;AACJ;;AAqDOoJ,EAAAA,IAAI;AACR,QAAI5d,sCAAJ,EAAa;AACT8b,MAAAA,sBAAoB,CAAC,KAAK/K,QAAN,EAAgB,KAAhB,EAAuB,KAAKhB,GAA5B,CAApB;AACH;AACJ;;AAEO8N,EAAAA,OAAO;AACX,QAAI7d,sCAAJ,EAAa;AACT8b,MAAAA,sBAAoB,CAAC,KAAK/K,QAAN,EAAgB,IAAhB,CAApB;AACH;AACJ;;;;MAQQgN;AAST5a,EAAAA,YAAYvE,SAA4Bof;AALhC,yBAAA,GAAmB,KAAnB;AACA,eAAA,GAAqC,EAArC;AACA,oBAAA,GAAc,KAAd;AACR,iBAAA,GAAyC,EAAzC;;AAcQ,wBAAA,GAAkB;;;AACtB,YAAMpZ,GAAG,GAAG,KAAK4R,IAAL,GAAY5M,QAAxB;;AACA,YAAMyG,IAAI,GAAGzL,GAAG,CAACyL,IAAjB;;AAEA,UAAIA,IAAJ,EAAU;AACN,aAAK4N,eAAL,CAAqBrZ,GAArB;;AAEA,cAAMiM,KAAK,GAAG,KAAKqN,SAAnB;;AAEA,YAAIrN,KAAJ,EAAW;AACP+K,UAAAA,mBAAmB,CAACvL,IAAD,EAAO;AAAE5P,YAAAA,IAAI,EAAEoQ;AAAR,WAAP,EAAwB,IAAxB,CAAnB;AACA9R,UAAAA,wBAAwB,CAAC,KAAK+R,QAAN,EAAgBT,IAAhB,CAAxB;AACA,iBAAO,MAAA1R,mBAAmB,CAAC,KAAKmS,QAAN,EAAgBT,IAAhB,CAAnB,UAAA,iBAAA,SAAA,MAA0C5P,IAAjD;AACH;AACJ,OAVD,MAUO,IAAI,CAAC,KAAK0d,gBAAV,EAA4B;AAC/B,aAAKA,gBAAL,GAAwB,IAAxB;AACAvZ,QAAAA,GAAG,CAAC6N,gBAAJ,CAAqB,kBAArB,EAAyC,KAAK2L,eAA9C;AACH;;AAED,aAAOjf,SAAP;AACH,KApBO;;AA+RA,uBAAA,GAAkBsB,IAAD;AACrB,aAAO,KAAK4d,MAAL,CAAY5d,IAAI,CAAC4F,EAAjB,CAAP;AACH,KAFO;;AA1SJ,SAAKyK,QAAL,GAAgBlS,OAAhB;AACA,SAAK4X,IAAL,GAAY5X,OAAO,CAACqL,SAApB;AACA,SAAKiU,SAAL,GAAiBF,QAAjB;AAEApf,IAAAA,OAAO,CAAC0f,SAAR,CAAkB;AACd,UAAI,KAAKJ,SAAT,EAAoB;AAChB,aAAKE,eAAL;AACH;AACJ,KAJD;AAKH;;AAwBOH,EAAAA,eAAe,CAACrZ,GAAD;AACnBA,IAAAA,GAAG,CAACmO,mBAAJ,CAAwB,kBAAxB,EAA4C,KAAKqL,eAAjD;AACA,SAAKD,gBAAL,GAAwB,KAAxB;AACH;;AAEDnf,EAAAA,OAAO;AACH,UAAMkL,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,SAAKyH,eAAL,CAAqB/T,GAAG,CAACN,QAAzB;;AACA,WAAO,KAAKsU,SAAZ;AAEA3d,IAAAA,MAAM,CAACC,IAAP,CAAY,KAAK6d,MAAjB,EAAyBE,OAAzB,CAAkCC,MAAD;AAC7B,UAAI,KAAKH,MAAL,CAAYG,MAAZ,CAAJ,EAAyB;AACrB,aAAKH,MAAL,CAAYG,MAAZ,EAAoBxf,OAApB;;AACA,eAAO,KAAKqf,MAAL,CAAYG,MAAZ,CAAP;AACH;AACJ,KALD;AAOA,SAAKC,QAAL,GAAgB,EAAhB;AACH;;AAEDvd,EAAAA,UAAU,CACNrC,OADM,EAENgS,KAFM,EAGN/P,GAHM;AAKN,QAAId,sCAAJ,EAAa;;AAIb,UAAM0e,OAAO,GAAG,IAAIlL,IAAJ,CACZ,KAAK1C,QADO,EAEZjS,OAFY,EAGZ,KAAK8f,cAHO,EAIZ9N,KAJY,EAKZ/P,GALY,CAAhB;AAQA,SAAKud,MAAL,CAAYK,OAAO,CAACrY,EAApB,IAA0BqY,OAA1B;;AAEA,QAAI,KAAKE,WAAT,EAAsB;AAClBF,MAAAA,OAAO,CAACjB,cAAR;AACH;;AAED,WAAOiB,OAAP;AACH;;AAEDjB,EAAAA,cAAc;AACV,SAAKmB,WAAL,GAAmB,IAAnB;AAEA,UAAMC,KAAK,GAAG,KAAKR,MAAnB;;AAEA,SAAK,MAAMhY,EAAX,IAAiB9F,MAAM,CAACC,IAAP,CAAYqe,KAAZ,CAAjB,EAAqC;AACjCA,MAAAA,KAAK,CAACxY,EAAD,CAAL,CAAUoX,cAAV;AACH;AACJ;;AAEkB,SAAZqB,YAAY,CACf7U,SADe,EAEf5D,EAFe;AAIf,UAAMzH,OAAO,GAAIqL,SAAS,GACrB8U,iBADL;;AAEA,WAAOngB,OAAO,IAAKA,OAAO,CAAC6B,IAAR,CAAyBge,QAAzB,CAAkCpY,EAAlC,CAAnB;AACH;AAED;;;;;;;;;;AAQwB,SAAjB2Y,iBAAiB,CACpBpgB,OADoB,EAEpBC,OAFoB,EAGpBogB,OAHoB;QAGpBA;AAAAA,MAAAA,UAA0C;;;;;AAE1C,QAAI,CAACpgB,OAAO,CAACiJ,aAAb,EAA4B;AACxB,aAAO3I,SAAP;AACH;;AAED,UAAM;AAAE+f,MAAAA,QAAF;AAAYC,MAAAA;AAAZ,QAAiCF,OAAvC;AAEA,UAAMhC,SAAS,GAAGre,OAAO,CAACqe,SAA1B;AAGA;AACA;;AACAre,IAAAA,OAAO,CAACwgB,cAAR;AAEA,QAAI3e,IAAJ;AACA,QAAIU,SAAJ;AACA,QAAIK,QAAJ;AACA,QAAIE,KAAJ;AACA,QAAI2d,iBAAiB,GAAG,KAAxB;AACA,QAAIC,mBAAJ;AACA,QAAIC,mBAAJ;AACA,QAAIC,cAAJ;AACA,QAAI3d,YAAJ;AACA,QAAIsb,UAAU,GAAgBgC,gBAAgB,IAAItgB,OAAlD;AACA,UAAM4gB,aAAa,GAA0C,EAA7D;;AAEA,WAAOtC,UAAU,KAAK,CAAC1c,IAAD,IAASye,QAAd,CAAjB,EAA0C;AACtC,YAAM/e,gBAAgB,GAAGxB,mBAAmB,CACxCC,OADwC,EAExCue,UAFwC,CAA5C;;AAKA,UAAI+B,QAAQ,IAAIM,cAAc,KAAKrgB,SAAnC,EAA8C;AAC1C,cAAMugB,GAAG,GAAIvC,UAA0B,CAACuC,GAAxC;;AAEA,YAAIA,GAAJ,EAAS;AACLF,UAAAA,cAAc,GAAGE,GAAG,CAACC,WAAJ,OAAsB,KAAvC;AACH;AACJ;;AAED,UAAI,CAACxf,gBAAL,EAAuB;AACnBgd,QAAAA,UAAU,GAAGF,SAAS,CAACE,UAAD,CAAtB;AACA;AACH;;AAED,YAAMnI,OAAO,GAAImI,UAA0B,CAACnI,OAA5C;;AAEA,UACI7U,gBAAgB,CAAC0B,YAAjB,IACAmT,OAAO,KAAK,QADZ,IAEAA,OAAO,KAAK,SAHhB,EAIE;AACEnT,QAAAA,YAAY,GAAGsb,UAAf;AACH;;AAED,UACI,CAACzb,KAAD,KACA,MAAAvB,gBAAgB,CAACoB,SAAjB,UAAA,iBAAA,SAAA,MAA4Bqe,gBAD5B,KAEA,CAACpe,QAHL,EAIE;AACE6d,QAAAA,iBAAiB,GAAG,IAApB;AACH;;AAED,YAAMQ,YAAY,GAAG1f,gBAAgB,CAACgB,SAAtC;AACA,YAAM2e,WAAW,GAAG3f,gBAAgB,CAACqB,QAArC;AACA,YAAMue,QAAQ,GAAG5f,gBAAgB,CAACuB,KAAlC;;AAEA,UAAI,CAACP,SAAD,IAAc0e,YAAlB,EAAgC;AAC5B1e,QAAAA,SAAS,GAAG0e,YAAZ;AACH;;AAED,UAAI,CAACre,QAAD,IAAase,WAAb,KAA6B,CAAC3e,SAAD,IAAc0e,YAA3C,CAAJ,EAA8D;AAC1D,YAAI1e,SAAJ,EAAe;AACX;AACA,cACI,CAAC2e,WAAW,CAACE,QAAZ,EAAD,IACAF,WAAW,CAAC5O,QAAZ,GAAuB+O,WADvB,IAEA9e,SAAS,CAAC+e,MAAV,MAAqB,MAAAthB,OAAO,CAACuC,SAAR,UAAA,iBAAA,SAAA,MAAmBgf,QAAxC,CAHJ,EAIE;AACEhf,YAAAA,SAAS,GAAGhC,SAAZ;AACAqC,YAAAA,QAAQ,GAAGse,WAAX;AACH;;AAEDP,UAAAA,mBAAmB,GAAGO,WAAtB;AACH,SAZD,MAYO;AACHte,UAAAA,QAAQ,GAAGse,WAAX;AACH;AACJ;;AAED,UACI,CAACpe,KAAD,IACAqe,QADA,KAEC,CAAC5e,SAAD,IAAc0e,YAFf,MAGC,CAACC,WAAD,IAAgB3C,UAAU,KAAKte,OAHhC,CADJ,EAKE;AACE6C,QAAAA,KAAK,GAAGqe,QAAR;AACAT,QAAAA,mBAAmB,GAAG,CAAC,CAAC9d,QAAF,IAAcA,QAAQ,KAAKse,WAAjD;AACH;;AAED,UAAI3f,gBAAgB,CAACM,IAArB,EAA2B;AACvBA,QAAAA,IAAI,GAAGN,gBAAgB,CAACM,IAAxB;AACH;;AAED,UAAI,MAAAN,gBAAgB,CAACoB,SAAjB,UAAA,iBAAA,SAAA,MAA4Bke,aAAhC,EAA+C;AAC3Clf,QAAAA,MAAM,CAAC6f,MAAP,CACIX,aADJ,EAEItf,gBAAgB,CAACoB,SAAjB,CAA2Bke,aAF/B;AAIH;;AAEDtC,MAAAA,UAAU,GAAGF,SAAS,CAACE,UAAD,CAAtB;AACH;;;AAGD,QAAI,CAAC1c,IAAL,EAAW;AACP,YAAM4f,OAAO,GAAGzhB,OAAO,CAAC6B,IAAxB;AACA,YAAMud,QAAQ,GAAGqC,OAAO,CAACnC,SAAzB;;AAEA,UAAIF,QAAJ,EAAc;AACV,YAAI,MAAAnf,OAAO,CAACiJ,aAAR,UAAA,iBAAA,SAAA,MAAuBuI,IAA3B,EAAiC;AAC7B5P,UAAAA,IAAI,GAAG4f,OAAO,CAACjC,eAAR,EAAP;AACH;AACJ;AACJ;;AAED,QAAI5c,QAAQ,IAAI,CAACE,KAAjB,EAAwB;AACpB4d,MAAAA,mBAAmB,GAAG,IAAtB;AACH;;AAED,QAAItf,sCAAO,IAAI,CAACS,IAAhB,EAAsB;AAClB,UAAIU,SAAS,IAAIK,QAAb,IAAyBE,KAA7B,EAAoC;AAChCzB,QAAAA,OAAO,CAACC,KAAR,CACI,qEADJ;AAGH;AACJ;;AAED,UAAMogB,mBAAmB,GAAItD,KAAD,IACxB,CAAC,CAACyC,aAAa,CACXzC,KAAK,CAAC1c,GADK,CADnB;;AAKA,WAAOG,IAAI,GACL;AACIA,MAAAA,IADJ;AAEIU,MAAAA,SAFJ;AAGIK,MAAAA,QAHJ;AAIIE,MAAAA,KAJJ;AAKI4d,MAAAA,mBALJ;AAMIC,MAAAA,mBANJ;AAOIgB,MAAAA,GAAG,EAAErB,QAAQ,GAAG,CAAC,CAACM,cAAL,GAAsBrgB,SAPvC;AAQI0C,MAAAA,YARJ;AASIwd,MAAAA,iBATJ;AAUII,MAAAA,aAAa,EAAEa;AAVnB,KADK,GAaLnhB,SAbN;AAcH;;AAEa,SAAPqhB,OAAO,CACV5hB,OADU,EAEVC,OAFU;;;AAIV,UAAMoe,SAAS,GAAGre,OAAO,CAACqe,SAA1B;;AAEA,SACI,IAAItO,EAAE,GAAG9P,OADb,EAEI8P,EAFJ,EAGIA,EAAE,GAAGsO,SAAS,CAACtO,EAAD,CAHlB,EAIE;AACE,YAAMlO,IAAI,GAAG,MAAA9B,mBAAmB,CAACC,OAAD,EAAU+P,EAAV,CAAnB,UAAA,iBAAA,SAAA,MAAkClO,IAA/C;;AAEA,UAAIA,IAAJ,EAAU;AACN,eAAOA,IAAP;AACH;AACJ;;AAED,WAAOtB,SAAP;AACH;;AAEDuB,EAAAA,MAAM,CAACD,IAAD,EAAmBggB,OAAnB;AACF,QAAIA,OAAJ,EAAa;AACT,aAAO,KAAKhC,QAAL,CAAche,IAAI,CAACsP,GAAnB,CAAP;AACH,KAFD,MAEO;AACH,WAAK0O,QAAL,CAAche,IAAI,CAACsP,GAAnB,IAA0BtP,IAA1B;AACH;AACJ;;;;ACpjBL;;;;AAwBA,MAAMigB,uBAAuB,GAAG,EAAhC;MAEsBC;MAKTC,oBAAoBD;AAK7Bxd,EAAAA,YAAYvE,SAA4BmC;AACpC;AACA,SAAKgP,GAAL,GAAWhP,OAAO,CAACgP,GAAnB;AACA,SAAKe,QAAL,GAAgBlS,OAAhB;AACA,SAAKiiB,QAAL,GAAgB9f,OAAhB;AACH;;AAED+f,EAAAA,SAAS,CAAC/f,OAAD;AACL,WAAOA,OAAO,KAAK,KAAK8f,QAAxB;AACH;;AAEDE,EAAAA,OAAO,CAACliB,OAAD;AACH,SAAKgiB,QAAL,CAAcE,OAAd,CAAsBliB,OAAtB;AACH;;AAEmB,QAAdmiB,cAAc;AAChB,UAAMC,SAAS,GAAG,KAAKJ,QAAL,CAAcK,aAAd,EAAlB;;AACA,UAAMC,cAAc,GAAG,KAAKN,QAAL,CAAc5P,UAAd,EAAvB;;AAEA,QAAIgQ,SAAS,IAAIE,cAAjB,EAAiC;AAC7B,UACI,CAACA,cAAc,CAAC/L,aAAf,CACG,IAAIxR,qBAAJ,CAA0B;AACtByR,QAAAA,EAAE,EAAE,SADkB;AAEtBC,QAAAA,KAAK,EAAE6L,cAFe;AAGtB5L,QAAAA,IAAI,EAAE0L;AAHgB,OAA1B,CADH,CADL,EAQE;AACE;AACA,eAAO,IAAP;AACH;;AAED,aAAO,KAAKnQ,QAAL,CAAcwL,cAAd,CAA6B8E,KAA7B,CAAmCH,SAAnC,CAAP;AACH;;AAED,WAAO,KAAP;AACH;;AAEe,QAAVI,UAAU;AACZ,UAAMpX,SAAS,GAAG,KAAK6G,QAAL,CAAc7G,SAAhC;AACA,WAAOyG,UAAU,CAACzG,SAAD,CAAV,CAAsBqX,OAAtB,CAA8B,KAAKT,QAAL,CAAcQ,UAAd,EAA9B,CAAP;AACH;;;MAGiBE;AAQlBpe,EAAAA,YAAYvE,SAA4B4iB;AAH9B,iBAAA,GAAgB,EAAhB;AAIN,SAAK1Q,QAAL,GAAgBlS,OAAhB;AACA,SAAK4iB,OAAL,GAAeA,OAAf;AACH;;AAEDC,EAAAA,SAAS;AACL,WAAO,KAAKC,QAAL,CAAc3f,MAArB;AACH;;AAED4f,EAAAA,aAAa,CAAC5gB,OAAD;AACT,SAAK2gB,QAAL,GAAgB,KAAKA,QAAL,CAAc5c,MAAd,CAAsB8c,CAAD,IAAO,CAACA,CAAC,CAACd,SAAF,CAAY/f,OAAZ,CAA7B,CAAhB;AACH;;AAED8gB,EAAAA,UAAU,CAAC9gB,OAAD;AACN,WAAO,KAAK2gB,QAAL,CAAcI,IAAd,CAAoBC,CAAD,IAAOA,CAAC,CAACjB,SAAF,CAAY/f,OAAZ,CAA1B,CAAP;AACH;;;;AAML,MAAMihB,oBAAN,SAAmCT,wBAAnC;AAIIU,EAAAA,gBAAgB,CAAClhB,OAAD,EAAyBlC,OAAzB;AACZ,QAAIqjB,IAAJ;;AAEA,SAAK,IAAI1S,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKkS,QAAL,CAAc3f,MAAlC,EAA0CyN,CAAC,EAA3C,EAA+C;AAC3C,UAAI,KAAKkS,QAAL,CAAclS,CAAd,EAAiBsR,SAAjB,CAA2B/f,OAA3B,CAAJ,EAAyC;AACrCmhB,QAAAA,IAAI,GAAG,KAAKR,QAAL,CAAclS,CAAd,CAAP;;AACA,aAAKkS,QAAL,CAAcS,MAAd,CAAqB3S,CAArB,EAAwB,CAAxB;;AACA;AACH;AACJ;;AAED,QAAI,CAAC0S,IAAL,EAAW;AACPA,MAAAA,IAAI,GAAG,IAAItB,WAAJ,CAAgB,KAAK9P,QAArB,EAA+B/P,OAA/B,CAAP;AACH;;AAEDmhB,IAAAA,IAAI,CAACnB,OAAL,CAAaliB,OAAb;;AAEA,SAAK6iB,QAAL,CAAcX,OAAd,CAAsBmB,IAAtB;;AAEA,SAAKR,QAAL,CAAcS,MAAd,CACIzB,uBADJ,EAEI,KAAKgB,QAAL,CAAc3f,MAAd,GAAuB2e,uBAF3B;AAIH;;AAEmB,QAAdM,cAAc,CAAClI,IAAD;AAChB,QAAIsJ,IAAI,GAAG,CAAC,CAACtJ,IAAb;;AAEA,SAAK,MAAMtJ,CAAX,IAAgB,KAAKkS,QAArB,EAA+B;AAC3B,UAAI5I,IAAI,IAAItJ,CAAC,CAACsR,SAAF,CAAYhI,IAAZ,CAAZ,EAA+B;AAC3BsJ,QAAAA,IAAI,GAAG,KAAP;AACH;;AAED,UAAI,CAACA,IAAL,EAAW;AACP,cAAMC,MAAM,GAAG,MAAM7S,CAAC,CAACwR,cAAF,EAArB,CADO;AAIP;;AACA,YAAIqB,MAAM,IAAIA,MAAM,KAAK,IAAzB,EAA+B;AAC3B,iBAAOA,MAAP;AACH;AACJ;AACJ;;AAED,WAAO,KAAP;AACH;;AAEe,QAAVhB,UAAU,CAACvI,IAAD;AACZ,QAAIsJ,IAAI,GAAG,CAAC,CAACtJ,IAAb;AACA,UAAMwJ,UAAU,GAAkC,EAAlD;;AAEA,SAAK,MAAM9S,CAAX,IAAgB,KAAKkS,QAArB,EAA+B;AAC3B,UAAI5I,IAAI,IAAItJ,CAAC,CAACsR,SAAF,CAAYhI,IAAZ,CAAZ,EAA+B;AAC3BsJ,QAAAA,IAAI,GAAG,KAAP;AACH;;AAED,UAAI,CAACA,IAAD,IAAS,CAACE,UAAU,CAAC9S,CAAC,CAACO,GAAH,CAAxB,EAAiC;AAC7BuS,QAAAA,UAAU,CAAC9S,CAAC,CAACO,GAAH,CAAV,GAAoBP,CAApB;AACH;AACJ;;;AAGD,SAAK,MAAMnJ,EAAX,IAAiB9F,MAAM,CAACC,IAAP,CAAY8hB,UAAZ,CAAjB,EAA0C;AACtC,UAAI,MAAMA,UAAU,CAACjc,EAAD,CAAV,CAAegb,UAAf,EAAV,EAAuC;AACnC,eAAO,IAAP;AACH;AACJ;;AAED,WAAO,KAAP;AACH;;;;MAGQkB;AAQTpf,EAAAA,YAAYvE;AANZ;AACQ,iBAAA,GAGF,EAHE;AAMJ,SAAKkS,QAAL,GAAgBlS,OAAhB;AACH;;AAEDI,EAAAA,OAAO;AACH,SAAK0iB,QAAL,GAAgB,EAAhB;AACH;;AAEDc,EAAAA,OAAO,CAAC3jB,OAAD;;;AACH,UAAMsL,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyCjS,OAAzC,CAAZ;AACA,UAAM2iB,OAAO,GAAGrX,GAAG,IAAIA,GAAG,CAAC1J,IAAJ,CAASsP,GAAhC;AACA,UAAMhP,OAAO,GAAG0hB,UAAU,CAACC,UAAX,CAAsB,KAAK5R,QAA3B,EAAqCjS,OAArC,CAAhB;;AAEA,QAAI,CAAC2iB,OAAD,IAAY,CAACzgB,OAAjB,EAA0B;AACtB,aAAO5B,SAAP;AACH;;AAED,UAAMwjB,aAAa,GAAG,KAAKC,IAAL,CAClBpB,OADkB,EAElB,MAAM,IAAIQ,oBAAJ,CAAyB,KAAKlR,QAA9B,EAAwC0Q,OAAxC,CAFY,CAAtB;;AAKA,QAAI,CAACrX,GAAD,IAAQ,CAACA,GAAG,CAAChJ,SAAb,KAA0B,MAAAgJ,GAAG,CAAChJ,SAAJ,UAAA,iBAAA,SAAA,MAAe6e,UAAzC,CAAJ,EAAyD;AACrD2C,MAAAA,aAAa,CAACV,gBAAd,CAA+BlhB,OAA/B,EAAwClC,OAAxC;AACH;;AAED,WAAOkC,OAAP;AACH;;AAED6hB,EAAAA,IAAI,CAIFpB,OAJE,EAIeqB,cAJf;AAKA,QAAIF,aAAJ;;AAEA,SAAK,IAAInT,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKkS,QAAL,CAAc3f,MAAlC,EAA0CyN,CAAC,EAA3C,EAA+C;AAC3C,YAAMsT,GAAG,GAAG,KAAKpB,QAAL,CAAclS,CAAd,CAAZ;;AAEA,UAAIsT,GAAG,CAACtB,OAAJ,KAAgBA,OAApB,EAA6B;AACzBmB,QAAAA,aAAa,GAAGG,GAAhB;;AACA,aAAKpB,QAAL,CAAcS,MAAd,CAAqB3S,CAArB,EAAwB,CAAxB;;AACA;AACH;AACJ;;AAED,QAAI,CAACmT,aAAL,EAAoB;AAChBA,MAAAA,aAAa,GAAGE,cAAc,EAA9B;AACH;;AAED,SAAKnB,QAAL,CAAcX,OAAd,CAAsB4B,aAAtB;;AAEA,SAAKjB,QAAL,CAAcS,MAAd,CACIzB,uBADJ,EAEI,KAAKgB,QAAL,CAAc3f,MAAd,GAAuB2e,uBAF3B;;AAKA,WAAOiC,aAAP;AACH;;AAEDhB,EAAAA,aAAa,CAAC5gB,OAAD;AACT,SAAK2gB,QAAL,CAAcnD,OAAd,CAAuB/O,CAAD;AAClBA,MAAAA,CAAC,CAACmS,aAAF,CAAgB5gB,OAAhB;AACH,KAFD;;AAIA,SAAK2gB,QAAL,GAAgB,KAAKA,QAAL,CAAc5c,MAAd,CAAsB0K,CAAD,IAAOA,CAAC,CAACiS,SAAF,KAAgB,CAA5C,CAAhB;AACH;;AAEmB,QAAdT,cAAc,CAAClI,IAAD;AAChB,QAAIsJ,IAAI,GAAG,CAAC,CAACtJ,IAAb;;AAEA,SAAK,MAAMiK,CAAX,IAAgB,KAAKrB,QAArB,EAA+B;AAC3B,UAAI5I,IAAI,IAAIiK,CAAC,CAAClB,UAAF,CAAa/I,IAAb,CAAZ,EAAgC;AAC5BsJ,QAAAA,IAAI,GAAG,KAAP;AACH;;AAED,UAAI,CAACA,IAAL,EAAW;AACP,cAAMC,MAAM,GAAG,MAAMU,CAAC,CAAC/B,cAAF,CAAiBlI,IAAjB,CAArB,CADO;AAIP;;AACA,YAAIuJ,MAAM,IAAIA,MAAM,KAAK,IAAzB,EAA+B;AAC3B,iBAAOA,MAAP;AACH;AACJ;AACJ;;AAED,WAAO,KAAP;AACH;;AAEe,QAAVhB,UAAU,CAACvI,IAAD;AACZ,QAAIsJ,IAAI,GAAG,CAAC,CAACtJ,IAAb;;AAEA,SAAK,MAAMiK,CAAX,IAAgB,KAAKrB,QAArB,EAA+B;AAC3B,UAAI5I,IAAI,IAAIiK,CAAC,CAAClB,UAAF,CAAa/I,IAAb,CAAZ,EAAgC;AAC5BsJ,QAAAA,IAAI,GAAG,KAAP;AACH;;AAED,UAAI,CAACA,IAAD,KAAU,MAAMW,CAAC,CAAC1B,UAAF,CAAavI,IAAb,CAAhB,CAAJ,EAAyC;AACrC,eAAO,IAAP;AACH;AACJ;;AAED,WAAO,KAAP;AACH;;;;AAGL,SAASgD,sBAAT,CACIC,WADJ,EAEIhF,MAFJ,EAGIiJ,QAHJ,EAIIgD,aAJJ;AAMI,MAAIhjB,sCAAJ,EAAa;AACT,UAAMnB,OAAO,GAAGkd,WAAW,CAAC7P,GAAZ,EAAhB;;AAEA,QAAIrN,OAAJ,EAAa;AACT,UAAIkY,MAAJ,EAAY;AACRlY,QAAAA,OAAO,CAACoT,KAAR,CAAc+J,cAAd,CAA6B,mBAA7B;AACH,OAFD,MAEO;AACHnd,QAAAA,OAAO,CAACoT,KAAR,CAAcI,WAAd,CACI,mBADJ,EAEI,CAAC2N,QAAQ,GAAG,QAAH,GAAc,UAAvB,IACI,GADJ,IAEK,cAAcgD,aAFnB,CAFJ;AAMH;AACJ;AACJ;AACJ;;AAED,SAASC,oBAAT,CACIpkB,OADJ,EAEIqkB,SAFJ,EAGIC,SAHJ;AAKI,QAAMvd,QAAQ,GAAa,EAA3B;AACA,QAAMwd,YAAY,GAAG,qBAArB;AACA,QAAMC,kBAAkB,GAAG,MAA3B;AAEA,QAAMC,SAAS,GAAGzkB,OAAO,CAACO,YAAR,CAAqB,IAArB,CAAlB;;AAEA,MAAIkkB,SAAJ,EAAe;AACX1d,IAAAA,QAAQ,CAACmG,IAAT,CACI,MAAMuX,SAAS,CAACC,OAAV,CAAkBH,YAAlB,EAAgCC,kBAAhC,CADV;AAGH;;AAED,MAAIH,SAAS,KAAK,KAAd,IAAuBrkB,OAAO,CAAC2kB,SAAnC,EAA8C;AAC1C3kB,IAAAA,OAAO,CAAC2kB,SAAR,CAAkBC,KAAlB,CAAwB,GAAxB,EAA6BlF,OAA7B,CAAsCmF,GAAD;AACjCA,MAAAA,GAAG,GAAGA,GAAG,CAACC,IAAJ,EAAN;;AAEA,UAAID,GAAJ,EAAS;AACL9d,QAAAA,QAAQ,CAACmG,IAAT,CACI,MAAM2X,GAAG,CAACH,OAAJ,CAAYH,YAAZ,EAA0BC,kBAA1B,CADV;AAGH;AACJ,KARD;AASH;;AAED,MAAIO,KAAK,GAAG,CAAZ;AACA,MAAIjV,EAAJ;;AAEA,MAAIwU,SAAS,KAAK,KAAd,IAAuBvd,QAAQ,CAAC7D,MAAT,KAAoB,CAA/C,EAAkD;AAC9C4M,IAAAA,EAAE,GAAG9P,OAAL;;AACA,WAAO8P,EAAP,EAAW;AACPiV,MAAAA,KAAK;AACLjV,MAAAA,EAAE,GAAGA,EAAE,CAACrH,sBAAR;AACH;;AACD1B,IAAAA,QAAQ,CAACmb,OAAT,CAAiB,gBAAgB6C,KAAhB,GAAwB,GAAzC;AACH;;AAEDhe,EAAAA,QAAQ,CAACmb,OAAT,CAAiBliB,OAAO,CAACmW,OAAR,CAAgB2K,WAAhB,EAAjB;AAEA,SAAO/Z,QAAQ,CAACnK,IAAT,CAAc,EAAd,CAAP;AACH;;AAED,SAASooB,aAAT,CAAuBhlB,OAAvB;AACI,MAAI,CAAC8M,gBAAgB,CAAC9M,OAAO,CAACiJ,aAAT,EAAwBjJ,OAAxB,CAArB,EAAuD;AACnD,WAAOM,SAAP;AACH;;AAED,QAAMyG,QAAQ,GAAa,CAACqd,oBAAoB,CAACpkB,OAAD,CAArB,CAA3B;AAEA,MAAIoG,IAAI,GAAG+C,GAAG,CAACE,aAAJ,CAAkBrJ,OAAlB,CAAX;;AAEA,SAAOoG,IAAI,IAAIA,IAAI,CAAC0H,QAAL,KAAkBC,IAAI,CAACkX,sBAAtC,EAA8D;AAC1D;AACA,QAAI7e,IAAI,CAAC0H,QAAL,KAAkBC,IAAI,CAACC,YAA3B,EAAyC;AACrC,YAAMkX,MAAM,GAAI9e,IAAoB,CAAC+P,OAArB,KAAiC,MAAjD;AAEApP,MAAAA,QAAQ,CAACmb,OAAT,CACIkC,oBAAoB,CAAChe,IAAD,EAAsB,KAAtB,EAA6B,CAAC8e,MAA9B,CADxB;;AAIA,UAAIA,MAAJ,EAAY;AACR;AACH;AACJ;;AAED9e,IAAAA,IAAI,GAAG+C,GAAG,CAACE,aAAJ,CAAkBjD,IAAlB,CAAP;AACH;;AAED,SAAOW,QAAQ,CAACnK,IAAT,CAAc,GAAd,CAAP;AACH;;MAEYI,gBACD+U;AAURzN,EAAAA,YACIvE,SACAC,SACA8d,WACA9L;AAEA,UAAMjS,OAAN,EAAeC,OAAf,EAAwBgS,KAAxB;AAXI,kBAAA,GAAY,KAAZ;AACA,iBAAA,GAAqD,CAAC,EAAD,CAArD;AACA,uBAAA,GAAiB,CAAjB;;AAqCR,iBAAA,GAAW;AACP,aAAO,KAAKmT,SAAZ;AACH,KAFD;;AA4BA,oBAAA,GAAeJ,KAAD;AACV,WAAKK,cAAL,GAAsBL,KAAtB;;AAEA,UAAI,KAAKlC,QAAL,CAAc3f,MAAd,GAAuB6hB,KAAK,GAAG,CAAnC,EAAsC;AAClC,aAAKlC,QAAL,CAAcS,MAAd,CAAqByB,KAAK,GAAG,CAA7B,EAAgC,KAAKlC,QAAL,CAAc3f,MAAd,GAAuB6hB,KAAvB,GAA+B,CAA/D;AACH;;AAED,UAAI,CAAC,KAAKlC,QAAL,CAAckC,KAAd,CAAL,EAA2B;AACvB,aAAKlC,QAAL,CAAckC,KAAd,IAAuB,EAAvB;AACH;;AAED,UAAI5jB,sCAAJ,EAAa;AACT8b,QAAAA,sBAAoB,CAChB,KAAK/K,QADW,EAEhB,KAFgB,EAGhB,KAAKiT,SAHW,EAIhB,KAAKC,cAJW,CAApB;AAMH;AACJ,KAnBD;;AAqBA,mBAAA,GAAa;AACT,YAAMlkB,CAAC,GAAG,KAAKgR,QAAL,CAAc7E,GAAd,EAAV;;AACA,aAAO,CAAC,CAACnM,CAAF,IAAO,KAAK+Q,QAAL,CAAcwL,cAAd,CAA6B4H,UAA7B,CAAwC;AAAElW,QAAAA,SAAS,EAAEjO;AAAb,OAAxC,CAAd;AACH,KAHD;;AA0BA,qBAAA,GAAe;AACX,YAAMA,CAAC,GAAG,KAAKgR,QAAL,CAAc7E,GAAd,EAAV;;AACA,aAAO,CAAC,CAACnM,CAAF,IAAO,KAAK+Q,QAAL,CAAcwL,cAAd,CAA6B6H,YAA7B,CAA0CpkB,CAA1C,CAAd;AACH,KAHD;;AAKA,mBAAA,GAAa;AACT,YAAMA,CAAC,GAAG,KAAKgR,QAAL,CAAc7E,GAAd,EAAV;;AACA,aAAO,CAAC,CAACnM,CAAF,IAAO,KAAK+Q,QAAL,CAAcwL,cAAd,CAA6B+E,UAA7B,CAAwCthB,CAAxC,CAAd;AACH,KAHD;;AAiFA,qBAAA,GAAgBqkB,gBAAD;AACX,YAAMvlB,OAAO,GAAG,KAAKkS,QAAL,CAAc7E,GAAd,EAAhB;;AAEA,UAAI,CAACrN,OAAL,EAAc;AACV,aAAK6iB,QAAL,CAAc,KAAKuC,cAAnB,IAAqC,EAArC;AAEA;AACH;;AAED,WAAKvC,QAAL,CAAc,KAAKuC,cAAnB,IAAqC,KAAKvC,QAAL,CACjC,KAAKuC,cAD4B,EAEnCnf,MAFmC,CAE3Buf,EAAD;AACL,cAAMtkB,CAAC,GAAGskB,EAAE,CAACnY,GAAH,EAAV;AACA,eAAOnM,CAAC,IAAIqkB,gBAAL,GAAwBpc,GAAG,CAACI,YAAJ,CAAiBvJ,OAAjB,EAA0BkB,CAA1B,CAAxB,GAAuD,KAA9D;AACH,OALoC,CAArC;AAMH,KAfD;;AA3LI,SAAKgQ,GAAL,GAAWD,aAAa,CAAClR,OAAO,CAACqL,SAAT,EAAoBpL,OAApB,CAAxB;AACA,SAAKylB,QAAL,GAAgBzT,KAAK,CAACyT,QAAN,IAAkBjlB,iBAAA,CAAwB5C,IAA1D;AACA,SAAK4gB,UAAL,GAAkBV,SAAlB;;AAEA,QAAI3c,sCAAJ,EAAa;AACT8b,MAAAA,sBAAoB,CAChB,KAAK/K,QADW,EAEhB,KAFgB,EAGhB,KAAKiT,SAHW,EAIhB,KAAKC,cAJW,CAApB;AAMH;AACJ;;AAEDjlB,EAAAA,OAAO;AACH,SAAK6e,OAAL;;AAEA,SAAKR,UAAL,CAAgB,IAAhB;;AAEA,SAAK2G,SAAL,GAAiB,KAAjB;AACA,SAAKC,cAAL,GAAsB,CAAtB;AAEA,SAAKjT,MAAL,GAAc,EAAd;AACA,SAAK0Q,QAAL,GAAgB,EAAhB;AACH;;AAMD6C,EAAAA,SAAS,CAACC,MAAD;AACL,SAAKR,SAAL,GAAiBQ,MAAjB;;AAEA,QAAIxkB,sCAAJ,EAAa;AACT8b,MAAAA,sBAAoB,CAChB,KAAK/K,QADW,EAEhB,KAFgB,EAGhB,KAAKiT,SAHW,EAIhB,KAAKC,cAJW,CAApB;AAMH;AACJ;;AAEDQ,EAAAA,UAAU;AACN,WAAO;AACHN,MAAAA,YAAY,EAAE,KAAKA,YADhB;AAEHD,MAAAA,UAAU,EAAE,KAAKA,UAFd;AAGH7C,MAAAA,UAAU,EAAE,KAAKA,UAHd;AAIHqD,MAAAA,YAAY,EAAE,KAAKA,YAJhB;AAKHC,MAAAA,WAAW,EAAE,KAAKA,WALf;AAMH3E,MAAAA,QAAQ,EAAE,KAAKA;AANZ,KAAP;AAQH;;AA4BDe,EAAAA,OAAO,CAACliB,OAAD;AACH,QAAIyb,GAAG,GAAG,KAAKoH,QAAL,CAAc,KAAKuC,cAAnB,CAAV;AAEA3J,IAAAA,GAAG,GAAG,KAAKoH,QAAL,CAAc,KAAKuC,cAAnB,IAAqC3J,GAAG,CAACxV,MAAJ,CAAYuf,EAAD;AAClD,YAAMtkB,CAAC,GAAGskB,EAAE,CAACnY,GAAH,EAAV;AACA,aAAOnM,CAAC,IAAIA,CAAC,KAAKlB,OAAlB;AACH,KAH0C,CAA3C;AAKAyb,IAAAA,GAAG,CAACyG,OAAJ,CACI,IAAInV,eAAJ,CACI,KAAKkF,QAAL,CAAc7G,SADlB,EAEIpL,OAFJ,EAGIglB,aAAa,CAAChlB,OAAD,CAHjB,CADJ;;AAQA,WAAOyb,GAAG,CAACvY,MAAJ,GAAa2e,uBAApB,EAA6C;AACzCpG,MAAAA,GAAG,CAACsK,GAAJ;AACH;AACJ;;AAYD1D,EAAAA,aAAa;AACT,UAAMriB,OAAO,GAAG,KAAKkS,QAAL,CAAc7E,GAAd,EAAhB;;AAEA,QAAI,CAACrN,OAAD,IAAY,CAAC,KAAKiS,QAAL,CAAcvP,SAAd,CAAwBsjB,SAAxB,CAAkChmB,OAAlC,CAAjB,EAA6D;AACzD,aAAO,IAAP;AACH;;AAED,QAAIimB,iBAAiB,GAAG,KAAK9T,MAAL,CAAY8T,iBAApC;AACA,QAAI7D,SAAS,GAAuB,IAApC;AAEA,UAAM9W,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyCjS,OAAzC,CAAZ;;AAEA,QAAI,CAACsL,GAAL,EAAU;AACN,aAAO,IAAP;AACH;;AAED,UAAM1J,IAAI,GAAG0J,GAAG,CAAC1J,IAAjB;AACA,UAAMyc,WAAW,GAAGzc,IAAI,CAACwQ,UAAL,EAApB;;AAEA,QAAI,CAACiM,WAAL,EAAkB;AACd,aAAO,IAAP;AACH;;AAED,QAAI4H,iBAAiB,KAAK3lB,SAA1B,EAAqC;AACjC2lB,MAAAA,iBAAiB,GAAGrkB,IAAI,CAACyQ,QAAL,GAAgB4T,iBAApC;AACH;;AAED,QAAIA,iBAAiB,KAAKzlB,kBAAA,CAAyBhD,WAAnD,EAAgE;AAC5D4kB,MAAAA,SAAS,GAAG,KAAKnQ,QAAL,CAAcvP,SAAd,CAAwBwjB,WAAxB,CAAoC;AAC5C/W,QAAAA,SAAS,EAAEkP;AADiC,OAApC,CAAZ;AAGH;;AAED,QACI,CAAC+D,SAAD,IACA6D,iBAAiB,KAAKzlB,kBAAA,CAAyB9C,SAFnD,EAGE;AACE0kB,MAAAA,SAAS,GAAG,KAAK+D,UAAL,CAAgB9H,WAAhB,CAAZ;AACH;;AAED,QAAI+D,SAAJ,EAAe;AACX,aAAOA,SAAP;AACH;;AAED,UAAMgE,kBAAkB,GAAG,KAAKC,cAAL,EAA3B;;AAEA,QACID,kBAAkB,IAClBH,iBAAiB,KAAKzlB,kBAAA,CAAyBlD,OAFnD,EAGE;AACE,aAAO8oB,kBAAP;AACH;;AAED,UAAME,gBAAgB,GAAG,KAAKrU,QAAL,CAAcvP,SAAd,CAAwBwjB,WAAxB,CAAoC;AACzD/W,MAAAA,SAAS,EAAEnP;AAD8C,KAApC,CAAzB;;AAIA,QACIsmB,gBAAgB,IAChBL,iBAAiB,KAAKzlB,kBAAA,CAAyBjD,cAFnD,EAGE;AACE,aAAO+oB,gBAAP;AACH;;AAED,UAAMC,cAAc,GAAG,KAAKJ,UAAL,CAAgBnmB,OAAhB,CAAvB;;AAEA,QACIumB,cAAc,IACdN,iBAAiB,KAAKzlB,kBAAA,CAAyB/C,YAFnD,EAGE;AACE,aAAO8oB,cAAP;AACH;;AAED,WAAOD,gBAAgB,IAAIF,kBAApB,IAA0CG,cAA1C,IAA4D,IAAnE;AACH;;AAmBDC,EAAAA,sBAAsB,CAACxmB,OAAD;AAClB,WAAOA,OAAO,CAACuW,aAAR,CACH,IAAIjR,qBAAJ,CAA0B,KAAKsgB,UAAL,EAA1B,CADG,CAAP;AAGH;;AAEOS,EAAAA,cAAc;AAClB,UAAM5K,GAAG,GAAG,KAAKoH,QAAL,CAAc,KAAKuC,cAAnB,EAAmChe,KAAnC,CAAyC,CAAzC,CAAZ;;AAEA,SAAKye,YAAL,CAAkB,IAAlB;;AAEA,SAAK,IAAIlV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8K,GAAG,CAACvY,MAAxB,EAAgCyN,CAAC,EAAjC,EAAqC;AACjC,YAAM6U,EAAE,GAAG/J,GAAG,CAAC9K,CAAD,CAAd;AACA,YAAMzP,CAAC,GAAGskB,EAAE,CAACnY,GAAH,EAAV;;AACA,YAAMrN,OAAO,GAAG,KAAKkS,QAAL,CAAc7E,GAAd,EAAhB;;AAEA,UAAInM,CAAC,IAAIlB,OAAL,IAAgBmJ,GAAG,CAACI,YAAJ,CAAiBvJ,OAAjB,EAA0BkB,CAA1B,CAApB,EAAkD;AAC9C,YAAI,KAAK+Q,QAAL,CAAcvP,SAAd,CAAwB0T,WAAxB,CAAoClV,CAApC,CAAJ,EAA4C;AACxC,iBAAOA,CAAP;AACH;AACJ,OAJD,MAIO,IAAI,CAAC,KAAKiR,MAAL,CAAYsU,eAAjB,EAAkC;AACrC;AACA;AACA;AACA,cAAM1f,QAAQ,GAAGye,EAAE,CAAClY,OAAH,EAAjB;;AAEA,YAAIvG,QAAQ,IAAI/G,OAAhB,EAAyB;AACrB,cAAI0mB,GAAJ;;AAEA,cAAI;AACAA,YAAAA,GAAG,GAAGvd,GAAG,CAAC7B,gBAAJ,CACFtH,OAAO,CAACiJ,aADN,EAEFlC,QAFE,CAAN;AAIH,WALD,CAKE,OAAO7F,CAAP,EAAU;AACR,gBAAIC,sCAAJ,EAAa;AACT;AACAC,cAAAA,OAAO,CAACC,KAAR,gCACmC0F,YADnC;AAGH;;AACD;AACH;;AAED,eAAK,IAAI4J,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG+V,GAAG,CAACxjB,MAAxB,EAAgCyN,CAAC,EAAjC,EAAqC;AACjC,kBAAMb,EAAE,GAAG4W,GAAG,CAAC/V,CAAD,CAAd;;AAEA,gBAAIb,EAAE,IAAI,KAAKmC,QAAL,CAAcvP,SAAd,CAAwB0T,WAAxB,CAAoCtG,EAApC,CAAV,EAAmD;AAC/C,qBAAOA,EAAP;AACH;AACJ;AACJ;AACJ;AACJ;;AAED,WAAO,IAAP;AACH;;AAEOqW,EAAAA,UAAU,CAACnmB,OAAD;AACd,QAAI,KAAKiS,QAAL,CAAcsL,kBAAd,CAAiCoJ,wBAAjC,EAAJ,EAAiE;AAC7D,YAAM1N,KAAK,GAAG,KAAKhH,QAAL,CAAcvP,SAAd,CAAwBkkB,SAAxB,CAAkC;AAC5CzX,QAAAA,SAAS,EAAEnP,OADiC;AAE5C6mB,QAAAA,kBAAkB,EAAE;AAFwB,OAAlC,CAAd;;AAKA,UAAI5N,KAAJ,EAAW;AACP,eAAOA,KAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;;AAEO+F,EAAAA,OAAO;AACX,QAAI7d,sCAAJ,EAAa;AACT8b,MAAAA,sBAAoB,CAAC,KAAK/K,QAAN,EAAgB,IAAhB,CAApB;AACH;AACJ;;;;MAQQ0R;AAeTtf,EAAAA,YACIvE,SACAiS;AAdJ;;;AAGQ,mBAAA,GAAa,KAAb;AAIA,0BAAA,GAAoB,KAApB;AACA,kBAAA,GAAY,KAAZ;;AAyHA,wBAAA,GAAmBmM,KAAD;;;AACtB,YAAM3R,MAAM,GAAG2R,KAAK,CAACI,YAAN,GAAqB,CAArB,CAAf;;AAKA,UAAI/R,MAAJ,EAAY;AACR,cAAM4V,SAAS,GAAG,MAAAwB,UAAU,CAACC,UAAX,CACd,KAAK5R,QADS,EAEdzF,MAFc,CAAA,UAAA,iBAAA,SAAA,MAGf6V,eAHH;;AAKA,YAAID,SAAJ,EAAe;AACX,eAAKnQ,QAAL,CAAcwL,cAAd,CAA6B8E,KAA7B,CAAmCH,SAAnC;AACH;;AAEDjE,QAAAA,KAAK,CAAC2I,wBAAN;AACH;AACJ,KAlBO;;AAoBA,iBAAA,GAAY5lB,CAAD;AACf,UAAI,KAAK6lB,kBAAT,EAA6B;AACzB,aAAKpP,IAAL,GAAYzL,YAAZ,CAAyB,KAAK6a,kBAA9B;;AACA,aAAKA,kBAAL,GAA0BzmB,SAA1B;AACH;;AAED,UAAI,CAACY,CAAL,EAAQ;AACJ,aAAK8lB,qBAAL;;AAEA;AACH;;AAED,YAAM9kB,OAAO,GAAG,KAAK2gB,QAAL,CAAcc,OAAd,CAAsBziB,CAAtB,CAAhB;;AAEA,UAAIgB,OAAJ,EAAa;AACT,aAAK+kB,SAAL,CAAe/kB,OAAf;AACH,OAFD,MAEO;AACH,aAAKglB,WAAL;AACH;AACJ,KAnBO;;AA6KA,0BAAA,GAAqBhlB,OAAD;AACxB,WAAK2gB,QAAL,CAAcC,aAAd,CAA4B5gB,OAA5B;;AAEA,UAAIA,OAAO,CAACif,QAAR,EAAJ,EAAwB;AACpB,aAAK6F,qBAAL;AACH;AACJ,KANO;;AAlTJ,SAAK/U,QAAL,GAAgBlS,OAAhB;AACA,SAAK4X,IAAL,GAAY5X,OAAO,CAACqL,SAApB;AACA,SAAKyX,QAAL,GAAgB,IAAIa,cAAJ,CAAmB3jB,OAAnB,CAAhB;AAEAA,IAAAA,OAAO,CAAC0f,SAAR,CAAkB;AACd,WAAKxN,QAAL,CAAcwL,cAAd,CAA6B0J,SAA7B,CAAuC,KAAKnO,QAA5C;;AACA,YAAMjT,GAAG,GAAG,KAAK4R,IAAL,GAAY5M,QAAxB;;AAEAhF,MAAAA,GAAG,CAAC6N,gBAAJ,CACIrQ,4BADJ,EAEI,KAAK6jB,eAFT;AAKA,YAAMvgB,aAAa,GAAGsC,GAAG,CAACK,gBAAJ,CAAqBzD,GAArB,CAAtB;;AAEA,UAAIc,aAAa,IAAIA,aAAa,KAAKd,GAAG,CAACyL,IAA3C,EAAiD;AAC7C;AACA,aAAKwH,QAAL,CAAcnS,aAAd;AACH;AACJ,KAfD;AAiBA,UAAMwgB,WAAW,GAAGrV,KAAK,SAAL,IAAAA,KAAK,WAAL,SAAA,GAAAA,KAAK,CAAEqV,WAA3B;;AACA,QAAIA,WAAJ,EAAiB;AACb,WAAKC,YAAL,GAAoBD,WAApB;AACH;AACJ;;AAEDlnB,EAAAA,OAAO;AACH,UAAMkL,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,QAAI,KAAKoP,kBAAT,EAA6B;AACzB1b,MAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAK6a,kBAAtB;AACA,WAAKA,kBAAL,GAA0BzmB,SAA1B;AACH;;AAED,QAAI,KAAKinB,oBAAT,EAA+B;AAC3B,WAAKA,oBAAL,CAA0BpnB,OAA1B;;AACA,aAAO,KAAKonB,oBAAZ;AACA,aAAO,KAAKD,YAAZ;AACH;;AAED,SAAKrV,QAAL,CAAcwL,cAAd,CAA6B+J,WAA7B,CAAyC,KAAKxO,QAA9C;;AAEA3N,IAAAA,GAAG,CAACN,QAAJ,CAAamJ,mBAAb,CACI3Q,4BADJ,EAEI,KAAK6jB,eAFT;;AAKA,SAAKvE,QAAL,CAAc1iB,OAAd;;AAEA,WAAO,KAAKsnB,WAAZ;AACH;;AAEDrlB,EAAAA,aAAa,CACTpC,OADS,EAETgS,KAFS;;;AAIT,QAAI7Q,sCAAJ,EAAa;;AAIb,UAAMe,OAAO,GAAG,IAAIlF,OAAJ,CACZ,KAAKiV,QADO,EAEZjS,OAFY,EAGZ,KAAK0nB,iBAHO,EAIZ1V,KAJY,CAAhB;;AAOA,QACI7I,GAAG,CAACI,YAAJ,CACIvJ,OADJ,EAEI,MAAA,KAAKiS,QAAL,CAAcwL,cAAd,CAA6BkK,iBAA7B,EAAA,UAAA,iBAAA,KAAA,GAAoD,IAFxD,CADJ,EAKE;AACE,WAAKV,SAAL,CAAe/kB,OAAf;AACH;;AAED,WAAOA,OAAP;AACH;;AAED0jB,EAAAA,UAAU,CAAC5lB,OAAD;AACN,SACI,IAAIkB,CAAC,GAAuBlB,OADhC,EAEIkB,CAFJ,EAGIA,CAAC,GAAGiI,GAAG,CAACG,gBAAJ,CAAqBpI,CAArB,CAHR,EAIE;AACE,YAAMI,gBAAgB,GAAGxB,mBAAmB,CAAC,KAAKmS,QAAN,EAAgB/Q,CAAhB,CAA5C;;AAEA,UAAII,gBAAgB,IAAIA,gBAAgB,CAACY,OAAzC,EAAkD;AAC9C,eAAOZ,gBAAgB,CAACY,OAAjB,CAAyB0jB,UAAzB,EAAP;AACH;AACJ;;AAED,WAAOtlB,SAAP;AACH;;AAEDsnB,EAAAA,KAAK;AACD,SAAKC,SAAL,GAAiB,IAAjB;;AAEA,QAAI,KAAKd,kBAAT,EAA6B;AACzB,WAAKpP,IAAL,GAAYzL,YAAZ,CAAyB,KAAK6a,kBAA9B;;AACA,WAAKA,kBAAL,GAA0BzmB,SAA1B;AACH;AACJ;;AAEDwnB,EAAAA,MAAM,CAACC,OAAD;AACF,SAAKF,SAAL,GAAiB,KAAjB;;AAEA,QAAIE,OAAJ,EAAa;AACT,WAAKf,qBAAL;AACH;AACJ;AA2CD;;;;;AAGQC,EAAAA,SAAS,CAAC/kB,OAAD;AACb,UAAM8lB,UAAU,GAAG,KAAKP,WAAxB;;AACA,QAAIO,UAAU,KAAK9lB,OAAnB,EAA4B;AACxB,WAAK+lB,UAAL,GAAkB,IAAlB;AACAD,MAAAA,UAAU,SAAV,IAAAA,UAAU,WAAV,SAAA,GAAAA,UAAU,CAAEtC,SAAZ,CAAsB,KAAtB,CAAA;AACAxjB,MAAAA,OAAO,CAACwjB,SAAR,CAAkB,IAAlB;AACA,WAAK+B,WAAL,GAAmBvlB,OAAnB;AACH;AACJ;AAED;;;;;AAGQglB,EAAAA,WAAW;;;AACf,SAAKe,UAAL,GAAkB,KAAlB;AACA,UAAA,KAAKR,WAAL,UAAA,iBAAA,SAAA,MAAkB/B,UAAU,MAA5B;AACA,SAAK+B,WAAL,GAAmBnnB,SAAnB;AACH;;AAEO0mB,EAAAA,qBAAqB,CAAChM,KAAD;AACzB,QAAI,KAAK6M,SAAL,IAAkB,KAAKK,iBAA3B,EAA8C;AAC1C;AACH;;AAED,UAAMC,YAAY,GAAG;AACjB,WAAKpB,kBAAL,GAA0BzmB,SAA1B;;AACA,YAAM8nB,WAAW,GACb,KAAKnW,QAAL,CAAcwL,cAAd,CAA6B4K,qBAA7B,EADJ;;AAGA,UACI,CAACrN,KAAD,KACC,KAAKkN,iBAAL,IACG,CAAC,KAAKD,UADT,IAEIG,WAAW,IAAI,CAACjM,aAAa,CAACiM,WAAD,CAHlC,CADJ,EAKE;AACE;AACH;;AAED,YAAMJ,UAAU,GAAG,KAAKP,WAAxB;AACA,UAAIa,QAAQ,GAAG,KAAf;;AAEA,UAAIN,UAAJ,EAAgB;AACZ,YACII,WAAW,IACXJ,UAAU,CAACxB,sBAAX,CAAkC4B,WAAlC,CAFJ,EAGE;AACE;AACH;;AAED,YAAIJ,UAAU,CAACvC,QAAX,KAAwBjlB,iBAAA,CAAwB3C,MAApD,EAA4D;AACxDyqB,UAAAA,QAAQ,GAAG,IAAX;AACH,SAFD,MAEO;AACH,gBAAMC,iBAAiB,GAAGP,UAAU,CAAC5V,UAAX,EAA1B;AACA,gBAAMtC,EAAE,GAAGkY,UAAU,CAAC3F,aAAX,EAAX;;AAEA,cACIvS,EAAE,KACD,EAACyY,iBAAiB,SAAjB,IAAAA,iBAAiB,WAAjB,SAAA,GAAAA,iBAAiB,CAAEhS,aAAnB,CACE,IAAIxR,qBAAJ,CAA0B;AACtByR,YAAAA,EAAE,EAAE,SADkB;AAEtBC,YAAAA,KAAK,EAAE8R,iBAFe;AAGtB7R,YAAAA,IAAI,EAAE5G;AAHgB,WAA1B,CADF,CAAD,KAOG,KAAKmC,QAAL,CAAcwL,cAAd,CAA6B8E,KAA7B,CAAmCzS,EAAnC,CARF,CADN,EAUE;AACE;AACH;AACJ;AACJ;;AAED,WAAKoX,WAAL;;AAEA,UAAIoB,QAAJ,EAAc;AACV;AACH;;AAED,WAAKJ,iBAAL,GAAyB,IAAzB;AAGA;;AACA,UAAI,CAAC,MAAM,KAAKrF,QAAL,CAAcV,cAAd,CAA6B,IAA7B,CAAP,MAA+C,KAAnD,EAA0D;AACtD,cAAM,KAAKU,QAAL,CAAcL,UAAd,CAAyB,IAAzB,CAAN;AACH;;AAED,WAAK0F,iBAAL,GAAyB,KAAzB;AACH,KA9DD;;AAgEA,QAAIlN,KAAJ,EAAW;AACPmN,MAAAA,YAAY;AACf,KAFD,MAEO;AACH,WAAKpB,kBAAL,GAA0B,KAAKpP,IAAL,GAAYjK,UAAZ,CAAuBya,YAAvB,EAAqC,GAArC,CAA1B;AACH;AACJ;;AAEgB,SAAVtE,UAAU,CACb9jB,OADa,EAEbC,OAFa;;;AAIb,QAAI4B,IAAJ;;AAEA,SACI,IAAIV,CAAC,GAAuBlB,OADhC,EAEIkB,CAFJ,EAGIA,CAAC,GAAGiI,GAAG,CAACG,gBAAJ,CAAqBpI,CAArB,CAHR,EAIE;AACE,YAAMI,gBAAgB,GAAGxB,mBAAmB,CAACC,OAAD,EAAUmB,CAAV,CAA5C;;AAEA,UAAII,gBAAJ,EAAsB;AAClB,YAAI,CAACM,IAAL,EAAW;AACPA,UAAAA,IAAI,GAAGN,gBAAgB,CAACM,IAAxB;AACH;;AAED,cAAMM,OAAO,GAAGZ,gBAAgB,CAACY,OAAjC;;AAEA,YAAIA,OAAJ,EAAa;AACT,iBAAOA,OAAP;AACH;AACJ;AACJ;;AAED,UAAMsmB,UAAU,GAAGzoB,OAAO,CAACmC,OAAR,IAAoBnC,OAAO,CAACmC,OAA/C;;AAEA,QAAIsmB,UAAJ,EAAgB;AACZ,UAAIA,UAAU,CAACjB,oBAAf,EAAqC;AACjC,eAAOiB,UAAU,CAACjB,oBAAlB;AACH;;AAED,YAAMkB,gBAAgB,GAAGD,UAAU,CAAClB,YAApC;;AAEA,UAAI1lB,IAAI,IAAI,CAAC4mB,UAAU,CAACjB,oBAApB,IAA4CkB,gBAAhD,EAAkE;AAC9D,cAAMjX,IAAI,GAAG,MAAAxR,OAAO,CAACiJ,aAAR,UAAA,iBAAA,SAAA,MAAuBuI,IAApC;;AAEA,YAAIA,IAAJ,EAAU;AACNgX,UAAAA,UAAU,CAACjB,oBAAX,GAAkC,IAAIvqB,OAAJ,CAC9B+C,OAD8B,EAE9ByR,IAF8B,EAG7BzR,OAAO,CAACmC,OAAR,CAA+BwlB,iBAHF,EAI9Be,gBAJ8B,CAAlC;AAMH;AACJ;;AAED,aAAOD,UAAU,CAACjB,oBAAlB;AACH;;AAED,WAAOjnB,SAAP;AACH;;AAUgB,SAAVooB,UAAU,CAAChO,QAAD;AACb,WAAQA,QAAuB,CAACmI,QAAhC;AACH;;AAEuB,SAAjB8F,iBAAiB,CAACjO,QAAD;AACnBA,IAAAA,QAAuB,CAACsM,qBAAxB,CAA8C,IAA9C;AACJ;;;;ACvhCL;;;;MAOsB4B;AAAtBtkB,EAAAA;AAIY,mBAAA,GAAiD,EAAjD;AAwDX;;AAtDGnE,EAAAA,OAAO;AACH,SAAK0oB,UAAL,GAAkB,EAAlB;AACA,WAAO,KAAKC,IAAZ;AACH;;AAED3B,EAAAA,SAAS,CAACvhB,QAAD;AACL,UAAMmjB,SAAS,GAAG,KAAKF,UAAvB;AACA,UAAM9D,KAAK,GAAGgE,SAAS,CAACC,OAAV,CAAkBpjB,QAAlB,CAAd;;AAEA,QAAImf,KAAK,GAAG,CAAZ,EAAe;AACXgE,MAAAA,SAAS,CAAC7b,IAAV,CAAetH,QAAf;AACH;AACJ;;AAEDqjB,EAAAA,cAAc,CAACrjB,QAAD;AACV,UAAMmjB,SAAS,GAAG,KAAKF,UAAvB;AACA,UAAM9D,KAAK,GAAGgE,SAAS,CAACC,OAAV,CAAkBpjB,QAAlB,CAAd;;AAEA,QAAImf,KAAK,IAAI,CAAb,EAAgB;AACZgE,MAAAA,SAAS,CAACzF,MAAV,CAAiByB,KAAjB,EAAwB,CAAxB;AACH;;AAEDgE,IAAAA,SAAS,CAAC7G,OAAV,CAAkBtc,QAAlB;AACH;;AAED4hB,EAAAA,WAAW,CAAC5hB,QAAD;AACP,UAAMmf,KAAK,GAAG,KAAK8D,UAAL,CAAgBG,OAAhB,CAAwBpjB,QAAxB,CAAd;;AAEA,QAAImf,KAAK,IAAI,CAAb,EAAgB;AACZ,WAAK8D,UAAL,CAAgBvF,MAAhB,CAAuByB,KAAvB,EAA8B,CAA9B;AACH;AACJ;;AAESmE,EAAAA,MAAM,CAACC,GAAD,EAAS3kB,MAAT;AACZ,QAAI,KAAKskB,IAAL,KAAcK,GAAlB,EAAuB;AACnB;AACH;;AAED,SAAKL,IAAL,GAAYK,GAAZ;;AAEA,SAAKC,cAAL,CAAoBD,GAApB,EAAyB3kB,MAAzB;AACH;;AAES6kB,EAAAA,MAAM;AACZ,WAAO,KAAKP,IAAZ;AACH;;AAESQ,EAAAA,OAAO,CAACH,GAAD,EAAS3kB,MAAT;AACb,SAAK4kB,cAAL,CAAoBD,GAApB,EAAyB3kB,MAAzB;AACH;;AAEO4kB,EAAAA,cAAc,CAACD,GAAD,EAAS3kB,MAAT;AAClB,SAAKqkB,UAAL,CAAgBnJ,OAAhB,CAAyB9Z,QAAD,IAAcA,QAAQ,CAACujB,GAAD,EAAM3kB,MAAN,CAA9C;AACH;;;;AClEL;;;;AAwBA,MAAM+kB,mBAAmB,GAAG,IAA5B;AACA,MAAMC,YAAY,GAAG,IAArB;AAEA,MAAMC,WAAW,GAAG,IAApB;AAEA,MAAMC,2BAA2B,GAAsC;AACnEC,EAAAA,SAAS,EAAE,CADwD;AAEnEC,EAAAA,YAAY,EAAE,CAFqD;AAGnEC,EAAAA,KAAK,EAAE,CAH4D;AAInEC,EAAAA,UAAU,EAAE,CAJuD;AAKnEC,EAAAA,qBAAqB,EAAE,CAL4C;AAMnEC,EAAAA,IAAI,EAAE;AAN6D,CAAvE;;AAyBA,MAAMC,sBAAN,SAAqCnI,eAArC;AAIIxd,EAAAA,YACIvE,SACAmC,SACAgoB;AAEA;AACA,SAAKlI,QAAL,GAAgB9f,OAAhB;AACA,SAAKioB,aAAL,GAAqBD,WAArB;AACH;;AAEDjI,EAAAA,SAAS,CAAC/f,OAAD;AACL,WAAOA,OAAO,CAACkoB,UAAR,KAAuB,KAAKpI,QAAL,CAAcoI,UAA5C;AACH;;AAEmB,QAAdjI,cAAc;AAChB,UAAMnV,IAAI,GAAyC,EAC/C,GAAG,KAAKgV,QADuC;AAE/CqI,MAAAA,KAAK,EAAE;AAFwC,KAAnD;AAKA,WAAO,KAAKF,aAAL,CACFG,gBADE,CACeC,gCADf,EACiDvd,IADjD,EAEFwd,IAFE,CAEI3O,KAAD,IAAW,CAAC,CAACA,KAFhB,CAAP;AAGH;;AAEe,QAAV2G,UAAU;AACZ,UAAMxV,IAAI,GAAyC,EAC/C,GAAG,KAAKgV,QADuC;AAE/CqI,MAAAA,KAAK,EAAE;AAFwC,KAAnD;AAKA,WAAO,KAAKF,aAAL,CACFG,gBADE,CACeC,gCADf,EACiDvd,IADjD,EAEFwd,IAFE,CAEI3O,KAAD,IAAW,CAAC,CAACA,KAFhB,CAAP;AAGH;;;;AAGL,MAAM4O,+BAAN,SAA8C/H,wBAA9C;AAMIpe,EAAAA,YACIvE,SACA4iB,SACA+H;AAEA,UAAM3qB,OAAN,EAAe4iB,OAAf;AACA,SAAKwH,aAAL,GAAqBO,YAArB;AACH;;AAEDxI,EAAAA,OAAO,CAAChgB,OAAD;AACH,QAAImhB,IAAJ;;AAEA,SAAK,IAAI1S,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKkS,QAAL,CAAc3f,MAAlC,EAA0CyN,CAAC,EAA3C,EAA+C;AAC3C,UAAI,KAAKkS,QAAL,CAAclS,CAAd,EAAiBsR,SAAjB,CAA2B/f,OAA3B,CAAJ,EAAyC;AACrCmhB,QAAAA,IAAI,GAAG,KAAKR,QAAL,CAAclS,CAAd,CAAP;;AACA,aAAKkS,QAAL,CAAcS,MAAd,CAAqB3S,CAArB,EAAwB,CAAxB;;AACA;AACH;AACJ;;AAED,QAAI,CAAC0S,IAAL,EAAW;AACPA,MAAAA,IAAI,GAAG,IAAI4G,sBAAJ,CACH,KAAKhY,QADF,EAEH/P,OAFG,EAGH,KAAKioB,aAHF,CAAP;AAKH;;AAED,SAAKtH,QAAL,CAAcX,OAAd,CAAsBmB,IAAtB;;AAEA,SAAKR,QAAL,CAAcS,MAAd,CAAqB,EAArB,EAAyB,KAAKT,QAAL,CAAc3f,MAAd,GAAuB,EAAhD;AACH;;AAEmB,QAAdif,cAAc;AAChB,SAAK,MAAMxR,CAAX,IAAgB,KAAKkS,QAArB,EAA+B;AAC3B,UAAI,MAAMlS,CAAC,CAACwR,cAAF,EAAV,EAA8B;AAC1B,eAAO,IAAP;AACH;AACJ;;AAED,WAAO,KAAP;AACH;;AAEe,QAAVK,UAAU;AACZ,SAAK,MAAM7R,CAAX,IAAgB,KAAKkS,QAArB,EAA+B;AAC3B,UAAI,MAAMlS,CAAC,CAAC6R,UAAF,EAAV,EAA0B;AACtB,eAAO,IAAP;AACH;AACJ;;AAED,WAAO,KAAP;AACH;;;;AAGL,MAAemI,sBAAf;AAqBIrmB,EAAAA,YACIvE,SACA6qB,UACAC,cACAhP,OACAiP,SACAC,QACAC,UACAC;AAbI,oBAAA,GAAyC,EAAzC;AACA,gBAAA,GAAU,KAAV;AACA,0BAAA,GAAoB,KAApB;AACA,mBAAA,GAAa,CAAb;AAYJ,SAAKlrB,OAAL,GAAeA,OAAf;AACA,SAAK0W,KAAL,GAAamU,QAAb;AACA,SAAKM,OAAL,GAAe9Z,YAAY,CAACwZ,QAAQ,EAAT,CAA3B;AACA,SAAKpjB,EAAL,GAAU4I,MAAM,CAACwa,QAAQ,EAAT,CAAhB;AACA,SAAKO,SAAL,GAAiBtP,KAAjB;AACA,SAAKuP,aAAL,GAAqBP,YAArB;AACA,SAAKQ,OAAL,GAAeN,MAAM,IAAI;AAAE,OAAC,KAAKG,OAAN,GAAgB;AAAlB,KAAzB;AACA,SAAKF,QAAL,GAAgBA,QAAhB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKH,OAAL,GAAeA,OAAf;AACA,SAAKQ,QAAL,GAAgB,KAAKzZ,UAAU,CAAC+Y,QAAD,CAAf,EAA8B,CAACnI,OAAD,EAAU8I,MAAV;AAC1C,WAAKC,QAAL,GAAgB/I,OAAhB;AACA,WAAKgJ,OAAL,GAAeF,MAAf;AACH,KAHe,CAAhB;AAIH;;AAESG,EAAAA,UAAU,CAACb,YAAD;AAChB,WAAO,KAAKG,QAAL,KAAkBvB,WAAlB,GACD,KAAKwB,MAAL,GACI;AAAE,OAACxB,WAAD,GAAe;AAAEkC,QAAAA,IAAI,EAAE,KAAKV;AAAb;AAAjB,KADJ,GAEI,IAHH,GAID,KAAKD,QAAL,GACAH,YAAY,CAAC,KAAKG,QAAN,CAAZ,GACI;AACI,OAAC,KAAKA,QAAN,GAAiB;AACbW,QAAAA,IAAI,EAAEd,YAAY,CAAC,KAAKG,QAAN,CAAZ,CAA4BW;AADrB;AADrB,KADJ,GAMI,IAPJ,GAQAjqB,MAAM,CAACC,IAAP,CAAYkpB,YAAZ,EAA0B3nB,MAA1B,KAAqC,CAArC,IAA0C,KAAK+nB,MAA/C,GACA;AAAE,OAACxB,WAAD,GAAe;AAAEkC,QAAAA,IAAI,EAAE,KAAKV;AAAb;AAAjB,KADA,GAEAvpB,MAAM,CAACC,IAAP,CAAYkpB,YAAZ,EAA0B3nB,MAA1B,GAAmC,CAAnC,GACA2nB,YADA,GAEA,IAhBN;AAiBH;;AAEDe,EAAAA,KAAK,CACDC,YADC;AAKD,UAAMC,OAAO,GAAG,KAAKJ,UAAL,CAAgB,KAAKN,aAArB,CAAhB;AACA,UAAML,MAAM,GAA4B,EAAE,GAAG,KAAKM;AAAV,KAAxC;;AAEA,QAAIS,OAAJ,EAAa;AACT,WAAK,MAAMtkB,EAAX,IAAiB9F,MAAM,CAACC,IAAP,CAAYmqB,OAAZ,CAAjB,EAAuC;AACnCf,QAAAA,MAAM,CAACvjB,EAAD,CAAN,GAAa,IAAb;AACH;AACJ;;AAED,UAAMwF,IAAI,GAA2C;AACjD+e,MAAAA,WAAW,EAAE,KAAKvkB,EAD+B;AAEjDjD,MAAAA,IAAI,EAAE,KAAKA,IAFsC;AAGjDynB,MAAAA,UAAU,EAAE,KAHqC;AAIjDC,MAAAA,SAAS,EAAElb,IAAI,CAACC,GAAL,EAJsC;AAKjDyF,MAAAA,KAAK,EAAE,KAAKyU,OALqC;AAMjDgB,MAAAA,MAAM,EAAEnB,MANyC;AAOjDD,MAAAA,OAAO,EAAE,KAAKA,OAPmC;AAQjDK,MAAAA,SAAS,EAAE,KAAKA;AARiC,KAArD;;AAWA,QAAI,KAAKH,QAAT,EAAmB;AACfhe,MAAAA,IAAI,CAACR,MAAL,GAAc,KAAKwe,QAAnB;AACH;;AAED,QAAIa,YAAJ,EAAkB;AACd,WAAKM,iBAAL,GAAyB,IAAzB;AAEAN,MAAAA,YAAY,CAAC7e,IAAD,CAAZ,CAAmBwd,IAAnB,CAAyB3O,KAAD;AACpB,aAAKsQ,iBAAL,GAAyB,KAAzB;;AAEA,YAAItQ,KAAK,KAAKvb,SAAd,EAAyB;AACrB,cAAI,CAAC,KAAK8rB,OAAV,EAAmB;AACf,iBAAKA,OAAL,GAAevQ,KAAf;AACH;AACJ;;AAED,YAAI,KAAKuQ,OAAL,IAAgB,KAAKC,UAAL,KAAoB,CAAxC,EAA2C;AACvC,eAAKC,GAAL;AACH;AACJ,OAZD;AAaH;;AAED,QAAIR,OAAJ,EAAa;AACT,WAAK,MAAMtkB,EAAX,IAAiB9F,MAAM,CAACC,IAAP,CAAYmqB,OAAZ,CAAjB,EAAuC;AACnC,YAAI,EAAEtkB,EAAE,IAAI,KAAK6jB,OAAb,CAAJ,EAA2B;AACvB,eAAKkB,KAAL,CAAWT,OAAO,CAACtkB,EAAD,CAAP,CAAYmkB,IAAvB,EAA6BnkB,EAA7B,EAAiCwF,IAAjC;AACH;AACJ;AACJ;;AAED,QAAI,KAAKqf,UAAL,KAAoB,CAApB,IAAyB,CAAC,KAAKF,iBAAnC,EAAsD;AAClD,WAAKG,GAAL;AACH;;AAED,WAAO,KAAKhB,QAAZ;AACH;;AAEOiB,EAAAA,KAAK,CACTZ,IADS,EAETX,QAFS,EAGThe,IAHS;AAKT,QAAI,KAAKwf,WAAL,CAAiBxB,QAAjB,MAA+B1qB,SAAnC,EAA8C;AAC1C,WAAKksB,WAAL,CAAiBxB,QAAjB,IAA6B,IAA7B;AACA,WAAKqB,UAAL;AACAV,MAAAA,IAAI,CAAC3e,IAAD,CAAJ;AACH;AACJ;;AAEDsf,EAAAA,GAAG,CAACjrB,KAAD;AACC,QAAI,KAAKorB,OAAT,EAAkB;AACd;AACH;;AAED,SAAKA,OAAL,GAAe,IAAf;;AAEA,QAAI,KAAKL,OAAL,KAAiB9rB,SAAjB,IAA8Be,KAAlC,EAAyC;AACrC,UAAI,KAAKoqB,OAAT,EAAkB;AACd,aAAKA,OAAL,CAAapqB,KAAb;AACH;AACJ,KAJD,MAIO,IAAI,KAAKmqB,QAAT,EAAmB;AACtB,WAAKA,QAAL,CAAc,KAAKY,OAAnB;AACH;AACJ;;AAEDM,EAAAA,UAAU,CAAC1f,IAAD;AACN,UAAMof,OAAO,GAAGpf,IAAI,CAACof,OAArB;;AAEA,QAAIA,OAAO,KAAK9rB,SAAZ,IAAyB,CAAC,KAAK8rB,OAAnC,EAA4C;AACxC,WAAKA,OAAL,GAAeA,OAAf;AACH;;AAED,UAAMO,YAAY,GACd3f,IAAI,CAACR,MAAL,KAAgBid,WAAhB,GAA8BA,WAA9B,GAA4Czc,IAAI,CAACyJ,KADrD;;AAGA,QAAI,KAAK+V,WAAL,CAAiBG,YAAjB,CAAJ,EAAoC;AAChC,WAAKH,WAAL,CAAiBG,YAAjB,IAAiC,KAAjC;AACA,WAAKN,UAAL;;AAEA,UACI,KAAKD,OAAL,IACC,KAAKC,UAAL,KAAoB,CAApB,IAAyB,CAAC,KAAKF,iBAFpC,EAGE;AACE,aAAKG,GAAL;AACH;AACJ;AACJ;;;;AAyCL,MAAMM,oBAAN,SAAmCjC,sBAAnC;AAAArmB,EAAAA;;AAII,aAAA,GAAOolB,2BAA2B,CAACC,SAAnC;AAcH;;AAZuB,SAAbkD,aAAa;AAChB,WAAO,KAAP;AACH;;AAEwB,eAAZC,YAAY,CACrB/sB,OADqB;AAGrB,WAAO;AACH4mB,MAAAA,wBAAwB,EACpB5mB,OAAO,CAACwd,kBAAR,CAA2BoJ,wBAA3B;AAFD,KAAP;AAIH;;;;AAoBL,MAAMoG,uBAAN,SAAsCpC,sBAAtC;AAAArmB,EAAAA;;AAII,aAAA,GAAOolB,2BAA2B,CAACE,YAAnC;AAqCH;;AAnC2B,SAAjBoD,iBAAiB;AACpB,WAAO,IAAP;AACH;;AAEmB,SAAbH,aAAa,CAChB9sB,OADgB,EAEhBiN,IAFgB,EAGhB4d,QAHgB;AAKhB,UAAM9a,EAAE,GAAGmd,qBAAqB,CAACC,WAAtB,CACPntB,OADO,EAEP6qB,QAFO,EAGP5d,IAAI,CAACme,SAHE,CAAX;AAKA,WAAO,CAACrb,EAAD,IAAO,CAAC/P,OAAO,CAAC2C,SAAR,CAAkB0T,WAAlB,CAA8BtG,EAA9B,CAAf;AACH;;AAEwB,eAAZgd,YAAY,CACrB/sB,OADqB,EAErBiN,IAFqB,EAGrB4d,QAHqB,EAIrBM,OAJqB,EAKrBR,YALqB,EAMrByC,aANqB;AAQrB,UAAMrd,EAAE,GAAGmd,qBAAqB,CAACC,WAAtB,CACPntB,OADO,EAEP6qB,QAFO,EAGP5d,IAAI,CAACme,SAHE,CAAX;AAKA,WACK,CAAC,CAACrb,EAAF,IAAQ/P,OAAO,CAAC0d,cAAR,CAAuB8E,KAAvB,CAA6BzS,EAA7B,EAAiC,IAAjC,CAAT,IACA,CAAC,EAAE,MAAMqd,aAAR,CAFL;AAIH;;;;AAGL,MAAMC,iBAAiB,GAOnB;AACAC,EAAAA,OAAO,EAAE,CADT;AAEAC,EAAAA,OAAO,EAAE,CAFT;AAGAC,EAAAA,QAAQ,EAAE,CAHV;AAIAC,EAAAA,UAAU,EAAE,CAJZ;AAKAC,EAAAA,kBAAkB,EAAE,CALpB;AAMAC,EAAAA,OAAO,EAAE;AANT,CAPJ;;AAoCA,MAAMC,gBAAN,SAA+BhD,sBAA/B;AAAArmB,EAAAA;;AAII,aAAA,GAAOolB,2BAA2B,CAACG,KAAnC;AAgPH;;AA9O2B,SAAjBmD,iBAAiB,CACpBjtB,OADoB,EAEpBiN,IAFoB;AAIpB,WACIA,IAAI,CAAC4gB,KAAL,KAAeR,iBAAiB,CAACI,UAAjC,IACAxgB,IAAI,CAAC4gB,KAAL,KAAeR,iBAAiB,CAACK,kBAFrC;AAIH;;AAEwB,eAAZX,YAAY,CACrB/sB,OADqB,EAErBiN,IAFqB,EAGrB4d,QAHqB,EAIrBM,OAJqB,EAKrBR,YALqB,EAMrByC,aANqB,EAOrBU,cAPqB;AASrB,UAAM5B,SAAS,GAAGjf,IAAI,CAACif,SAAvB;AACA,UAAMd,SAAS,GAAGne,IAAI,CAACme,SAAvB;;AAEA,QAAIc,SAAS,IAAId,SAAjB,EAA4B;AACxB,cAAQA,SAAS,CAACyC,KAAlB;AACI,aAAKR,iBAAiB,CAACC,OAAvB;AACI,iBAAOM,gBAAgB,CAACG,oBAAjB,CACH/tB,OADG,EAEHksB,SAFG,EAGHd,SAHG,EAIHT,YAJG,EAKHmD,cALG,CAAP;;AAOJ,aAAKT,iBAAiB,CAACE,OAAvB;AACI,iBAAOK,gBAAgB,CAACI,oBAAjB,CACHhuB,OADG,EAEHksB,SAFG,EAGHd,SAHG,EAIHT,YAAY,CAACpf,GAJV,CAAP;;AAMJ,aAAK8hB,iBAAiB,CAACG,QAAvB;AACI,iBAAOI,gBAAgB,CAACK,qBAAjB,CACHjuB,OADG,EAEHorB,SAFG,CAAP;;AAIJ,aAAKiC,iBAAiB,CAACI,UAAvB;AACI,iBAAOG,gBAAgB,CAACM,uBAAjB,CACHluB,OADG,EAEHorB,SAFG,EAGHT,YAHG,EAIHyC,aAJG,CAAP;;AAMJ,aAAKC,iBAAiB,CAACK,kBAAvB;AACI,iBAAOE,gBAAgB,CAACO,+BAAjB,CACHnuB,OADG,EAEH2qB,YAAY,CAACpf,GAFV,EAGH6f,SAAS,CAACxE,wBAHP,CAAP;;AAKJ,aAAKyG,iBAAiB,CAACM,OAAvB;AACI,iBAAOC,gBAAgB,CAACQ,oBAAjB,CACHpuB,OADG,EAEH2qB,YAAY,CAACpf,GAFV,EAGH6f,SAAS,CAACloB,OAHP,CAAP;AAnCR;AAyCH;;AAED,WAAO,IAAP;AACH;;AAEmB,SAAbgQ,aAAa,CAChBlT,OADgB,EAEhBorB,SAFgB;AAIhB,WAAOA,SAAS,CAACja,GAAV,GACD,IAAIkd,kBAAJ,CACIruB,OADJ,EAEIorB,SAAS,CAACja,GAFd,EAGIia,SAAS,CAACkD,QAHd,EAIIlD,SAAS,CAAC3jB,EAJd,EAKI2jB,SAAS,CAACxI,OALd,EAMIwI,SAAS,CAACmD,YANd,EAOInD,SAAS,CAACoD,eAPd,CADC,GAUD,IAVN;AAWH;;AAEwC,eAApBT,oBAAoB,CACrC/tB,OADqC,EAErCksB,SAFqC,EAGrCd,SAHqC,EAIrCT,YAJqC,EAKrCmD,cALqC;AAOrC,UAAM7tB,OAAO,GAAG2tB,gBAAgB,CAAC1a,aAAjB,CAA+BlT,OAA/B,EAAwCorB,SAAxC,CAAhB;;AAEA,QAAIA,SAAS,IAAIA,SAAS,CAACkD,QAAvB,IAAmCruB,OAAvC,EAAgD;AAC5C0qB,MAAAA,YAAY,CAACpf,GAAb,CAAiBkjB,UAAjB,GAA8BrD,SAAS,CAACkD,QAAxC;AACA3D,MAAAA,YAAY,CAACpf,GAAb,CAAiBmjB,mBAAjB,GAAuCxC,SAAvC;;AAEA,UAAI,CAAC4B,cAAD,IAAmB1C,SAAS,CAACxI,OAA7B,IAAwCwI,SAAS,CAACf,UAAtD,EAAkE;AAC9D,cAAM5B,UAAU,GAAGzoB,OAAO,CAACmC,OAA3B;;AAEA,YAAIsmB,UAAJ,EAAgB;AACZ,gBAAMkG,OAAO,GAAG9K,UAAU,CAAC8E,UAAX,CAAsBF,UAAtB,CAAhB;AAEA,gBAAMtmB,OAAO,GAAuB;AAChCmsB,YAAAA,QAAQ,EAAElD,SAAS,CAACkD,QADY;AAEhCjE,YAAAA,UAAU,EAAEe,SAAS,CAACf,UAFU;AAGhCzH,YAAAA,OAAO,EAAEwI,SAAS,CAACxI;AAHa,WAApC;AAMA,gBAAMgM,WAAW,GAAGD,OAAO,CAAC3K,IAAR,CAChBoH,SAAS,CAACxI,OADM,EAEhB,MACI,IAAI8H,+BAAJ,CACI1qB,OADJ,EAEImC,OAAO,CAACygB,OAFZ,EAGI+H,YAHJ,CAHY,CAApB;AAUAiE,UAAAA,WAAW,CAACzM,OAAZ,CAAoBhgB,OAApB;AACH;AACJ;;AAED0sB,MAAAA,8BAA8B,CAAC1F,MAA/B;AAEInpB,MAAAA,OAAO,CAAC8uB,WAAR,CAAqBpR,cAFzB,EAGIzd,OAHJ,EAII;AACI8uB,QAAAA,yBAAyB,EACrB3D,SAAS,CAAC2D;AAFlB,OAJJ;AASH;;AAED,WAAO,IAAP;AACH;;AAEwC,eAApBf,oBAAoB,CACrChuB,OADqC,EAErCksB,SAFqC,EAGrCd,SAHqC,EAIrCle,OAJqC;AAMrC,QACIke,SAAS,KACRA,SAAS,CAACkD,QAAV,KAAuBphB,OAAO,CAACuhB,UAA/B,IAA6CrD,SAAS,CAACnQ,KAD/C,CAAT,KAEC,CAAC/N,OAAO,CAACwhB,mBAAT,IACGxhB,OAAO,CAACwhB,mBAAR,GAA8BxC,SAHlC,CADJ,EAKE;AACE2C,MAAAA,8BAA8B,CAAC1F,MAA/B;AAEInpB,MAAAA,OAAO,CAAC8uB,WAAR,CAAqBpR,cAFzB,EAGInd,SAHJ,EAII,EAJJ;AAMH;;AAED,WAAO,IAAP;AACH;;AAEyC,eAArB0tB,qBAAqB,CACtCjuB,OADsC,EAEtCorB,SAFsC;AAItC,UAAMvP,IAAI,GAAGuP,SAAS,CAACmD,YAAvB;AACA,UAAMtuB,OAAO,GAAG2tB,gBAAgB,CAAC1a,aAAjB,CAA+BlT,OAA/B,EAAwCorB,SAAxC,CAAhB;;AAEA,QAAIvP,IAAI,IAAI5b,OAAZ,EAAqB;AACjB+uB,MAAAA,+BAA+B,CAACzF,OAAhC;AAEIvpB,MAAAA,OAAO,CAAC8uB,WAAR,CAAqB9sB,eAFzB,EAGI/B,OAHJ,EAII;AAAEgvB,QAAAA,KAAK,EAAE,CAACpT,IAAD,CAAT;AAAiBhX,QAAAA,OAAO,EAAEumB,SAAS,CAACoD;AAApC,OAJJ;AAMH;;AAED,WAAO,IAAP;AACH;;AAE2C,eAAvBN,uBAAuB,CACxCluB,OADwC,EAExCorB,SAFwC,EAGxCT,YAHwC,EAIxCyC,aAJwC;AAMxC,UAAM8B,OAAO,GAAG9D,SAAS,IAAIA,SAAS,CAACkD,QAAvC;;AAEA,QAAIY,OAAJ,EAAa;AACTvE,MAAAA,YAAY,CAACwE,YAAb,CAA0BD,OAA1B;AACH;;AAED,WAAO9B,aAAa,CAAC3C,IAAd,CAAmB;AACtB,UAAIyE,OAAO,KAAKvE,YAAY,CAACpf,GAAb,CAAiBkjB,UAAjC,EAA6C;AACzC,cAAMhG,UAAU,GAAGzoB,OAAO,CAACmC,OAA3B;;AAEA,YAAIsmB,UAAJ,EAAgB;AACZ5E,UAAAA,UAAU,CAAC+E,iBAAX,CAA6BH,UAA7B;AACH;AACJ;;AACD,aAAO,IAAP;AACH,KATM,CAAP;AAUH;;AAEmD,eAA/B0F,+BAA+B,CAChDnuB,OADgD,EAEhDkN,OAFgD,EAGhD0Z,wBAHgD;AAKhD,QACIA,wBAAwB,KAAKrmB,SAA7B,IACAP,OAAO,CAACwd,kBAAR,CAA2BoJ,wBAA3B,OACIA,wBAHR,EAIE;AACE1Z,MAAAA,OAAO,CAACkiB,mCAAR,GAA8C,IAA9C;AACApvB,MAAAA,OAAO,CAACwd,kBAAR,CAA2BC,yBAA3B,CACImJ,wBADJ;AAGA1Z,MAAAA,OAAO,CAACkiB,mCAAR,GAA8C,KAA9C;AACH;;AACD,WAAO,IAAP;AACH;;AAEwC,eAApBhB,oBAAoB,CACrCpuB,OADqC,EAErCkN,OAFqC,EAGrC+E,KAHqC;AAKrC,QAAI/E,OAAO,CAACmiB,gBAAZ,EAA8B;AAC1BniB,MAAAA,OAAO,CAACmiB,gBAAR,CAAyB/nB,IAAzB;AAEItH,MAAAA,OAAO,CAACkD,OAFZ,EAGI+O,KAHJ;AAKH;;AACD,WAAO,IAAP;AACH;;;;AAGL,MAAMib,qBAAN,SAAoCtC,sBAApC;AAAArmB,EAAAA;;AAII,aAAA,GAAOolB,2BAA2B,CAACI,UAAnC;AAuJH;;AArJ2B,SAAjBkD,iBAAiB;AACpB,WAAO,IAAP;AACH;;AAEiB,SAAXE,WAAW,CACdntB,OADc,EAEd6qB,QAFc,EAGd5d,IAHc;AAKd,QAAIhN,OAAJ;;AAEA,QACIgN,IAAI,KACH,CAACA,IAAI,CAACke,OAAN,IAAiBle,IAAI,CAACke,OAAL,KAAiB9Z,YAAY,CAACwZ,QAAQ,EAAT,CAD3C,CADR,EAGE;AACE,UAAI5d,IAAI,CAACxF,EAAT,EAAa;AACTxH,QAAAA,OAAO,GAAGmJ,GAAG,CAAC1B,cAAJ,CAAmBmjB,QAAQ,GAAG7f,QAA9B,EAAwCiC,IAAI,CAACxF,EAA7C,CAAV;;AAEA,YAAIxH,OAAO,IAAIgN,IAAI,CAAC2S,MAApB,EAA4B;AACxB,gBAAMrU,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0BpgB,OAA1B,EAAmCC,OAAnC,CAAZ;;AAEA,cAAI,CAACsL,GAAD,IAAQA,GAAG,CAAC1J,IAAJ,CAASsP,GAAT,KAAiBlE,IAAI,CAAC2S,MAAlC,EAA0C;AACtC,mBAAO,IAAP;AACH;AACJ;AACJ,OAVD,MAUO,IAAI3S,IAAI,CAACkE,GAAT,EAAc;AACjB,cAAMlI,GAAG,GAAGmC,kBAAkB,CAACyf,QAAD,CAAlB,CAA6Bpf,YAA7B,CAA0CwB,IAAI,CAACkE,GAA/C,CAAZ;AACAlR,QAAAA,OAAO,GAAGgJ,GAAG,IAAIA,GAAG,CAACqE,GAAJ,EAAjB;AACH,OAHM,MAGA,IAAIL,IAAI,CAACshB,YAAT,EAAuB;AAC1B;AACAtuB,QAAAA,OAAO,GAAGD,OAAO,CAACgC,eAAR,CAAyBqQ,UAAzB,CACNpF,IAAI,CAACshB,YADC,EAENthB,IAAI,CAACqiB,aAFC,CAAV;AAIH;AACJ;;AAED,WAAOrvB,OAAO,IAAI,IAAlB;AACH;;AAEoB,SAAdsvB,cAAc,CACjBvvB,OADiB,EAEjBC,OAFiB,EAGjB4qB,QAHiB,EAIjB3d,OAJiB,EAKjBohB,QALiB;AAOjB,UAAMnsB,OAAO,GAAG0hB,UAAU,CAACC,UAAX,CAAsB9jB,OAAtB,EAA+BC,OAA/B,CAAhB;AACA,UAAMsL,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0BpgB,OAA1B,EAAmCC,OAAnC,CAAZ;AACA,UAAMsB,gBAAgB,GAAGxB,mBAAmB,CAACC,OAAD,EAAUC,OAAV,CAA5C;AACA,UAAM+C,QAAQ,GAAGzB,gBAAgB,IAAIA,gBAAgB,CAACyB,QAAtD;AAEA,WAAO;AACHmO,MAAAA,GAAG,EAAED,aAAa,CAAC2Z,QAAD,EAAW5qB,OAAX,CADf;AAEHquB,MAAAA,QAFG;AAGH7mB,MAAAA,EAAE,EAAExH,OAAO,CAACwH,EAAR,IAAclH,SAHf;AAIHqiB,MAAAA,OAAO,EAAErX,GAAG,GAAGA,GAAG,CAAC1J,IAAJ,CAASsP,GAAZ,GAAkB5Q,SAJ3B;AAKH8pB,MAAAA,UAAU,EAAEloB,OAAO,GACbqtB,aAAa,CAAC3E,QAAD,EAAW3d,OAAX,EAAoB/K,OAApB,CADA,GAEb5B,SAPH;AAQHguB,MAAAA,YAAY,EAAEvrB,QAAQ,IAAIA,QAAQ,CAACisB,KAArB,IAA8BjsB,QAAQ,CAACisB,KAAT,CAAe,CAAf,CARzC;AASHT,MAAAA,eAAe,EAAExrB,QAAQ,IAAIA,QAAQ,CAAC6B;AATnC,KAAP;AAWH;;AAEwB,eAAZkoB,YAAY,CACrB/sB,OADqB,EAErBiN,IAFqB,EAMrB4d,QANqB,EAOrByD,QAPqB,EAQrB3D,YARqB,EASrByC,aATqB;AAWrB,UAAMhC,SAAS,GAAGne,IAAI,CAACme,SAAvB;AACA,QAAInrB,OAAJ;AACA,QAAIwvB,OAAJ;;AAEA,QAAIrE,SAAS,KAAK7qB,SAAlB,EAA6B;AACzBN,MAAAA,OAAO,GAAGD,OAAO,CAAC0d,cAAR,CAAuBkK,iBAAvB,EAAV;AACH,KAFD,MAEO,IAAIwD,SAAJ,EAAe;AAClBnrB,MAAAA,OAAO,GACHitB,qBAAqB,CAACC,WAAtB,CACIntB,OADJ,EAEI6qB,QAFJ,EAGIO,SAHJ,KAIK7qB,SALT;AAMH;;AAED,QAAI,CAACN,OAAD,IAAYmrB,SAAhB,EAA2B;AACvB,YAAMvP,IAAI,GAAGuP,SAAS,CAACmD,YAAvB;AACA,YAAMxD,OAAO,GAAG9d,IAAI,CAAC8d,OAArB;AACA,YAAMuE,aAAa,GAAGlE,SAAS,CAACkE,aAAhC;;AAEA,UAAIzT,IAAI,IAAIkP,OAAZ,EAAqB;AACjB,cAAM5pB,CAAC,GAGH,MAAM,KAAK2Q,UAAU,CAAC+Y,QAAD,CAAf,EAA4BnI,OAAD;AACjC,cAAIgN,qBAAqB,GAAG,KAA5B;AACA,cAAIC,iBAAiB,GAAG,KAAxB;AACA,cAAIC,UAAU,GAAG,KAAjB;;AAGA5vB,UAAAA,OAAO,CACFgC,eADL,CACsB6tB,WADtB,CAEQhU,IAFR,EAGQkP,OAHR,EAIQuE,aAJR,EAMK7L,MANL,CAMYgH,IANZ,CAMkB3O,KAAD;AACT4T,YAAAA,qBAAqB,GAAG,IAAxB;;AAEA,gBAAI,CAACE,UAAD,KAAgB9T,KAAK,IAAI6T,iBAAzB,CAAJ,EAAiD;AAC7CC,cAAAA,UAAU,GAAG,IAAb;AACAlN,cAAAA,OAAO,CAAC;AAAEziB,gBAAAA,OAAO,EAAE6b;AAAX,eAAD,CAAP;AACH;AACJ,WAbL;AAeAsR,UAAAA,aAAa,CAAC3C,IAAd,CAAoB3O,KAAD;AACf6T,YAAAA,iBAAiB,GAAG,IAApB;;AAEA,gBAAI,CAACC,UAAD,KAAgB9T,KAAK,IAAI4T,qBAAzB,CAAJ,EAAqD;AACjDE,cAAAA,UAAU,GAAG,IAAb;AACAlN,cAAAA,OAAO,CAAC;AAAEoM,gBAAAA,WAAW,EAAEhT;AAAf,eAAD,CAAP;AACH;AACJ,WAPD;AAQH,SA7BS,CAHV;;AAkCA,YAAI3a,CAAC,CAAClB,OAAN,EAAe;AACXA,UAAAA,OAAO,GAAGkB,CAAC,CAAClB,OAAZ;AACH,SAFD,MAEO,IAAIkB,CAAC,CAAC2tB,WAAN,EAAmB;AACtBW,UAAAA,OAAO,GAAGtuB,CAAC,CAAC2tB,WAAZ;AACH;AACJ;AACJ;;AAED,WAAO7uB,OAAO,GACRitB,qBAAqB,CAACqC,cAAtB,CACIvvB,OADJ,EAEIC,OAFJ,EAGI4qB,QAHJ,EAIIF,YAAY,CAACpf,GAJjB,EAKI+iB,QALJ,CADQ,GAQRmB,OARN;AASH;;;;AAaL,MAAMjF,gCAAN,SAA+CI,sBAA/C;AAAArmB,EAAAA;;AAII,aAAA,GAAOolB,2BAA2B,CAACK,qBAAnC;AA4BH;;AA1B4B,eAAZ+C,YAAY,CACrB/sB,OADqB,EAErBiN,IAFqB,EAMrB4d,QANqB,EAOrBM,OAPqB,EAQrBR,YARqB,EASrByC,aATqB;AAWrB,UAAM0C,UAAU,GAAG,MAAM1C,aAAzB;AACA,UAAMvB,KAAK,GAAG,CAACiE,UAAD,IAAe7iB,IAAI,CAACme,SAAlC;AACA,UAAMja,GAAG,GAAG0a,KAAK,IAAIA,KAAK,CAACxB,UAA3B;AACA,UAAMloB,OAAO,GAAGgP,GAAG,IAAIwZ,YAAY,CAACpf,GAAb,CAAiBwkB,YAAjB,CAA8B5e,GAA9B,CAAvB;AACA,UAAMsX,UAAU,GAAGzoB,OAAO,CAACmC,OAA3B;;AAEA,QAAI0pB,KAAK,IAAI1pB,OAAT,IAAoBsmB,UAAxB,EAAoC;AAChC,YAAMkG,OAAO,GAAG9K,UAAU,CAAC8E,UAAX,CAAsBF,UAAtB,CAAhB;AACA,aAAOoD,KAAK,CAACvB,KAAN,GACDqE,OAAO,CAAClM,UAAR,CAAmBtgB,OAAnB,CADC,GAEDwsB,OAAO,CAACvM,cAAR,CAAuBjgB,OAAvB,CAFN;AAGH;;AAED,WAAO,CAAC,CAAC2tB,UAAT;AACH;;;;AAGL,MAAME,eAAN,SAA8BpF,sBAA9B;AAAArmB,EAAAA;;AACI,aAAA,GAAOolB,2BAA2B,CAACM,IAAnC;AASH;;AAPuB,SAAb6C,aAAa;AAChB,WAAO,KAAP;AACH;;AAEwB,eAAZC,YAAY;AACrB,WAAO,IAAP;AACH;;;;AAQL,MAAMkD,uBAAN;AAgBI1rB,EAAAA,YACIvE,SACA6qB,UACA3d;AAhBI,sBAAA,GAA8B,EAA9B;AACA,sBAAA,GAGJ,EAHI;AAMA,yBAAA,GAAmB,KAAnB;AAER,gBAAA,GAAU,KAAV;;AA2RQ,mBAAA,GAAc/L,CAAD;AACjB,UAAIA,CAAC,CAAC8L,IAAF,CAAOyJ,KAAP,KAAiB,KAAKwZ,SAAtB,IAAmC,CAAC,KAAKhe,QAA7C,EAAuD;AACnD;AACH;;;AAGD,YAAMjF,IAAI,GAA+C9L,CAAC,CAAC8L,IAA3D;AACA,UAAIkjB,aAAJ;;AAEA,UACI,CAACljB,IAAD,IACA,EAAEkjB,aAAa,GAAGljB,IAAI,CAAC+e,WAAvB,CADA,IAEA,CAAC/e,IAAI,CAACzI,IAFN,IAGA,CAACyI,IAAI,CAACif,SAHN,IAIA,CAACjf,IAAI,CAACyJ,KAJN,IAKA,CAACzJ,IAAI,CAACkf,MANV,EAOE;AACE;AACH;;AAED,UAAIiE,WAAW,GAAG,KAAK/E,aAAL,CAAmBpe,IAAI,CAACyJ,KAAxB,CAAlB;;AAEA,UAAI,CAAC0Z,WAAD,IAAgBjvB,CAAC,CAACyqB,IAAlB,IAA0B3e,IAAI,CAACyJ,KAAL,KAAe,KAAKwZ,SAAlD,EAA6D;AACzDE,QAAAA,WAAW,GAAG,KAAK/E,aAAL,CAAmBpe,IAAI,CAACyJ,KAAxB,IAAiC;AAAEkV,UAAAA,IAAI,EAAEzqB,CAAC,CAACyqB;AAAV,SAA/C;AACH;;AAED,UAAIwE,WAAJ,EAAiB;AACbA,QAAAA,WAAW,CAAChX,IAAZ,GAAmBpI,IAAI,CAACC,GAAL,EAAnB;AACH;;AAED,UAAIhE,IAAI,CAACgf,UAAT,EAAqB;AACjB,cAAMoE,CAAC,GAAG,KAAKjG,aAAL,CAAmB+F,aAAnB,CAAV;;AAEA,YAAIE,CAAC,IAAIA,CAAC,CAACrE,WAAP,IAAsBqE,CAAC,CAACrE,WAAF,CAAcxnB,IAAd,KAAuByI,IAAI,CAACzI,IAAtD,EAA4D;AACxD6rB,UAAAA,CAAC,CAACrE,WAAF,CAAcW,UAAd,CAAyB1f,IAAzB;AACH;AACJ,OAND,MAMO;AACH,cAAMqjB,WAAW,GAAG,KAAKC,oBAAL,CAA0BtjB,IAAI,CAACzI,IAA/B,CAApB;;AAEA,cAAM4oB,aAAa,GAAG,KAAKoD,kBAAL,CAAwBvjB,IAAxB,CAAtB;;AAEA,YAAIqjB,WAAW,IAAInvB,CAAC,CAACyqB,IAArB,EAA2B;AACvB0E,UAAAA,WAAW,CAACvD,YAAZ,CACI,KAAK7a,QADT,EAEIjF,IAFJ,EAGI,KAAKwjB,MAHT,EAII,KAAKP,SAJT,EAKI,IALJ,EAMI9C,aANJ,EAOI,KAPJ,EAQE3C,IARF,CAQQ9b,CAAD;AACH;AACA,kBAAM+hB,QAAQ,GACV;AACI1E,cAAAA,WAAW,EAAE/e,IAAI,CAAC+e,WADtB;AAEIxnB,cAAAA,IAAI,EAAEyI,IAAI,CAACzI,IAFf;AAGIynB,cAAAA,UAAU,EAAE,IAHhB;AAIIC,cAAAA,SAAS,EAAElb,IAAI,CAACC,GAAL,EAJf;AAKIyF,cAAAA,KAAK,EAAE,KAAKwZ,SALhB;AAMInF,cAAAA,OAAO,EAAE9d,IAAI,CAAC8d,OANlB;AAOIoB,cAAAA,MAAM,EAAE,EAPZ;AAQI1f,cAAAA,MAAM,EACFQ,IAAI,CAACR,MAAL,KAAgBid,WAAhB,GACMA,WADN,GAEMzc,IAAI,CAACyJ,KAXnB;AAYI2V,cAAAA,OAAO,EAAE1d;AAZb,aADJ;AAgBAxN,YAAAA,CAAC,CAACyqB,IAAF,CAAO8E,QAAP;AACH,WA3BD;AA4BH;AACJ;AACJ,KAxEO;;AA0EA,oBAAA,GAAc;AAClB,WAAKC,KAAL;AACH,KAFO;;AA0FA,0BAAA,GAAqBxvB,CAAD;AACxB,UAAIA,CAAC,CAACyvB,MAAF,KAAa,KAAKH,MAAL,EAAjB,EAAgC;AAC5B;AACH;;;AAGD,YAAM7E,IAAI,GAAI3e,IAAD;AACT,YAAI9L,CAAC,CAACyvB,MAAF,IAAYzvB,CAAC,CAACyvB,MAAF,CAASC,WAAzB,EAAsC;AAClC;AACC1vB,UAAAA,CAAC,CAACyvB,MAAF,CAASC,WAAT,CAAkC9vB,IAAI,CAAC8b,SAAL,CAAe5P,IAAf,CAAlC,EAAwD,GAAxD;AACJ;AACJ,OALD;;AAOA,UAAI;AACA,aAAK6jB,UAAL,CAAgB;AACZ7jB,UAAAA,IAAI,EAAElM,IAAI,CAACC,KAAL,CAAWG,CAAC,CAAC8L,IAAb,CADM;AAEZ2e,UAAAA;AAFY,SAAhB;AAIH,OALD,CAKE,OAAOzqB,CAAP,EAAU;AACR;AACH;AACJ,KArBO;;AAtbJ,SAAK+Q,QAAL,GAAgBlS,OAAhB;AACA,SAAKywB,MAAL,GAAc5F,QAAd;AACA,SAAKqF,SAAL,GAAiB7e,YAAY,CAACwZ,QAAQ,EAAT,CAA7B;AACA,SAAKtf,GAAL,GAAW2B,OAAX;AACH;;AAED6jB,EAAAA,KAAK,CACD7F,MADC;AAGD,QAAI,KAAK8F,OAAT,EAAkB;AACd,UAAI5vB,sCAAJ,EAAa;AACTC,QAAAA,OAAO,CAACC,KAAR,CAAc,gCAAd;AACH;AACJ,KAJD,MAIO;AACH,WAAK0vB,OAAL,GAAe,IAAf;AAEA,WAAKC,SAAL,CAAe/F,MAAf;;AAEA,WAAKuF,MAAL,GAAc5c,gBAAd,CAA+B,UAA/B,EAA2C,KAAKqd,WAAhD;;AAEA,WAAKC,KAAL;AACH;;AAED,WAAO,KAAKL,UAAZ;AACH;;AAEDG,EAAAA,SAAS,CACL/F,MADK;AAGL,QAAI,CAAC,KAAK8F,OAAV,EAAmB;AACf,YAAM,IAAI/vB,KAAJ,CAAU,4BAAV,CAAN;AACH;;AAED,SAAKiqB,MAAL,GAAcA,MAAM,IAAI3qB,SAAxB;;AAEA,UAAMmW,KAAK,GAAG,KAAK+Z,MAAL,EAAd;;AAEA,QAAIvF,MAAM,KAAK3qB,SAAf,EAA0B;AACtB,UAAI,CAAC,KAAK6wB,gBAAV,EAA4B;AACxB,YAAI1a,KAAK,CAAC1L,QAAV,EAAoB;AAChB,eAAKomB,gBAAL,GAAwB,IAAxB;;AAEA,cACI1a,KAAK,CAAChQ,MAAN,IACAgQ,KAAK,CAAChQ,MAAN,KAAiBgQ,KADjB,IAEAA,KAAK,CAAChQ,MAAN,CAAamqB,WAHjB,EAIE;AACE,iBAAK3F,MAAL,GAAc;AAEVje,YAAAA,IAFU;AAIVyJ,cAAAA,KAAK,CAAChQ,MAAN,CAAamqB,WAAb,CAAyB9vB,IAAI,CAAC8b,SAAL,CAAe5P,IAAf,CAAzB,EAA+C,GAA/C;AACH,aALD;AAMH;;AAEDyJ,UAAAA,KAAK,CAAC7C,gBAAN,CAAuB,SAAvB,EAAkC,KAAKwd,iBAAvC;AACH;AACJ;AACJ,KArBD,MAqBO,IAAI,KAAKD,gBAAT,EAA2B;AAC9B1a,MAAAA,KAAK,CAACvC,mBAAN,CAA0B,SAA1B,EAAqC,KAAKkd,iBAA1C;AACA,WAAKD,gBAAL,GAAwB,KAAxB;AACH;;AAED,WAAO,KAAKN,UAAZ;AACH;;AAEY,QAAP1wB,OAAO;AACT,UAAMsW,KAAK,GAAG,KAAK+Z,MAAL,EAAd;;AAEA,QAAI,KAAKa,UAAT,EAAqB;AACjB5a,MAAAA,KAAK,CAACvK,YAAN,CAAmB,KAAKmlB,UAAxB;AACA,WAAKA,UAAL,GAAkB/wB,SAAlB;AACH;;AAEDmW,IAAAA,KAAK,CAACvC,mBAAN,CAA0B,SAA1B,EAAqC,KAAKkd,iBAA1C;AACA3a,IAAAA,KAAK,CAACvC,mBAAN,CAA0B,UAA1B,EAAsC,KAAK+c,WAA3C;AAEA,UAAM,KAAKP,KAAL,EAAN;AAEA,WAAO,KAAKY,YAAZ;;AAEA,SAAK,MAAM9pB,EAAX,IAAiB9F,MAAM,CAACC,IAAP,CAAY,KAAKwoB,aAAjB,CAAjB,EAAkD;AAC9C,YAAMiG,CAAC,GAAG,KAAKjG,aAAL,CAAmB3iB,EAAnB,CAAV;;AAEA,UAAI4oB,CAAC,CAACmB,KAAN,EAAa;AACT9a,QAAAA,KAAK,CAACvK,YAAN,CAAmBkkB,CAAC,CAACmB,KAArB;AACA,eAAOnB,CAAC,CAACmB,KAAT;AACH;;AAEDnB,MAAAA,CAAC,CAACrE,WAAF,CAAcO,GAAd;AACH;;AAED,SAAKlB,aAAL,GAAqB,EAArB;AAEA,WAAO,KAAKH,MAAZ;AACH;;AAEDX,EAAAA,gBAAgB,CACZ+F,WADY,EAEZxU,KAFY,EAGZiP,OAHY,EAIZC,MAJY,EAKZC,QALY,EAMZwG,UANY;AAQZ,QAAI,CAAC,KAAKhB,MAAV,EAAkB;AACd,aAAO3e,UAAU,CAAC,KAAK2e,MAAN,CAAV,CAAwBjF,MAAxB,EAAP;AACH;;AAED,UAAMQ,WAAW,GAAG,IAAIsE,WAAJ,CAChB,KAAKpe,QADW,EAEhB,KAAKue,MAFW,EAGhB,KAAKpF,aAHW,EAIhBvP,KAJgB,EAKhBiP,OALgB,EAMhBC,MANgB,EAOhBC,QAPgB,EAQhB,KAAKC,MARW,CAApB;AAUA,QAAIY,YAAJ;;AAMA,QACIwE,WAAW,CAACrD,iBAAZ,IACAqD,WAAW,CAACrD,iBAAZ,CACI,KAAK/a,QADT,EAEI4J,KAFJ,EAGI,KAAK2U,MAHT,EAII,KAAKP,SAJT,CAFJ,EAQE;AACEpE,MAAAA,YAAY,GAAI7e,IAAD;AACX,eAAOqjB,WAAW,CAACvD,YAAZ,CACH,KAAK7a,QADF,EAEHjF,IAFG,EAGH,KAAKwjB,MAHF,EAIH,KAAKP,SAJF,EAKH,IALG,EAMHpe,UAAU,CAAC,KAAK2e,MAAN,CAAV,CAAwB/N,OAAxB,CAAgCniB,SAAhC,CANG,EAOH,IAPG,CAAP;AASH,OAVD;AAWH;;AAED,WAAO,KAAKmxB,iBAAL,CACH1F,WADG,EAEHjB,OAFG,EAGHe,YAHG,EAIH2F,UAJG,CAAP;AAMH;;AAEDtC,EAAAA,YAAY,CAAChe,GAAD;AACR,WAAO,KAAKka,aAAL,CAAmBla,GAAnB,CAAP;AACH;;AAEOugB,EAAAA,iBAAiB,CACrB1F,WADqB,EAErBjB,OAFqB,EAGrBe,YAHqB,EAMrB2F,UANqB;AAQrB,UAAM/a,KAAK,GAAG,KAAK+Z,MAAL,EAAd;;AAEA,UAAM9W,OAAO,GAAwC;AACjDqS,MAAAA,WADiD;AAEjDwF,MAAAA,KAAK,EAAE9a,KAAK,CAAC/I,UAAN,CAAiB;AACpB,eAAOgM,OAAO,CAAC6X,KAAf;AACAxF,QAAAA,WAAW,CAACO,GAAZ,CAAgB,qCAAhB;AACH,OAHM,EAGJ/C,mBAAmB,IAAIuB,OAAO,IAAI,CAAf,CAHf;AAF0C,KAArD;AAQA,SAAKX,aAAL,CAAmB4B,WAAW,CAACvkB,EAA/B,IAAqCkS,OAArC;AAEA,UAAMoC,GAAG,GAAGiQ,WAAW,CAACH,KAAZ,CAAkBC,YAAlB,CAAZ;AAEA/P,IAAAA,GAAG,CAAC4V,KAAJ,CAAU;AACN;AACH,KAFD,EAEGC,OAFH,CAEW;AACP,UAAIjY,OAAO,CAAC6X,KAAZ,EAAmB;AACf9a,QAAAA,KAAK,CAACvK,YAAN,CAAmBwN,OAAO,CAAC6X,KAA3B;AACH;;AACD,aAAO,KAAKpH,aAAL,CAAmB4B,WAAW,CAACvkB,EAA/B,CAAP;AACH,KAPD;AASA,WAAOsU,GAAG,CAAC0O,IAAJ,CACF3O,KAAD,IAAWA,KADR,EAEH2V,UAAU,GAAGlxB,SAAH,GAAe,MAAMA,SAF5B,CAAP;AAIH;;AAEDiwB,EAAAA,kBAAkB;AAEdvjB,EAAAA,IAFc;AAAA;AAKd,UAAMyJ,KAAK,GAAG,KAAK+Z,MAAnB;AACA,QAAIxF,QAAQ,GAAGhe,IAAI,CAACR,MAApB;;AAEA,QAAIwe,QAAQ,KAAK,KAAKiF,SAAtB,EAAiC;AAC7B,aAAOpe,UAAU,CAAC4E,KAAD,CAAV,CAAkBgM,OAAlB,EAAP;AACH;;AAED,UAAM4N,WAAW,GAAG,KAAKC,oBAAL,CAA0BtjB,IAAI,CAACzI,IAA/B,CAApB;;AAEA,QAAI8rB,WAAJ,EAAiB;AACb,UACIA,WAAW,CAACxD,aAAZ,KAA8BvsB,SAA9B,IACA+vB,WAAW,CAACxD,aAAZ,CACI,KAAK5a,QADT,EAEIjF,IAFJ,EAGIyJ,KAHJ,EAII,KAAKwZ,SAJT,CAFJ,EAQE;AACE,cAAMlF,MAAM,GAAG/d,IAAI,CAACkf,MAApB;;AAEA,YAAIlB,QAAQ,KAAKvB,WAAjB,EAA8B;AAC1BuB,UAAAA,QAAQ,GAAG1qB,SAAX;AACAyqB,UAAAA,MAAM,CAAC,KAAKkF,SAAN,CAAN,GAAyB,IAAzB;AACH;;AAED,eAAOlF,MAAM,CAACtB,WAAD,CAAb;AAEA,eAAO,KAAKgI,iBAAL,CACH,IAAIpB,WAAJ,CACI,KAAKpe,QADT,EAEIwE,KAFJ,EAGI,KAAK2U,aAHT,EAIIpe,IAAI,CAACme,SAJT,EAKIne,IAAI,CAAC8d,OALT,EAMIC,MANJ,EAOIC,QAPJ,EAQI,KAAKC,MART,CADG,EAWHje,IAAI,CAAC8d,OAXF,CAAP;AAaH,OA/BD,MA+BO;AACH,eAAOjZ,UAAU,CAAC4E,KAAD,CAAV,CAAkBgM,OAAlB,EAAP;AACH;AACJ;;AAED,WAAO5Q,UAAU,CAAC4E,KAAD,CAAV,CAAkB8U,MAAlB,6BACyBve,IAAI,CAACzI,MAD9B,CAAP;AAGH;;AAEO+rB,EAAAA,oBAAoB,CACxB/rB,IADwB;AAAA;AAIxB,YAAQA,IAAR;AACI,WAAKmlB,2BAA2B,CAACC,SAAjC;AACI,eAAOiD,oBAAP;;AACJ,WAAKlD,2BAA2B,CAACE,YAAjC;AACI,eAAOmD,uBAAP;;AACJ,WAAKrD,2BAA2B,CAACG,KAAjC;AACI,eAAO8D,gBAAP;;AACJ,WAAKjE,2BAA2B,CAACI,UAAjC;AACI,eAAOmD,qBAAP;;AACJ,WAAKvD,2BAA2B,CAACK,qBAAjC;AACI,eAAOQ,gCAAP;;AACJ,WAAKb,2BAA2B,CAACM,IAAjC;AACI,eAAO+F,eAAP;;AACJ;AACI,eAAO,IAAP;AAdR;AAgBH;;AAgFkB,QAALW,KAAK;AACf,QAAI,CAAC,KAAKY,YAAN,IAAsB,KAAKhmB,GAAL,CAASkjB,UAAT,KAAwB,KAAKyB,SAAvD,EAAkE;AAC9D,WAAKqB,YAAL,GAAoB,KAAKhH,gBAAL,CAAsBqD,gBAAtB,EAAwC;AACxDU,QAAAA,QAAQ,EAAE,KAAK4B,SADyC;AAExDrC,QAAAA,KAAK,EAAER,iBAAiB,CAACI;AAF+B,OAAxC,CAApB;AAIH;;AAED,QAAI,KAAK8D,YAAT,EAAuB;AACnB,YAAM,KAAKA,YAAX;AACH;AACJ;;AAEkB,QAALJ,KAAK;AACf,QAAI,KAAKG,UAAT,EAAqB;AACjB;AACH;;AAED,QAAIO,WAAJ;AACA,UAAM5gB,GAAG,GAAGD,IAAI,CAACC,GAAL,EAAZ;AACA,UAAM8a,OAAO,GAAGpqB,MAAM,CAACC,IAAP,CAAY,KAAKypB,aAAjB,EAAgCnlB,MAAhC,CACXiL,GAAD,IAASF,GAAG,IAAI,KAAKoa,aAAL,CAAmBla,GAAnB,EAAwBiI,IAAxB,IAAgC,CAApC,CAAH,GAA4CqQ,YADzC,CAAhB;;AAIA,QAAI,KAAKyB,MAAT,EAAiB;AACba,MAAAA,OAAO,CAAC5e,IAAR,CAAauc,WAAb;AACH;;AAED,QAAIqC,OAAO,CAAC5oB,MAAZ,EAAoB;AAChB,YAAM2O,UAAU,CAAC,KAAK2e,MAAN,CAAV,CAAwBqB,GAAxB,CACF/F,OAAO,CAAC5U,GAAR,CAAahG,GAAD,IACR,KAAKoZ,gBAAL,CACIyF,eADJ,EAEIzvB,SAFJ,EAGIA,SAHJ,EAIIA,SAJJ,EAKI4Q,GALJ,EAMI,IANJ,EAOEsZ,IAPF,CAQI,MAAM,IARV,EASI;AACI,YAAItZ,GAAG,KAAKuY,WAAZ,EAAyB;AACrB,cAAI,CAACmI,WAAL,EAAkB;AACdA,YAAAA,WAAW,GAAG,EAAd;AACH;;AACDA,UAAAA,WAAW,CAAC1gB,GAAD,CAAX,GAAmB,IAAnB;AACA,iBAAO,KAAKka,aAAL,CAAmBla,GAAnB,CAAP;AACH;;AACD,eAAO,KAAP;AACH,OAlBL,CADJ,CADE,CAAN;AAwBH;;AAED,QAAI0gB,WAAJ,EAAiB;AACb,YAAME,OAAO,GAAG,MAAM,KAAKxH,gBAAL,CAClB2C,qBADkB,EAElB3sB,SAFkB,CAAtB;;AAKA,UACI,CAACwxB,OAAD,IACA,KAAKxmB,GAAL,CAASkjB,UADT,IAEA,KAAKljB,GAAL,CAASkjB,UAAT,IAAuBoD,WAH3B,EAIE;AACE,cAAM,KAAKtH,gBAAL,CAAsBqD,gBAAtB,EAAwC;AAC1CU,UAAAA,QAAQ,EAAE,KAAK4B,SAD2B;AAE1CrC,UAAAA,KAAK,EAAER,iBAAiB,CAACE,OAFiB;AAG1CtS,UAAAA,KAAK,EAAE;AAHmC,SAAxC,CAAN;AAMA,cAAMwN,UAAU,GAAG,KAAKvW,QAAL,CAAc/P,OAAjC;;AAEA,YAAIsmB,UAAJ,EAAgB;AACZ5E,UAAAA,UAAU,CAAC+E,iBAAX,CAA6BH,UAA7B;AACH;AACJ;AACJ;;AAED,SAAK6I,UAAL,GAAkB,KAAKb,MAAL,GAAc9iB,UAAd,CAAyB;AACvC,WAAK2jB,UAAL,GAAkB/wB,SAAlB;;AACA,WAAK4wB,KAAL;AACH,KAHiB,EAGf1H,YAHe,CAAlB;AAIH;;;;MA0BQ4E;AAST9pB,EAAAA,YACIvE,SACAmR,KACAga,SACA1jB,IACAmY,QACA2O,cACAC;AAEA,SAAKtc,QAAL,GAAgBlS,OAAhB;AACA,SAAKmR,GAAL,GAAWA,GAAX;AACA,SAAKga,OAAL,GAAeA,OAAf;AACA,SAAK1jB,EAAL,GAAUA,EAAV;AACA,SAAKmY,MAAL,GAAcA,MAAd;AACA,SAAK2O,YAAL,GAAoBA,YAApB;AACA,SAAKC,eAAL,GAAuBA,eAAvB;AACH;;AAEDhM,EAAAA,KAAK,CACDwP,6BADC,EAEDC,iBAFC;AAID;AACA,WAAO,KAAK/f,QAAL,CAAc4c,WAAd,CAA2BpR,cAA3B,CAA0C8E,KAA1C,CACH,IADG,EAEHwP,6BAFG,EAGHC,iBAHG,CAAP;AAKH;;;MAGQpD,uCACDhG;AAQRtkB,EAAAA,YAAYomB;AACR;AACA,SAAKP,aAAL,GAAqBO,YAArB;AACH;;AAEU,QAALnI,KAAK,CACPviB,OADO,EAEP+xB,6BAFO,EAGPC,iBAHO;AAKP,WAAO,KAAKC,MAAL,CACH;AACI/gB,MAAAA,GAAG,EAAElR,OAAO,CAACkR,GADjB;AAEI1J,MAAAA,EAAE,EAAExH,OAAO,CAACwH,EAFhB;AAGImY,MAAAA,MAAM,EAAE3f,OAAO,CAAC2f,MAHpB;AAIIuL,MAAAA,OAAO,EAAElrB,OAAO,CAACkrB,OAJrB;AAKIoD,MAAAA,YAAY,EAAEtuB,OAAO,CAACsuB;AAL1B,KADG,EAQHyD,6BARG,EASHC,iBATG,CAAP;AAWH;;AAEc,QAATE,SAAS,CACXzN,SADW,EAEX9E,MAFW,EAGXoS,6BAHW,EAIXC,iBAJW;AAMX,WAAO,KAAKC,MAAL,CACH;AAAEzqB,MAAAA,EAAE,EAAEid,SAAN;AAAiB9E,MAAAA;AAAjB,KADG,EAEHoS,6BAFG,EAGHC,iBAHG,CAAP;AAKH;;AAEwB,QAAnBG,mBAAmB,CACrB7D,YADqB,EAErBxD,OAFqB,EAGrBnL,MAHqB,EAIrBoS,6BAJqB,EAKrBC,iBALqB;AAOrB,WAAO,KAAKC,MAAL,CACH;AAAE3D,MAAAA,YAAF;AAAgB3O,MAAAA;AAAhB,KADG,EAEHoS,6BAFG,EAGHC,iBAHG,EAIHlH,OAJG,CAAP;AAMH;;AAEmB,QAANmH,MAAM,CAChBG,WADgB,EAEhBL,6BAFgB,EAGhBC,iBAHgB,EAIhBlH,OAJgB;AAMhB,WAAO,KAAKX,aAAL,CACFG,gBADE,CAECyC,uBAFD,EAGC,EACI,GAAGqF,WADP;AAEIL,MAAAA,6BAFJ;AAGIC,MAAAA;AAHJ,KAHD,EAQClH,OARD,EAUFN,IAVE,CAUI3O,KAAD,IAAW,CAAC,CAACA,KAVhB,CAAP;AAWH;;AAEY,SAANqN,MAAM,CACTxO,QADS,EAETyO,GAFS,EAGT3kB,MAHS;AAKRkW,IAAAA,QAA2C,CAACwO,MAA5C,CAAmDC,GAAnD,EAAwD3kB,MAAxD;AACJ;;;MAGQuqB,wCACDnG;AAORtkB,EAAAA,YACIvE,SACA2qB;AAEA;AANI,4BAAA,GAAsB,CAAtB;AAOJ,SAAKzY,QAAL,GAAgBlS,OAAhB;AACA,SAAKoqB,aAAL,GAAqBO,YAArB;AACH;;AAEe,QAAVtY,UAAU,CACZkc,YADY,EAEZe,aAFY;AAIZ,WAAO,KAAKO,WAAL,CAAiBtB,YAAjB,EAA+B,CAA/B,EAAkCe,aAAlC,CAAP;AACH;;AAEgB,QAAXO,WAAW,CACbtB,YADa,EAEbxD,OAFa,EAGbuE,aAHa;AAKb,WAAO,KAAKlF,aAAL,CACFG,gBADE,CAEC2C,qBAFD,EAGC;AACIqB,MAAAA,YADJ;AAEIe,MAAAA;AAFJ,KAHD,EAOCvE,OAPD,EASFN,IATE,CASI3O,KAAD,IACFA,KAAK,GACC8R,gBAAgB,CAAC1a,aAAjB,CAA+B,KAAKhB,QAApC,EAA8C4J,KAA9C,CADD,GAEC,IAZP,CAAP;AAcH;;AAEiB,QAAZwW,YAAY,CACd/D,YADc,EAEdxD,OAFc;AAId,UAAMwH,SAAS,GAAG,EAAE,KAAKC,mBAAzB;AACA,WAAO,KAAK3C,WAAL,CACHtB,YADG,EAEHxD,OAFG,EAGHtqB,6BAAA,CAAoCpD,SAHjC,EAILotB,IAJK,CAICxqB,OAAD,IACH,KAAKuyB,mBAAL,KAA6BD,SAA7B,IAA0CtyB,OAA1C;AAEM,SAAKiS,QAAL,CAAc4c,WAAd,CAA2BpR,cAA3B,CAA0C8E,KAA1C,CAAgDviB,OAAhD,EAAyD,IAAzD,CAFN,GAGM,KARH,CAAP;AAUH;;AAEa,SAAPspB,OAAO,CACV5O,QADU,EAEV1a,OAFU,EAGV4E,OAHU;AAKT8V,IAAAA,QAA4C,CAAC4O,OAA7C,CAAqDtpB,OAArD,EAA8D4E,OAA9D;AACJ;;;MAGQ4tB;AAUTluB,EAAAA,YAAYvE;AAqCJ,cAAA,GAAQ;AACZ,YAAMA,OAAO,GAAG,KAAKkS,QAArB;AAEAlS,MAAAA,OAAO,CAACwd,kBAAR,CAA2B4J,SAA3B,CACI,KAAKsL,iCADT;AAGA1yB,MAAAA,OAAO,CAAC0d,cAAR,CAAuB0J,SAAvB,CAAiC,KAAKnO,QAAtC;;AAEAjZ,MAAAA,OAAO,CAACgC,eAAR,CAAyBolB,SAAzB,CAAmC,KAAKuL,WAAxC;;AAEA,UAAI,CAAC,KAAKC,IAAL,CAAUvD,gBAAf,EAAiC;AAC7B;AACA,aAAKuD,IAAL,CAAUvD,gBAAV,GAA6BrvB,OAAO,CAACkD,OAAR,CAAiB6tB,KAA9C,CAF6B;;AAI7B/wB,QAAAA,OAAO,CAACkD,OAAR,CAAiB6tB,KAAjB,GAAyB,KAAK8B,aAA9B;AACH;;AAED,WAAKzI,aAAL,CACKG,gBADL,CAEQsC,oBAFR,EAGQtsB,SAHR,EAIQA,SAJR,EAKQA,SALR,EAMQmpB,WANR,EAQKe,IARL,CAQWxd,IAAD;AACF,YACIA,IAAI,IACJ,KAAKiF,QAAL,CAAcsL,kBAAd,CAAiCoJ,wBAAjC,OACI3Z,IAAI,CAAC2Z,wBAHb,EAIE;AACE,eAAKgM,IAAL,CAAUxD,mCAAV,GAAgD,IAAhD;;AACA,eAAKld,QAAL,CAAcsL,kBAAd,CAAiCC,yBAAjC,CACIxQ,IAAI,CAAC2Z,wBADT;;AAGA,eAAKgM,IAAL,CAAUxD,mCAAV,GAAgD,KAAhD;AACH;AACJ,OApBL;AAqBH,KAtCO;;AAwDA,0CAAA,GAAqCtT,KAAD;AACxC,UAAI,CAAC,KAAK8W,IAAL,CAAUxD,mCAAf,EAAoD;AAChD,aAAKhF,aAAL,CAAmBG,gBAAnB,CAAoCqD,gBAApC,EAAsD;AAClDC,UAAAA,KAAK,EAAER,iBAAiB,CAACK,kBADyB;AAElDY,UAAAA,QAAQ,EAAEjd,YAAY,CAAC,KAAKuG,IAAL,EAAD,CAF4B;AAGlDgP,UAAAA,wBAAwB,EAAE9K;AAHwB,SAAtD;AAKH;AACJ,KARO;;AAUA,iBAAA,GAAY7b,OAAD;AACf,YAAMqL,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,YAAM0W,QAAQ,GAAGjd,YAAY,CAAC/F,GAAD,CAA7B;;AAEA,UAAI,KAAKwnB,UAAT,EAAqB;AACjBxnB,QAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAK2mB,UAAtB;AACA,aAAKA,UAAL,GAAkBvyB,SAAlB;AACH;;AAED,UAAIN,OAAJ,EAAa;AACT,aAAKmqB,aAAL,CAAmBG,gBAAnB,CAAoCqD,gBAApC,EAAsD,EAClD,GAAGV,qBAAqB,CAACqC,cAAtB,CACC,KAAKrd,QADN,EAECjS,OAFD,EAGC,KAAK2X,IAHN,EAIC,KAAKgb,IAJN,EAKCtE,QALD,CAD+C;AAQlDT,UAAAA,KAAK,EAAER,iBAAiB,CAACC;AARyB,SAAtD;AAUH,OAXD,MAWO;AACH,aAAKwF,UAAL,GAAkBxnB,GAAG,CAACqC,UAAJ,CAAe;AAC7B,eAAKmlB,UAAL,GAAkBvyB,SAAlB;;AAEA,cAAI,KAAKqyB,IAAL,CAAUnE,UAAV,IAAwB,KAAKmE,IAAL,CAAUnE,UAAV,KAAyBH,QAArD,EAA+D;AAC3D,iBAAKlE,aAAL,CACKG,gBADL,CACsB2C,qBADtB,EAC6C3sB,SAD7C,EAEKkqB,IAFL,CAEW3O,KAAD;AACF,kBAAI,CAACA,KAAD,IAAU,KAAK8W,IAAL,CAAUnE,UAAV,KAAyBH,QAAvC,EAAiD;AAC7C,qBAAKlE,aAAL,CAAmBG,gBAAnB,CACIqD,gBADJ,EAEI;AACIU,kBAAAA,QADJ;AAEIT,kBAAAA,KAAK,EAAER,iBAAiB,CAACE,OAF7B;AAGItS,kBAAAA,KAAK,EAAE;AAHX,iBAFJ;AAQH;AACJ,aAbL;AAcH;AACJ,SAnBiB,EAmBf,CAnBe,CAAlB;AAoBH;AACJ,KA3CO;;AA6CA,oBAAA,GAAc,CAClBhb,OADkB,EAElB4E,OAFkB;;;AAIlB,YAAMse,CAAC,GAAG+J,qBAAqB,CAACqC,cAAtB,CACN,KAAKrd,QADC,EAENjS,OAFM,EAGN,KAAK2X,IAHC,EAIN,KAAKgb,IAJC,EAKNvhB,YAAY,CAAC,KAAKuG,IAAL,EAAD,CALN,CAAV;AAQAuL,MAAAA,CAAC,CAAC0K,KAAF,GAAUR,iBAAiB,CAACG,QAA5B;AACArK,MAAAA,CAAC,CAACoL,YAAF,GAAiB,MAAA1pB,OAAO,CAACoqB,KAAR,UAAA,iBAAA,SAAA,MAAgB,EAAjC;AACA9L,MAAAA,CAAC,CAACqL,eAAF,GAAoB3pB,OAAO,CAACA,OAA5B;;AAEA,WAAKulB,aAAL,CAAmBG,gBAAnB,CAAoCqD,gBAApC,EAAsDzK,CAAtD;AACH,KAjBO;;AAmBA,sBAAA,GAAiBlR,KAAD;AACpB,WAAKmY,aAAL,CAAmBG,gBAAnB,CAAoCqD,gBAApC,EAAsD;AAClDC,QAAAA,KAAK,EAAER,iBAAiB,CAACM,OADyB;AAElDW,QAAAA,QAAQ,EAAEjd,YAAY,CAAC,KAAKuG,IAAL,EAAD,CAF4B;AAGlD1U,QAAAA,OAAO,EAAE+O;AAHyC,OAAtD;AAKH,KANO;;AAtKJ,SAAKC,QAAL,GAAgBlS,OAAhB;AACA,SAAK4X,IAAL,GAAY5X,OAAO,CAACqL,SAApB;AACA,SAAKunB,IAAL,GAAY;AACRxD,MAAAA,mCAAmC,EAAE,KAD7B;AAERW,MAAAA,YAAY,EAAE;AAFN,KAAZ;AAKA,SAAK3F,aAAL,GAAqB,IAAI6F,uBAAJ,CACjBjwB,OADiB,EAEjB,KAAK4X,IAFY,EAGjB,KAAKgb,IAHY,CAArB;AAKA,SAAKlV,cAAL,GAAsB,IAAImR,8BAAJ,CAClB,KAAKzE,aADa,CAAtB;AAGA,SAAKpoB,eAAL,GAAuB,IAAIgtB,+BAAJ,CACnBhvB,OADmB,EAEnB,KAAKoqB,aAFc,CAAvB;AAIH;;AAED2G,EAAAA,KAAK,CACD7F,MADC;AAGD,QAAI,KAAK8F,OAAL,EAAJ,EAAoB;AAChB,aAAO,KAAK5G,aAAL,CAAmB6G,SAAnB,CAA6B/F,MAA7B,CAAP;AACH,KAFD,MAEO;AACH,WAAKhZ,QAAL,CAAcwN,SAAd,CAAwB,KAAKqT,KAA7B;;AACA,aAAO,KAAK3I,aAAL,CAAmB2G,KAAnB,CAAyB7F,MAAzB,CAAP;AACH;AACJ;;AAED8F,EAAAA,OAAO;AACH,WAAO,KAAK5G,aAAL,CAAmB4G,OAA1B;AACH;;AA0CD5wB,EAAAA,OAAO;;;AACH,UAAMJ,OAAO,GAAG,KAAKkS,QAArB;AAEAlS,IAAAA,OAAO,CAACwd,kBAAR,CAA2BiK,WAA3B,CACI,KAAKiL,iCADT;AAGA1yB,IAAAA,OAAO,CAAC0d,cAAR,CAAuB+J,WAAvB,CAAmC,KAAKxO,QAAxC;AACA,UAAAjZ,OAAO,CAACgC,eAAR,UAAA,iBAAA,SAAA,MAAyBylB,YAAY,KAAKkL,YAA1C;;AAEA,SAAKvI,aAAL,CAAmBhqB,OAAnB;;AACA,SAAKsd,cAAL,CAAoBtd,OAApB;AACA,SAAK4B,eAAL,CAAqB5B,OAArB;AAEA,SAAKwyB,IAAL,CAAU7C,YAAV,GAAyB,EAAzB;AACH;;;;AAqFL,SAASP,aAAT,CACInkB,SADJ,EAEI6B,OAFJ,EAGI/K,OAHJ;AAKI,QAAMogB,cAAc,GAAGpgB,OAAO,CAACkQ,UAAR,EAAvB;;AAEA,MAAIkQ,cAAJ,EAAoB;AAChB,UAAMpR,GAAG,GAAGD,aAAa,CAAC7F,SAAD,EAAYkX,cAAZ,CAAzB;;AAEA,QAAI,CAACrV,OAAO,CAAC6iB,YAAR,CAAqB5e,GAArB,CAAL,EAAgC;AAC5BjE,MAAAA,OAAO,CAAC6iB,YAAR,CAAqB5e,GAArB,IAA4BhP,OAA5B;AACH;;AAED,WAAOgP,GAAP;AACH;;AAED,SAAO5Q,SAAP;AACH;;AChzDD;;;;MAkBayyB;AAGTzuB,EAAAA,YAAYvE;AACR,SAAKkS,QAAL,GAAgBlS,OAAhB;AACH;;AAEDI,EAAAA,OAAO;AACH;AACH;;AAEDkS,EAAAA,QAAQ,CAACrS,OAAD;AACJ,UAAMsB,gBAAgB,GAAGxB,mBAAmB,CAAC,KAAKmS,QAAN,EAAgBjS,OAAhB,CAA5C;AACA,WAAQsB,gBAAgB,IAAIA,gBAAgB,CAACoB,SAAtC,IAAoD,EAA3D;AACH;;AAED0T,EAAAA,WAAW,CACPtG,EADO,EAEPkjB,gCAFO,EAGPC,cAHO,EAIPjB,iBAJO;AAMP,QACIvgB,eAAe,CAAC3B,EAAD,EAAKtP,iBAAL,CAAf,KACCwyB,gCAAgC,IAAIljB,EAAE,CAACoD,QAAH,KAAgB,CAAC,CADtD,CADJ,EAGE;AACE,aACI,CAAC+f,cAAc,IAAI,KAAKjN,SAAL,CAAelW,EAAf,CAAnB,MACCkiB,iBAAiB,IAAI,KAAKkB,YAAL,CAAkBpjB,EAAlB,CADtB,CADJ;AAIH;;AAED,WAAO,KAAP;AACH;;AAEDkW,EAAAA,SAAS,CAAClW,EAAD;AACL,QAAI,CAACA,EAAE,CAAC7G,aAAJ,IAAqB6G,EAAE,CAAChC,QAAH,KAAgBC,IAAI,CAACC,YAA9C,EAA4D;AACxD,aAAO,KAAP;AACH;;AAED,QAAImO,aAAa,CAACrM,EAAD,CAAjB,EAAuB;AACnB,aAAO,KAAP;AACH;;AAED,UAAMzB,IAAI,GAAGyB,EAAE,CAAC7G,aAAH,CAAiBuI,IAAjB,CAAsB7C,qBAAtB,EAAb;;AAEA,QAAIN,IAAI,CAAC7D,KAAL,KAAe,CAAf,IAAoB6D,IAAI,CAAC5D,MAAL,KAAgB,CAAxC,EAA2C;AACvC;AACA,aAAO,KAAP;AACH;;AAED,WAAO,IAAP;AACH;;AAEDyoB,EAAAA,YAAY,CAACpjB,EAAD;;;AACR,SAAK,IAAI5O,CAAC,GAAuB4O,EAAjC,EAAqC5O,CAArC,EAAwCA,CAAC,GAAGiI,GAAG,CAACG,gBAAJ,CAAqBpI,CAArB,CAA5C,EAAqE;AACjE,YAAMI,gBAAgB,GAAGxB,mBAAmB,CAAC,KAAKmS,QAAN,EAAgB/Q,CAAhB,CAA5C;;AAEA,UAAI,KAAKiyB,SAAL,CAAejyB,CAAf,CAAJ,EAAuB;AACnB,eAAO,KAAP;AACH;;AAED,YAAMkyB,cAAc,GAChB,MAAA9xB,gBAAgB,SAAhB,IAAAA,gBAAgB,WAAhB,SAAA,GAAAA,gBAAgB,CAAEoB,SAAlB,UAAA,iBAAA,SAAA,MAA6B2wB,kBADjC;;AAGA,UAAI,CAACD,cAAD,IAAmB,KAAKE,WAAL,CAAiBpyB,CAAjB,CAAvB,EAA4C;AACxC,eAAO,KAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;;AAEOoyB,EAAAA,WAAW,CAACxjB,EAAD;AACf,WAAOA,EAAE,CAACyjB,YAAH,CAAgB,UAAhB,CAAP;AACH;;AAEOJ,EAAAA,SAAS,CAACrjB,EAAD;;;AACb,UAAM0jB,OAAO,GAAG1jB,EAAE,CAACvP,YAAH,CAAgB,aAAhB,CAAhB;;AAEA,QAAIizB,OAAO,IAAIA,OAAO,CAAC1S,WAAR,OAA0B,MAAzC,EAAiD;AAC7C,UAAI,EAAC,MAAA,KAAK7O,QAAL,CAAc3P,SAAd,UAAA,iBAAA,SAAA,MAAyBmxB,YAAY3jB,GAAtC,CAAJ,EAA+C;AAC3C,eAAO,IAAP;AACH;AACJ;;AAED,WAAO,KAAP;AACH;;AAED8W,EAAAA,SAAS,CACLxG,OADK,EAELsT,GAFK;AAIL,WAAO,KAAKxG,WAAL,CACH,EACI,GAAG9M;AADP,KADG,EAIHsT,GAJG,CAAP;AAMH;;AAEDC,EAAAA,QAAQ,CACJvT,OADI,EAEJsT,GAFI;AAIJ,WAAO,KAAKxG,WAAL,CACH;AACIjX,MAAAA,UAAU,EAAE,IADhB;AAEI,SAAGmK;AAFP,KADG,EAKHsT,GALG,CAAP;AAOH;;AAEDE,EAAAA,QAAQ,CACJxT,OADI,EAEJsT,GAFI;AAIJ,WAAO,KAAKxG,WAAL,CAAiB,EAAE,GAAG9M;AAAL,KAAjB,EAAiCsT,GAAjC,CAAP;AACH;;AAEDG,EAAAA,QAAQ,CACJzT,OADI,EAEJsT,GAFI;AAIJ,WAAO,KAAKxG,WAAL,CAAiB,EAAE,GAAG9M,OAAL;AAAcnK,MAAAA,UAAU,EAAE;AAA1B,KAAjB,EAAmDyd,GAAnD,CAAP;AACH;;AAEDxN,EAAAA,WAAW,CACP9F,OADO,EAEPsT,GAFO;AAIP,WACI,KAAKxG,WAAL,CACI,EACI,GAAG9M,OADP;AAEI0T,MAAAA,eAAe,EAAGhkB,EAAD,IACb,KAAKsG,WAAL,CACItG,EADJ,EAEIsQ,OAAO,CAAC4S,gCAFZ,KAGK,CAAC,CAAC,KAAK3gB,QAAL,CAAcvC,EAAd,EAAkBikB;AANjC,KADJ,EASIL,GATJ,KAUK,IAXT;AAaH;;AAEDM,EAAAA,OAAO,CAAC5T,OAAD;AACH,WAAO,KAAK6T,aAAL,CAAmB,IAAnB,EAAyB7T,OAAzB,KAAqC,EAA5C;AACH;;AAED8M,EAAAA,WAAW,CACP9M,OADO,EAEPsT,GAFO;AAIP,UAAMQ,KAAK,GAAG,KAAKD,aAAL,CAAmB,KAAnB,EAA0B7T,OAA1B,EAAmCsT,GAAnC,CAAd;;AACA,WAAOQ,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAR,GAAcA,KAA1B;AACH;;AAEOD,EAAAA,aAAa,CACjBD,OADiB,EAEjB5T,OAFiB,EAGjBsT,GAHiB;;;AAKjB,UAAM;AACFvkB,MAAAA,SADE;AAEFglB,MAAAA,cAAc,GAAG,IAFf;AAGFnB,MAAAA,gCAHE;AAIFnM,MAAAA,kBAJE;AAKFlJ,MAAAA,mBALE;AAMFyW,MAAAA,WANE;AAOFne,MAAAA,UAPE;AAQFoe,MAAAA;AARE,QASFjU,OATJ;;AAWA,QAAI,CAACsT,GAAL,EAAU;AACNA,MAAAA,GAAG,GAAG,EAAN;AACH;;AAED,UAAMY,QAAQ,GAAkB,EAAhC;AAEA,QAAI;AAAER,MAAAA;AAAF,QAAsB1T,OAA1B;AACA,UAAMmU,kBAAkB,GAAG,CAAC,CAACT,eAA7B;;AAEA,QAAI,CAAC3kB,SAAL,EAAgB;AACZ,aAAO,IAAP;AACH;;AAED,QAAI,CAAC2kB,eAAL,EAAsB;AAClBA,MAAAA,eAAe,GAAIhkB,EAAD,IACd,KAAKsG,WAAL,CACItG,EADJ,EAEIkjB,gCAFJ,EAGI,KAHJ,EAIIrV,mBAJJ,CADJ;AAOH;;AAED,UAAM6W,kBAAkB,GAAsC;AAC1DrlB,MAAAA,SAD0D;AAE1DslB,MAAAA,eAAe,EACXL,WAAW,KAAK9zB,SAAhB,IAA6BumB,kBAA7B,GACM,MAAA,KAAK5U,QAAL,CAAc3P,SAAd,UAAA,iBAAA,SAAA,MAAyBgf,QAD/B,GAEM8S,WAAW,KACX,MAAA,MAAAlV,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyC9C,SAAzC,CAAA,UAAA,iBAAA,SAAA,MACM7M,SADN,UAAA,iBAAA,SAAA,MACiB+e,MAFN,CALqC;AAQ1DpH,MAAAA,IAAI,EAAEka,cAAc,IAAIhlB,SARkC;AAS1D8G,MAAAA,UAT0D;AAU1D6d,MAAAA,eAV0D;AAW1DS,MAAAA,kBAX0D;AAY1DvB,MAAAA,gCAZ0D;AAa1DrV,MAAAA,mBAb0D;AAc1D+W,MAAAA,eAAe,EAAE;AAdyC,KAA9D;AAiBA,UAAMC,MAAM,GAAG/mB,uBAAuB,CAClCuB,SAAS,CAAClG,aADwB,EAElCkG,SAFkC,EAGjC/I,IAAD,IACI,KAAKwuB,cAAL,CAAoBxuB,IAApB,EAAyCouB,kBAAzC,CAJ8B,CAAtC;;AAOA,QAAI,CAACG,MAAL,EAAa;AACT,aAAO,IAAP;AACH;;AAED,UAAME,qBAAqB,GACvBC,wBAD0B;;;AAG1B,YAAMC,YAAY,GACd,MAAAP,kBAAkB,CAACO,YAAnB,UAAA,iBAAA,KAAA,GACAP,kBAAkB,CAACQ,aAFvB;;AAIA,UAAID,YAAJ,EAAkB;AACdT,QAAAA,QAAQ,CAACpnB,IAAT,CAAc6nB,YAAd;AACH;;AAED,UAAIf,OAAJ,EAAa;AACT,YAAIe,YAAJ,EAAkB;AACdP,UAAAA,kBAAkB,CAACN,KAAnB,GAA2B,KAA3B;AACA,iBAAOM,kBAAkB,CAACO,YAA1B;AACA,iBAAOP,kBAAkB,CAACQ,aAA1B;AACA,iBAAOR,kBAAkB,CAACS,OAA1B;AACAT,UAAAA,kBAAkB,CAACva,IAAnB,GAA0B8a,YAA1B;;AAEA,cAAIV,SAAS,IAAI,CAACA,SAAS,CAACU,YAAD,CAA3B,EAA2C;AACvC,mBAAO,KAAP;AACH;AACJ;;AAED,eAAO,CAAC,EAAEA,YAAY,IAAID,wBAAlB,CAAR;AACH,OAdD,MAcO;AACH,YAAIC,YAAY,IAAIrB,GAApB,EAAyB;AACrBA,UAAAA,GAAG,CAAC1wB,YAAJ,GAAmB,MAAAkc,OAAO,CAACiB,iBAAR,CACf,KAAKlO,QADU,EAEf8iB,YAFe,CAAA,UAAA,iBAAA,SAAA,MAGhB/xB,YAHH;AAIH;;AAED,eAAO,CAAC,EAAE8xB,wBAAwB,IAAI,CAACC,YAA/B,CAAR;AACH;AACJ,KAnCD;;AAqCA,QAAI,CAACZ,cAAL,EAAqB;AACjBT,MAAAA,GAAG,CAACwB,aAAJ,GAAoB,IAApB;AACH;;AAED,QAAIf,cAAc,IAAIhrB,GAAG,CAACI,YAAJ,CAAiB4F,SAAjB,EAA4BglB,cAA5B,CAAtB,EAAmE;AAC/DQ,MAAAA,MAAM,CAACQ,WAAP,GAAqBhB,cAArB;AACH,KAFD,MAEO,IAAIle,UAAJ,EAAgB;AACnB,YAAMpO,SAAS,GAAG6B,cAAY,CAACyF,SAAD,CAA9B;;AAEA,UAAI,CAACtH,SAAL,EAAgB;AACZ,eAAO,IAAP;AACH;;AAED,UACI,KAAK+sB,cAAL,CAAoB/sB,SAApB,EAA+B2sB,kBAA/B,MACIxpB,UAAU,CAACoqB,aADf,IAEA,CAACP,qBAAqB,CAAC,IAAD,CAH1B,EAIE;AACE,YAAIL,kBAAkB,CAACa,gBAAvB,EAAyC;AACrC3B,UAAAA,GAAG,CAACwB,aAAJ,GAAoB,IAApB;AACH;;AAED,eAAOZ,QAAP;AACH;;AAEDK,MAAAA,MAAM,CAACQ,WAAP,GAAqBttB,SAArB;AACH;;AAED,OAAG;AACC,UAAIoO,UAAJ,EAAgB;AACZ0e,QAAAA,MAAM,CAACW,YAAP;AACH,OAFD,MAEO;AACHX,QAAAA,MAAM,CAACY,QAAP;AACH;AACJ,KAND,QAMSV,qBAAqB,EAN9B;;AAQA,QAAIL,kBAAkB,CAACa,gBAAvB,EAAyC;AACrC3B,MAAAA,GAAG,CAACwB,aAAJ,GAAoB,IAApB;AACH;;AAED,WAAOZ,QAAQ,CAACpxB,MAAT,GAAkBoxB,QAAlB,GAA6B,IAApC;AACH;;AAEOM,EAAAA,cAAc,CAClB50B,OADkB,EAElB4tB,KAFkB;;;AAIlB,QAAIA,KAAK,CAACsG,KAAV,EAAiB;AACb,aAAOlpB,UAAU,CAACoqB,aAAlB;AACH;;AAED,UAAMJ,aAAa,GAAGpH,KAAK,CAACoH,aAA5B;;AAEA,QACIA,aAAa,KACZh1B,OAAO,KAAKg1B,aAAZ,IACG,CAAC7rB,GAAG,CAACI,YAAJ,CAAiByrB,aAAjB,EAAgCh1B,OAAhC,CAFQ,CADjB,EAIE;AACE4tB,MAAAA,KAAK,CAACsG,KAAN,GAAc,IAAd;AACAtG,MAAAA,KAAK,CAACmH,YAAN,GAAqBC,aAArB;AACA,aAAOhqB,UAAU,CAACoqB,aAAlB;AACH;;AAED,UAAMjmB,SAAS,GAAGye,KAAK,CAACze,SAAxB;;AAEA,QAAInP,OAAO,KAAKmP,SAAhB,EAA2B;AACvB,aAAOnE,UAAU,CAACwqB,WAAlB;AACH;;AAED,QAAI,CAACrsB,GAAG,CAACI,YAAJ,CAAiB4F,SAAjB,EAA4BnP,OAA5B,CAAL,EAA2C;AACvC,aAAOgL,UAAU,CAACyqB,aAAlB;AACH;;AAED,QACKz1B,OAAyC,CAAC+T,uBAD/C,EAEE;AACE,aAAO/I,UAAU,CAACyqB,aAAlB;AACH;;AAED,QAAItsB,GAAG,CAACI,YAAJ,CAAiBqkB,KAAK,CAAC8H,kBAAvB,EAA2C11B,OAA3C,CAAJ,EAAyD;AACrD,aAAOgL,UAAU,CAACyqB,aAAlB;AACH;;AAED,UAAMnqB,GAAG,GAAIsiB,KAAK,CAAC+H,UAAN,GAAmBzW,OAAO,CAACiB,iBAAR,CAC5B,KAAKlO,QADuB,EAE5BjS,OAF4B,CAAhC;;AAMA,QAAI,CAACsL,GAAL,EAAU;AACN,aAAON,UAAU,CAACwqB,WAAlB;AACH;;AAED,QAAIrlB,iBAAiB,CAACnQ,OAAD,CAArB,EAAgC;AAC5B,UAAI,KAAKoW,WAAL,CAAiBpW,OAAjB,EAA0BM,SAA1B,EAAqC,IAArC,EAA2C,IAA3C,CAAJ,EAAsD;AAClDstB,QAAAA,KAAK,CAACyH,gBAAN,GAAyB,IAAzB;AACH;;AAED,aAAOrqB,UAAU,CAACwqB,WAAlB;AACH;AAGD;AACA;;;AACA,QACI,CAAC5H,KAAK,CAAC2G,kBAAP,KACCv0B,OAAO,CAACmW,OAAR,KAAoB,QAApB,IAAgCnW,OAAO,CAACmW,OAAR,KAAoB,SADrD,CADJ,EAGE;AACE,UAAI,CAAA,MAAA7K,GAAG,CAAChJ,SAAJ,UAAA,iBAAA,SAAA,MAAe+e,MAAf,OAA0B,MAAA,KAAKpP,QAAL,CAAc3P,SAAd,UAAA,iBAAA,SAAA,MAAyBgf,QAAnD,CAAJ,EAAiE;AAC7DsM,QAAAA,KAAK,CAACsG,KAAN,GAAc,IAAd;AACAtG,QAAAA,KAAK,CAAC8H,kBAAN,GAA2B9H,KAAK,CAACmH,YAAN,GAAqB/0B,OAAhD;AAEA,eAAOgL,UAAU,CAACoqB,aAAlB;AACH,OALD,MAKO;AACH,eAAOpqB,UAAU,CAACyqB,aAAlB;AACH;AACJ;;AAED,QAAI,CAAC7H,KAAK,CAACjQ,mBAAP,IAA8B,CAAC,KAAKuV,YAAL,CAAkBlzB,OAAlB,CAAnC,EAA+D;AAC3D,UAAI,KAAKoW,WAAL,CAAiBpW,OAAjB,EAA0B,KAA1B,EAAiC,IAAjC,EAAuC,IAAvC,CAAJ,EAAkD;AAC9C4tB,QAAAA,KAAK,CAACyH,gBAAN,GAAyB,IAAzB;AACH;;AAED,aAAOrqB,UAAU,CAACyqB,aAAlB;AACH;;AAED,QAAIjS,MAAJ;AAEA,QAAIyR,OAAO,GAAGrH,KAAK,CAACqH,OAApB;;AAEA,QAAI,CAACA,OAAL,EAAc;AACVA,MAAAA,OAAO,GAAGrH,KAAK,CAACqH,OAAN,GAAgB/V,OAAO,CAACiB,iBAAR,CACtB,KAAKlO,QADiB,EAEtB2b,KAAK,CAAC3T,IAFgB,CAA1B;AAIH;;AAED,UAAM2b,SAAS,GAAGX,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAEpyB,KAA3B;AACA,QAAIF,QAAQ,GAAG2I,GAAG,CAAC3I,QAAnB;AACA,QAAIE,KAAK,GAAGyI,GAAG,CAACzI,KAAhB;AAEA2gB,IAAAA,MAAM,GAAG,MAAA,KAAKvR,QAAL,CAAc3P,SAAd,UAAA,iBAAA,SAAA,MAAyBuzB,cAAc71B,SAAS4tB,MAAzD;;AAEA,QAAIpK,MAAM,KAAKljB,SAAf,EAA0B;AACtBstB,MAAAA,KAAK,CAACyH,gBAAN,GAAyB,IAAzB;AACH;;AAED,QAAI7R,MAAM,KAAKljB,SAAX,KAAyBqC,QAAQ,IAAIE,KAAZ,IAAqB+yB,SAA9C,CAAJ,EAA8D;AAC1D,YAAME,eAAe,GAAGnzB,QAAQ,SAAR,IAAAA,QAAQ,WAAR,SAAA,GAAAA,QAAQ,CAAEyP,UAAV,EAAxB;AACA,YAAM2jB,gBAAgB,GAAGH,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAExjB,UAAX,EAAzB;AACA,UAAI4jB,YAAY,GAAGnzB,KAAK,SAAL,IAAAA,KAAK,WAAL,SAAA,GAAAA,KAAK,CAAEuP,UAAP,EAAnB;;AAEA,UACI4jB,YAAY,IACZ7sB,GAAG,CAACI,YAAJ,CAAiBwsB,gBAAjB,EAAmCC,YAAnC,CADA,IAEA7sB,GAAG,CAACI,YAAJ,CAAiB4F,SAAjB,EAA4B4mB,gBAA5B,CAFA,KAGC,CAACD,eAAD,IACG,CAACjzB,KADJ,IAEGsG,GAAG,CAACI,YAAJ,CAAiBwsB,gBAAjB,EAAmCD,eAAnC,CALJ,CADJ,EAOE;AACEjzB,QAAAA,KAAK,GAAG+yB,SAAR;AACAI,QAAAA,YAAY,GAAGD,gBAAf;AACH;;AAED,UACID,eAAe,KACdA,eAAe,KAAK3mB,SAApB,IACG,CAAChG,GAAG,CAACI,YAAJ,CAAiB4F,SAAjB,EAA4B2mB,eAA5B,CAFU,CADnB,EAIE;AACEnzB,QAAAA,QAAQ,GAAGrC,SAAX;AACH;;AAED,UAAI01B,YAAY,IAAI,CAAC7sB,GAAG,CAACI,YAAJ,CAAiB4F,SAAjB,EAA4B6mB,YAA5B,CAArB,EAAgE;AAC5DnzB,QAAAA,KAAK,GAAGvC,SAAR;AACH;;AAED,UAAIqC,QAAQ,IAAIE,KAAhB,EAAuB;AACnB,YACImzB,YAAY,IACZF,eADA,IAEA,CAAC3sB,GAAG,CAACI,YAAJ,CAAiBusB,eAAjB,EAAkCE,YAAlC,CAHL,EAIE;AACEnzB,UAAAA,KAAK,GAAGvC,SAAR;AACH,SAND,MAMO;AACHqC,UAAAA,QAAQ,GAAGrC,SAAX;AACH;AACJ;;AAED,UAAIqC,QAAJ,EAAc;AACV6gB,QAAAA,MAAM,GAAG7gB,QAAQ,CAACkzB,aAAT,CAAuB71B,OAAvB,EAAgC4tB,KAAhC,CAAT;AACH;;AAED,UAAI/qB,KAAJ,EAAW;AACP2gB,QAAAA,MAAM,GAAG3gB,KAAK,CAACgzB,aAAN,CAAoB71B,OAApB,EAA6B4tB,KAA7B,CAAT;AACH;AACJ;;AAED,QAAIpK,MAAM,KAAKljB,SAAf,EAA0B;AACtBkjB,MAAAA,MAAM,GAAGoK,KAAK,CAACkG,eAAN,CAAsB9zB,OAAtB,IACHgL,UAAU,CAACoqB,aADR,GAEHpqB,UAAU,CAACwqB,WAFjB;;AAIA,UACIhS,MAAM,KAAKxY,UAAU,CAACwqB,WAAtB,IACA,KAAKpf,WAAL,CAAiBpW,OAAjB,EAA0B,KAA1B,EAAiC,IAAjC,EAAuC,IAAvC,CAFJ,EAGE;AACE4tB,QAAAA,KAAK,CAACyH,gBAAN,GAAyB,IAAzB;AACH;AACJ;;AAED,QAAI7R,MAAM,KAAKxY,UAAU,CAACoqB,aAAtB,IAAuC,CAACxH,KAAK,CAACsG,KAAlD,EAAyD;AACrD,UAAItG,KAAK,CAAC3X,UAAV,EAAsB;AAClB;AACA;AACA;AACA2X,QAAAA,KAAK,CAACoH,aAAN,GAAsBh1B,OAAtB;AACAwjB,QAAAA,MAAM,GAAGxY,UAAU,CAACwqB,WAApB;AACH,OAND,MAMO;AACH5H,QAAAA,KAAK,CAACsG,KAAN,GAAc,IAAd;AACAtG,QAAAA,KAAK,CAACmH,YAAN,GAAqB/0B,OAArB;AACH;AACJ;;AAED,WAAOwjB,MAAP;AACH;;;;ACzfL;;;;AAKO,MAAMyS,IAAI,GAab;AACAC,EAAAA,GAAG,EAAE,KADL;AAEAz2B,EAAAA,KAAK,EAAE,OAFP;AAGAC,EAAAA,MAAM,EAAE,QAHR;AAIAy2B,EAAAA,KAAK,EAAE,GAJP;AAKAn3B,EAAAA,MAAM,EAAE,QALR;AAMAC,EAAAA,QAAQ,EAAE,UANV;AAOAE,EAAAA,GAAG,EAAE,KAPL;AAQAD,EAAAA,IAAI,EAAE,MARN;AASAJ,EAAAA,SAAS,EAAE,WATX;AAUAF,EAAAA,OAAO,EAAE,SAVT;AAWAG,EAAAA,UAAU,EAAE,YAXZ;AAYAF,EAAAA,SAAS,EAAE;AAZX,CAbG;;ACLP;;;;;AAgCA,SAASu3B,kCAAT,CACIr2B,OADJ,EAEIC,OAFJ;;;AAII,QAAMoe,SAAS,GAAGre,OAAO,CAACqe,SAA1B;AACA,MAAItO,EAAE,GAAuB9P,OAA7B;;AAEA,KAAG;AACC,UAAMq2B,qBAAqB,GAAG,MAAAv2B,mBAAmB,CAC7CC,OAD6C,EAE7C+P,EAF6C,CAAnB,UAAA,iBAAA,SAAA,MAG3B9M,YAHH;;AAKA,QACIqzB,qBAAqB,IACrBt2B,OAAO,CAACiD,YAAR,CAAqBszB,wBAArB,CACIxmB,EADJ,EAEI,CAAC,CAACumB,qBAAqB,CAACE,UAF5B,CAFJ,EAME;AACE,aAAOzmB,EAAP;AACH;;AAEDA,IAAAA,EAAE,GAAGsO,SAAS,CAACtO,EAAD,CAAd;AACH,GAjBD,QAiBSA,EAjBT;;AAmBA,SAAOxP,SAAP;AACH;;AAED,MAAMk2B,gCAAgC,GAAG;AACrC,GAACh2B,iBAAA,CAAwBzD,QAAzB,GAAoC,CADC;AAErC,GAACyD,iBAAA,CAAwBxD,OAAzB,GAAmC,CAFE;AAGrC,GAACwD,iBAAA,CAAwB1D,cAAzB,GAA0C;AAHL,CAAzC;MAYa25B,4BACD7N;AAkBRtkB,EAAAA,YAAYvE,SAA4BqL;AACpC;;AAOI,cAAA,GAAQ;AACZ,YAAMC,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AACA,YAAM5R,GAAG,GAAGsF,GAAG,CAACN,QAAhB;;AAGAhF,MAAAA,GAAG,CAAC6N,gBAAJ,CAAqBiL,uBAArB,EAAsC,KAAKvJ,UAA3C,EAAuD,IAAvD;AACAvP,MAAAA,GAAG,CAAC6N,gBAAJ,CAAqBkL,wBAArB,EAAuC,KAAKvJ,WAA5C,EAAyD,IAAzD;AACAlK,MAAAA,GAAG,CAACuI,gBAAJ,CAAqB,SAArB,EAAgC,KAAK8iB,UAArC,EAAiD,IAAjD;AAEA,YAAM7vB,aAAa,GAAGsC,GAAG,CAACK,gBAAJ,CAAqBzD,GAArB,CAAtB;;AAEA,UAAIc,aAAa,IAAIA,aAAa,KAAKd,GAAG,CAACyL,IAA3C,EAAiD;AAC7C,aAAKmlB,kBAAL,CAAwB9vB,aAAxB;AACH;;AAED,WAAKsgB,SAAL,CAAe,KAAKyP,UAApB;AACH,KAhBO;;AAyTA,mBAAA,GAAc11B,CAAD;AACjB,YAAMsL,MAAM,GAAGtL,CAAC,CAACqd,YAAF,GAAiB,CAAjB,CAAf;;AAEA,UAAI/R,MAAJ,EAAY;AACR,aAAKmqB,kBAAL,CACInqB,MADJ,EAEItL,CAAC,CAACsD,MAAF,CAASqO,aAFb,EAGI3R,CAAC,CAACsD,MAAF,CAASsqB,yBAHb;AAKH;AACJ,KAVO;;AAYA,oBAAA,GAAe5tB,CAAD;;;AAClB,WAAKy1B,kBAAL,CACIr2B,SADJ,EAEI,MAAAY,CAAC,CAACsD,MAAF,UAAA,iBAAA,SAAA,MAAUqyB,cAAchkB,aAF5B;AAIH,KALO;;;AA6HA,gCAAA,GAA2B7S,OAAD;AAEjC,KAFO;;AAIA,mBAAA,GAAcme,KAAD;AACjB,UAAIA,KAAK,CAAC1c,GAAN,KAAcw0B,IAAI,CAACC,GAAnB,IAA0B/X,KAAK,CAAC2Y,OAApC,EAA6C;AACzC;AACH;;AAED,YAAM3C,cAAc,GAAG,KAAK9K,MAAL,EAAvB;;AAEA,UACI,CAAC8K,cAAD,IACA,CAACA,cAAc,CAAClrB,aADhB,IAEAkrB,cAAc,CAAC4C,eAAf,KAAmC,MAHvC,EAIE;AACE;AACH;;AAED,YAAMh3B,OAAO,GAAG,KAAKkS,QAArB;AACA,YAAMyM,UAAU,GAAG3e,OAAO,CAAC2e,UAA3B;AACA,YAAMpT,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0BpgB,OAA1B,EAAmCo0B,cAAnC,CAAZ;;AAEA,UAAI,CAAC7oB,GAAD,IAAQA,GAAG,CAACsV,aAAJ,CAAkBzC,KAAlB,CAAZ,EAAsC;AAClC;AACH;;AAED,YAAMlI,UAAU,GAAGkI,KAAK,CAAC6Y,QAAzB;AAEA,YAAMtgB,IAAI,GAAG+f,mBAAmB,CAACQ,gBAApB,CACTl3B,OADS,EAETuL,GAFS,EAGThL,SAHS,EAIT6zB,cAJS,EAKT7zB,SALS,EAMT2V,UANS,EAOT,IAPS,CAAb;AAUA,YAAMoI,WAAW,GAAG/S,GAAG,CAAC1J,IAAJ,CAASwQ,UAAT,EAApB;;AAEA,UAAI,CAACiM,WAAL,EAAkB;AACd;AACH;;AAED,YAAM6Y,WAAW,GAAGxgB,IAAI,SAAJ,IAAAA,IAAI,WAAJ,SAAA,GAAAA,IAAI,CAAE1W,OAA1B;AACA,YAAMm3B,+BAA+B,GACjCf,kCAAkC,CAACr2B,OAAD,EAAUo0B,cAAV,CADtC;;AAGA,UAAI+C,WAAJ,EAAiB;AACb,cAAME,gBAAgB,GAAG1gB,IAAI,CAAC1T,YAA9B;;AAEA,YACIsI,GAAG,CAACtI,YAAJ,IACAmG,GAAG,CAACI,YAAJ,CAAiB6tB,gBAAjB,EAAmCjD,cAAnC,CAFJ,EAGE;AACE,cACK,CAACzd,IAAI,CAACwe,aAAN,IACGkC,gBAAgB,KAAK9rB,GAAG,CAACtI,YAD7B,IAECm0B,+BAA+B,IAC5B,CAAChuB,GAAG,CAACI,YAAJ,CACG4tB,+BADH,EAEGD,WAFH,CAJT,EAQE;AACE;AACA;AACA;AACH,WAbH;AAgBE;AACA;AACA;AACA;;;AACAniB,UAAAA,iBAAiB,CAAC4B,yBAAlB,CACI5W,OADJ,EAEIo0B,cAFJ,EAGIle,UAHJ,EAIIihB,WAJJ;AAOA;AACH;;AAED,YAAIE,gBAAgB,IAAIF,WAAW,CAAC/gB,OAAZ,KAAwB,QAAhD,EAA0D;AACtD;AACA;AACA,cACIkI,WAAW,CAAC9H,aAAZ,CACI,IAAIxR,qBAAJ,CAA0B;AACtByR,YAAAA,EAAE,EAAE,MADkB;AAEtBC,YAAAA,KAAK,EAAE4H,WAFe;AAGtB3H,YAAAA,IAAI,EAAEwgB,WAHgB;AAItBvhB,YAAAA,YAAY,EAAEwI;AAJQ,WAA1B,CADJ,CADJ,EASE;AACEpJ,YAAAA,iBAAiB,CAACgB,oBAAlB,CACI,KAAK9D,QADT,EAEImlB,gBAAgB,SAAhB,IAAAA,gBAAgB,WAAhB,GAAAA,gBAAA,GAAoBF,WAFxB,EAGI,KAHJ,EAIIjhB,UAJJ,EAKIkI,KALJ;AAOH;;AAED;AACH;;AAED,YAAIO,UAAU,KAAIhI,IAAI,SAAJ,IAAAA,IAAI,WAAJ,SAAA,GAAAA,IAAI,CAAEwe,aAAV,CAAd,EAAuC;AACnC,cACI7W,WAAW,CAAC9H,aAAZ,CACI,IAAIxR,qBAAJ,CAA0B;AACtByR,YAAAA,EAAE,EAAE,MADkB;AAEtBC,YAAAA,KAAK,EAAE4H,WAFe;AAGtB3H,YAAAA,IAAI,EAAEwgB,WAHgB;AAItBvhB,YAAAA,YAAY,EAAEwI;AAJQ,WAA1B,CADJ,CADJ,EASE;AACEA,YAAAA,KAAK,CAACkZ,cAAN;AACAlZ,YAAAA,KAAK,CAAC2I,wBAAN;AAEApU,YAAAA,mBAAW,CAACwkB,WAAD,CAAX;AACH;AACJ;AAIJ,OAjFD,MAiFO;AACH,YACI,CAACC,+BAAD,IACA9Y,WAAW,CAAC9H,aAAZ,CACI,IAAIxR,qBAAJ,CAA0B;AACtByR,UAAAA,EAAE,EAAE,MADkB;AAEtBC,UAAAA,KAAK,EAAE4H,WAFe;AAGtB3H,UAAAA,IAAI,EAAE,IAHgB;AAItBf,UAAAA,YAAY,EAAEwI;AAJQ,SAA1B,CADJ,CAFJ,EAUE;AACE7S,UAAAA,GAAG,CAAC1J,IAAJ,CAAS8T,wBAAT,CAAkCO,UAAlC,EAA8CkI,KAA9C;AACH;AACJ;AACJ,KA7IO;;AA+IR,mBAAA,GAAa,CACTne,OADS,EAETwE,MAFS;;;AAIT,UAAIxE,OAAJ,EAAa;AACTA,QAAAA,OAAO,CAACuW,aAAR,CAAsB,IAAI1R,mBAAJ,CAAwBL,MAAxB,CAAtB;AACH,OAFD,MAEO;AACH,cAAM2U,IAAI,GAAG,MAAA,KAAKme,QAAL,UAAA,iBAAA,SAAA,MAAejqB,KAA5B;;AAEA,YAAI8L,IAAJ,EAAU;AACN,gBAAM+J,CAAC,GAAG,EAAE,GAAG1e;AAAL,WAAV;AACA,gBAAM+yB,OAAO,GAAGrY,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyCkH,IAAzC,CAAhB;AACA,gBAAMib,WAAW,GAAG,MAAAmD,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAEj1B,SAAT,UAAA,iBAAA,SAAA,MAAoB+e,MAAxC;;AAEA,cAAI+S,WAAJ,EAAiB;AACblR,YAAAA,CAAC,CAACkR,WAAF,GAAgBA,WAAhB;AACH;;AAEDjb,UAAAA,IAAI,CAAC5C,aAAL,CAAmB,IAAIzR,oBAAJ,CAAyBoe,CAAzB,CAAnB;AACH;AACJ;AACJ,KArBD;;AA1lBI,SAAKjR,QAAL,GAAgBlS,OAAhB;AACA,SAAK4X,IAAL,GAAYvM,SAAZ;AACArL,IAAAA,OAAO,CAAC0f,SAAR,CAAkB,KAAKqT,KAAvB;AACH;;AAoBD3yB,EAAAA,OAAO;AACH,UAAMA,OAAN;;AAEA,UAAMkL,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AACA,UAAM5R,GAAG,GAAGsF,GAAG,CAACN,QAAhB;AAEAhF,IAAAA,GAAG,CAACmO,mBAAJ,CAAwB2K,uBAAxB,EAAyC,KAAKvJ,UAA9C,EAA0D,IAA1D;AACAvP,IAAAA,GAAG,CAACmO,mBAAJ,CAAwB4K,wBAAxB,EAA0C,KAAKvJ,WAA/C,EAA4D,IAA5D;AACAlK,IAAAA,GAAG,CAAC6I,mBAAJ,CAAwB,SAAxB,EAAmC,KAAKwiB,UAAxC,EAAoD,IAApD;AAEA,SAAKlP,WAAL,CAAiB,KAAKoP,UAAtB;AAEA,UAAMY,UAAU,GAAG,KAAKC,WAAxB;;AACA,QAAID,UAAJ,EAAgB;AACZnsB,MAAAA,GAAG,CAACa,YAAJ,CAAiBsrB,UAAU,CAAC1M,OAA5B;AACA,aAAO,KAAK2M,WAAZ;AACH;;AAED,WAAOhB,mBAAmB,CAACiB,iBAA3B;AAEA,WAAO,KAAKC,QAAZ;AACA,WAAO,KAAKL,QAAZ;AACH;;AAEqB,SAAfM,eAAe,CAClBld,QADkB,EAElBjU,MAFkB;;;AAIlB,QAAI8K,GAAG,GAAGklB,mBAAmB,CAACiB,iBAA9B;AACA,QAAI5nB,EAAE,GAAGyB,GAAG,IAAIA,GAAG,CAAClE,GAAJ,EAAhB;;AACA,QAAIyC,EAAE,IAAI3G,GAAG,CAACI,YAAJ,CAAiB9C,MAAjB,EAAyBqJ,EAAzB,CAAV,EAAwC;AACpC,aAAO2mB,mBAAmB,CAACiB,iBAA3B;AACH;;AAED5nB,IAAAA,EAAE,GAAG,MAAA,MAAC4K,QAAgC,CAACid,QAAlC,UAAA,iBAAA,SAAA,MAA4C33B,OAA5C,UAAA,iBAAA,SAAA,MAAqDqN,KAA1D;;AACA,QAAIyC,EAAE,IAAI3G,GAAG,CAACI,YAAJ,CAAiB9C,MAAjB,EAAyBqJ,EAAzB,CAAV,EAAwC;AACpC,aAAQ4K,QAAgC,CAACid,QAAzC;AACH;;AAEDpmB,IAAAA,GAAG,GAAImJ,QAAgC,CAAC4c,QAAxC;AACAxnB,IAAAA,EAAE,GAAGyB,GAAG,IAAIA,GAAG,CAAClE,GAAJ,EAAZ;;AACA,QAAIyC,EAAE,IAAI3G,GAAG,CAACI,YAAJ,CAAiB9C,MAAjB,EAAyBqJ,EAAzB,CAAV,EAAwC;AACpC,aAAQ4K,QAAgC,CAAC4c,QAAzC;AACH;AACJ;;AAED3P,EAAAA,iBAAiB;AACb,WAAO,KAAK0B,MAAL,EAAP;AACH;;AAEDhB,EAAAA,qBAAqB;;;AACjB,QAAIvY,EAAE,GAAG,MAAA,KAAKwnB,QAAL,UAAA,iBAAA,SAAA,MAAejqB,KAAxB;;AAEA,QAAI,CAACyC,EAAD,IAAQA,EAAE,IAAI,CAAChD,gBAAgB,CAACgD,EAAE,CAAC7G,aAAJ,EAAmB6G,EAAnB,CAAnC,EAA4D;AACxD,WAAKwnB,QAAL,GAAgBxnB,EAAE,GAAGxP,SAArB;AACH;;AAED,WAAOwP,EAAP;AACH;;AAEDyS,EAAAA,KAAK,CACDviB,OADC,EAED+xB,6BAFC,EAGDC,iBAHC;AAKD,QACI,CAAC,KAAK/f,QAAL,CAAcvP,SAAd,CAAwB0T,WAAxB,CACGpW,OADH,EAEG+xB,6BAFH,EAGG,KAHH,EAIGC,iBAJH,CADL,EAOE;AACE,aAAO,KAAP;AACH;;AAEDhyB,IAAAA,OAAO,CAACuiB,KAAR;AAEA,WAAO,IAAP;AACH;;AAED+C,EAAAA,YAAY,CAACnW,SAAD;AACR,UAAMW,EAAE,GAAG,KAAKmC,QAAL,CAAcvP,SAAd,CAAwBwjB,WAAxB,CAAoC;AAAE/W,MAAAA;AAAF,KAApC,CAAX;;AAEA,QAAIW,EAAJ,EAAQ;AACJ,WAAKmC,QAAL,CAAcwL,cAAd,CAA6B8E,KAA7B,CAAmCzS,EAAnC;;AAEA,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH;;AAED4N,EAAAA,sBAAsB,CAClBjK,OADkB,EAElBzB,KAFkB;;;AAOlB,UAAM;AAAE7C,MAAAA,SAAF;AAAawO,MAAAA;AAAb,QAAqC3L,KAA3C;AACA,QAAIwH,OAAJ;;AAEA,QAAIrK,SAAJ,EAAe;AACX,YAAM7D,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyC9C,SAAzC,CAAZ;;AAEA,UAAI7D,GAAJ,EAAS;AACLkO,QAAAA,OAAO,GAAG,MAAAid,mBAAmB,CAACQ,gBAApB,CACN,KAAKhlB,QADC,EAEN3G,GAFM,EAGN6D,SAHM,EAIN7O,SAJM,EAKNA,SALM,EAMN,CAACmT,OANK,EAONkK,mBAPM,CAAA,UAAA,iBAAA,SAAA,MAQP3d,OARH;AASH;AACJ;;AAED,QAAIwZ,OAAO,IAAI,CAACrQ,GAAG,CAACI,YAAJ,CAAiB4F,SAAjB,EAA4BqK,OAA5B,CAAhB,EAAsD;AAClDA,MAAAA,OAAO,GAAGlZ,SAAV;AACH;;AAED,WAAOkZ,OAAO,IAAIlZ,SAAlB;AACH;;AAEOu3B,EAAAA,iBAAiB,CACrBpkB,OADqB,EAErBzB,KAFqB;AAIrB,UAAMwH,OAAO,GAAG,KAAKkE,sBAAL,CAA4BjK,OAA5B,EAAqCzB,KAArC,CAAhB;;AAEA,QAAIwH,OAAJ,EAAa;AACT,WAAK+I,KAAL,CAAW/I,OAAX,EAAoB,KAApB,EAA2B,IAA3B;AAEA,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH;;AAED6L,EAAAA,UAAU,CAACrT,KAAD;AACN,WAAO,KAAK6lB,iBAAL,CAAuB,IAAvB,EAA6B7lB,KAA7B,CAAP;AACH;;AAED8lB,EAAAA,SAAS,CAAC9lB,KAAD;AACL,WAAO,KAAK6lB,iBAAL,CAAuB,KAAvB,EAA8B7lB,KAA9B,CAAP;AACH;;AAEDwQ,EAAAA,UAAU,CAACrT,SAAD;AACN,QAAI,CAAC,KAAK8C,QAAL,CAAcvP,SAAd,CAAwBsjB,SAAxB,CAAkC7W,SAAlC,CAAL,EAAmD;AAC/C,aAAO,KAAP;AACH;;AAED,QAAI,CAAC,KAAK8C,QAAL,CAAcvP,SAAd,CAAwB0T,WAAxB,CAAoCjH,SAApC,EAA+C,IAA/C,EAAqD,IAArD,EAA2D,IAA3D,CAAL,EAAuE;AACnE,YAAM4oB,YAAY,GAAG5oB,SAAS,CAAC5O,YAAV,CAAuB,UAAvB,CAArB;AACA,YAAMy3B,cAAc,GAAG7oB,SAAS,CAAC5O,YAAV,CAAuB,aAAvB,CAAvB;AAEA4O,MAAAA,SAAS,CAAC+D,QAAV,GAAqB,CAAC,CAAtB;AACA/D,MAAAA,SAAS,CAACgE,YAAV,CAAuB,aAAvB,EAAsC,MAAtC;AAEAsjB,MAAAA,mBAAmB,CAACiB,iBAApB,GAAwC,IAAI3qB,eAAJ,CACpC,KAAK4K,IAD+B,EAEpCxI,SAFoC,CAAxC;AAKA,WAAKoT,KAAL,CAAWpT,SAAX,EAAsB,IAAtB,EAA4B,IAA5B;;AAEA,WAAK8oB,qBAAL,CAA2B9oB,SAA3B,EAAsC,UAAtC,EAAkD4oB,YAAlD;;AACA,WAAKE,qBAAL,CACI9oB,SADJ,EAEI,aAFJ,EAGI6oB,cAHJ;AAKH,KApBD,MAoBO;AACH,WAAKzV,KAAL,CAAWpT,SAAX;AACH;;AAED,WAAO,IAAP;AACH;;AAED+oB,EAAAA,iBAAiB,CACbvH,MADa,EAEb/qB,QAFa,EAGbuyB,KAHa;AAKb,UAAM9sB,GAAG,GAAG,KAAK4G,QAAL,CAAc7G,SAAd,EAAZ;;AACA,UAAMgtB,iBAAiB,GAAG,KAAKX,WAA/B;;AAEA,QAAIW,iBAAJ,EAAuB;AACnB,UACI5B,gCAAgC,CAAC7F,MAAD,CAAhC,GACA6F,gCAAgC,CAAC4B,iBAAiB,CAACzH,MAAnB,CAFpC,EAGE;AACE;AACA;AACH,OAPkB;;;AAUnBtlB,MAAAA,GAAG,CAACa,YAAJ,CAAiBksB,iBAAiB,CAACtN,OAAnC;AACH;;AAED,SAAK2M,WAAL,GAAmB;AACf9G,MAAAA,MADe;AAEf/qB,MAAAA,QAFe;AAGfklB,MAAAA,OAAO,EAAEzf,GAAG,CAACqC,UAAJ,CAAe;AACpB,aAAK+pB,WAAL,GAAmBn3B,SAAnB;AACAsF,QAAAA,QAAQ;AACX,OAHQ,EAGNuyB,KAHM;AAHM,KAAnB;AAQH;;AAEDE,EAAAA,gBAAgB,CAAC1H,MAAD;AACZ,UAAM6G,UAAU,GAAG,KAAKC,WAAxB;;AAEA,QAAI,CAAAD,UAAU,SAAV,IAAAA,UAAU,WAAV,SAAA,GAAAA,UAAU,CAAE7G,MAAZ,MAAuBA,MAA3B,EAAmC;AAC/B,WAAK1e,QAAL,CAAc7G,SAAd,GAA0Bc,YAA1B,CAAuCsrB,UAAU,CAAC1M,OAAlD;;AACA,WAAK2M,WAAL,GAAmBn3B,SAAnB;AACH;AACJ;;AAEO23B,EAAAA,qBAAqB,CACzBj4B,OADyB,EAEzB4b,IAFyB,EAGzBC,KAHyB;AAKzB,QAAIA,KAAK,KAAK,IAAd,EAAoB;AAChB7b,MAAAA,OAAO,CAACic,eAAR,CAAwBL,IAAxB;AACH,KAFD,MAEO;AACH5b,MAAAA,OAAO,CAACmT,YAAR,CAAqByI,IAArB,EAA2BC,KAA3B;AACH;AACJ;;AAEO8a,EAAAA,kBAAkB,CACtB32B,OADsB,EAEtB6S,aAFsB,EAGtBic,yBAHsB;;;AAKtB,QAAI,KAAK7c,QAAL,CAAc5R,KAAlB,EAAyB;AACrB;AACH;;AAED,UAAMmE,MAAM,GAA+B;AAAEqO,MAAAA;AAAF,KAA3C;;AAEA,QAAI7S,OAAJ,EAAa;AACT,YAAMs4B,gBAAgB,GAClB,MAAA7B,mBAAmB,CAACiB,iBAApB,UAAA,iBAAA,SAAA,MAAuCrqB,KAD3C;AAEAopB,MAAAA,mBAAmB,CAACiB,iBAApB,GAAwCp3B,SAAxC;;AAEA,UAAIg4B,gBAAgB,KAAKt4B,OAArB,IAAgCmQ,iBAAiB,CAACnQ,OAAD,CAArD,EAAgE;AAC5D;AACH;;AAEDwE,MAAAA,MAAM,CAACsqB,yBAAP,GAAmCA,yBAAnC;AAEA,YAAMxjB,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyCjS,OAAzC,CAAZ;AAEA,YAAMo0B,WAAW,GAAG,MAAA9oB,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEhJ,SAAL,UAAA,iBAAA,SAAA,MAAgB+e,MAApC;;AAEA,UAAI+S,WAAJ,EAAiB;AACb5vB,QAAAA,MAAM,CAAC4vB,WAAP,GAAqBA,WAArB;AACH;AACJ;;AAED,UAAMmE,OAAO,GAAI,KAAKZ,QAAL,GAAgB;AAC7B33B,MAAAA,OAAO,EAAEA,OAAO,GACV,IAAI+M,eAAJ,CAAoB,KAAK4K,IAAzB,EAA+B3X,OAA/B,CADU,GAEVM,SAHuB;AAI7BkE,MAAAA;AAJ6B,KAAjC;;AAOA,QAAIxE,OAAO,IAAIA,OAAO,KAAK,KAAK8oB,IAAhC,EAAsC;AAClC,WAAK0P,uBAAL,CAA6Bx4B,OAA7B;AACH;AAGD;;;AACA,QAAI,KAAK23B,QAAL,KAAkBY,OAAtB,EAA+B;AAC3B,WAAKrP,MAAL,CAAYlpB,OAAZ,EAAqBwE,MAArB;AACH;;AAED,SAAKmzB,QAAL,GAAgBr3B,SAAhB;AACH;;AAES4oB,EAAAA,MAAM,CACZC,GADY,EAEZ3kB,MAFY;AAIZ,UAAM0kB,MAAN,CAAaC,GAAb,EAAkB3kB,MAAlB;;AAEA,QAAI2kB,GAAJ,EAAS;AACL,WAAKmO,QAAL,GAAgB,IAAIvqB,eAAJ,CAAoB,KAAK4K,IAAzB,EAA+BwR,GAA/B,CAAhB;AACH;AACJ;;AAqBsB,SAAhB8N,gBAAgB,CACnBl3B,OADmB,EAEnBuL,GAFmB,EAGnB6D,SAHmB,EAInBglB,cAJmB,EAKnB7T,gBALmB,EAMnBrK,UANmB,EAOnB0H,mBAPmB;AASnB,UAAM8a,eAAe,GAAGtpB,SAAS,IAAI7D,GAAG,CAAC1J,IAAJ,CAASwQ,UAAT,EAArC;;AAEA,QAAI,CAACqmB,eAAL,EAAsB;AAClB,aAAO,IAAP;AACH;;AAED,QAAI/hB,IAAI,GAA8B,IAAtC;AAEA,UAAMgiB,cAAc,GAAGjC,mBAAmB,CAACkC,eAA3C;AACA,UAAMttB,GAAG,GAAGtL,OAAO,CAACqL,SAAR,EAAZ;;AAEA,QAAIstB,cAAJ,EAAoB;AAChBrtB,MAAAA,GAAG,CAACa,YAAJ,CAAiBwsB,cAAjB;AACH;;AAEDjC,IAAAA,mBAAmB,CAACmC,SAApB,GAAgC,IAAhC;AACAnC,IAAAA,mBAAmB,CAACkC,eAApB,GAAsCttB,GAAG,CAACqC,UAAJ,CAAe;AACjD,aAAO+oB,mBAAmB,CAACkC,eAA3B;AACAlC,MAAAA,mBAAmB,CAACmC,SAApB,GAAgC,KAAhC;AACH,KAHqC,EAGnC,CAHmC,CAAtC;AAKA,UAAMt2B,SAAS,GAAGgJ,GAAG,CAAChJ,SAAtB;AACA,UAAMK,QAAQ,GAAG2I,GAAG,CAAC3I,QAArB;AACA,UAAME,KAAK,GAAGyI,GAAG,CAACzI,KAAlB;;AAEA,UAAMg2B,YAAY,GACd5hB,IADiB;AAGjBP,MAAAA,IAAI,GAAGO,IAAI,CAACggB,gBAAL,CACH9C,cADG,EAEH7T,gBAFG,EAGHrK,UAHG,EAIH0H,mBAJG,CAAP;;AAOA,UAAIwW,cAAc,IAAI,EAACzd,IAAI,SAAJ,IAAAA,IAAI,WAAJ,SAAA,GAAAA,IAAI,CAAE1W,OAAP,CAAtB,EAAsC;AAClC,cAAMuG,aAAa,GACf0Q,IAAI,KAAK3U,SAAT,IACA6G,GAAG,CAACG,gBAAJ,CAAqB2N,IAAI,CAAC7E,UAAL,EAArB,CAFJ;;AAIA,YAAI7L,aAAJ,EAAmB;AACf,gBAAMuyB,SAAS,GAAG5Z,OAAO,CAACiB,iBAAR,CACdpgB,OADc,EAEdo0B,cAFc,EAGd;AAAE7T,YAAAA,gBAAgB,EAAE/Z;AAApB,WAHc,CAAlB;;AAMA,cAAIuyB,SAAJ,EAAe;AACX,kBAAMC,mBAAmB,GAAG9hB,IAAI,CAAC7E,UAAL,EAA5B;AACA,kBAAM4mB,UAAU,GAAG/iB,UAAU,GACvB8iB,mBADuB,GAEtBA,mBAAmB,IAChBrvB,cAAY,CAACqvB,mBAAD,CADhB,IAEAA,mBAJN;;AAMA,gBAAIC,UAAJ,EAAgB;AACZtiB,cAAAA,IAAI,GAAG+f,mBAAmB,CAACQ,gBAApB,CACHl3B,OADG,EAEH+4B,SAFG,EAGH3pB,SAHG,EAIH6pB,UAJG,EAKHzyB,aALG,EAMH0P,UANG,EAOH0H,mBAPG,CAAP;;AAUA,kBAAIjH,IAAJ,EAAU;AACNA,gBAAAA,IAAI,CAACwe,aAAL,GAAqB,IAArB;AACH;AACJ;AACJ;AACJ;AACJ;AACJ,KAhDD;;AAkDA,QAAIvyB,QAAQ,IAAIE,KAAhB,EAAuB;AACnBg2B,MAAAA,YAAY,CAACvtB,GAAG,CAACmV,mBAAJ,GAA0B9d,QAA1B,GAAqCE,KAAtC,CAAZ;AACH,KAFD,MAEO,IAAIF,QAAJ,EAAc;AACjBk2B,MAAAA,YAAY,CAACl2B,QAAD,CAAZ;AACH,KAFM,MAEA,IAAIE,KAAJ,EAAW;AACdg2B,MAAAA,YAAY,CAACh2B,KAAD,CAAZ;AACH,KAFM,MAEA,IAAIP,SAAJ,EAAe;AAClBu2B,MAAAA,YAAY,CAACv2B,SAAD,CAAZ;AACH,KAFM,MAEA;AACH,YAAM22B,SAAS,GAAwB;AACnC9pB,QAAAA,SAAS,EAAEspB,eADwB;AAEnCtE,QAAAA,cAFmC;AAGnC7T,QAAAA,gBAHmC;AAInC3C,QAAAA,mBAJmC;AAKnCkJ,QAAAA,kBAAkB,EAAE;AALe,OAAvC;AAQA,YAAMqS,YAAY,GAAmC,EAArD;AAEA,YAAMhC,WAAW,GAAGn3B,OAAO,CAAC2C,SAAR,CAChBuT,UAAU,GAAG,UAAH,GAAgB,UADV,EAElBgjB,SAFkB,EAEPC,YAFO,CAApB;AAIAxiB,MAAAA,IAAI,GAAG;AACH1W,QAAAA,OAAO,EAAEk3B,WADN;AAEHhC,QAAAA,aAAa,EAAEgE,YAAY,CAAChE,aAFzB;AAGHlyB,QAAAA,YAAY,EAAEk2B,YAAY,CAACl2B;AAHxB,OAAP;AAKH;;AAED,WAAO0T,IAAP;AACH;;;AApdM+f,6BAAA,GAAY,KAAZ;;AC/EX;;;;;AA4BA,MAAM0C,oBAAN,SAAmCpkB,iBAAnC;AACIzQ,EAAAA,YACItE,SACA2C,UACA5C,SACAkC;AAEA,UACIlC,OADJ,EAEIC,OAFJ,EAGI0U,2BAA2B,CAACI,QAHhC,EAII7S,GAJJ,EAKI,IALJ;;AAQA,SAAKoT,YAAL,CACI,CACI0D,UADJ,EAEI9C,UAFJ,EAGIpD,aAHJ;;;AAKI,YAAM1D,SAAS,GAAGnP,OAAO,CAACqN,GAAR,EAAlB;AACA,YAAMsF,KAAK,GAAGoG,UAAU,CAACpG,KAAzB;;AAEA,UAAIxD,SAAS,IAAIwD,KAAjB,EAAwB;AACpB,cAAMrH,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0BpgB,OAA1B,EAAmC4S,KAAnC,CAAZ;;AAEA,YAAIrH,GAAJ,EAAS;AACL,cAAIoL,IAAJ;AAEAA,UAAAA,IAAI,GAAG,MAAA/T,QAAQ,CAACs0B,gBAAT,CACHpkB,aAAa,IAAIvS,SADd,EAEHA,SAFG,EAGH2V,UAHG,EAIH,IAJG,CAAA,UAAA,iBAAA,SAAA,MAKJjW,OALH;;AAOA,cAAI,CAAC0W,IAAL,EAAW;AACPA,YAAAA,IAAI,GAAG,MAAA+f,mBAAmB,CAACQ,gBAApB,CACHl3B,OADG,EAEHuL,GAFG,EAGHhL,SAHG,EAIHyY,UAAU,CAACxG,SAAX,GACMI,KADN,GAEM4I,kBAAkB,CACdpM,SADc,EAEd,CAAC8G,UAFa,CANrB,EAUH3V,SAVG,EAWH2V,UAXG,EAYH,IAZG,CAAA,UAAA,iBAAA,SAAA,MAaJjW,OAbH;AAcH;;AAED,cAAI0W,IAAJ,EAAU;AACNhE,YAAAA,mBAAW,CAACgE,IAAD,CAAX;AACH;AACJ;AACJ;AACJ,KA5CL;AA8CH;;;;MAGQ5B,iBACD/C;AASRzN,EAAAA,YACIvE,SACAC,SACA8d,WACA9L,OACA/P;AAEA,UAAMlC,OAAN,EAAeC,OAAf,EAAwBgS,KAAxB;AAbI,yBAAA,GAAmB,KAAnB;AAcJ,SAAKonB,YAAL,CAAkB,KAAlB;AAEA,SAAK5a,UAAL,GAAkBV,SAAlB;;AAEA,QAAI,CAAC/d,OAAO,CAAC2e,UAAb,EAAyB;AACrB,WAAKO,YAAL,GAAoB,IAAIka,oBAAJ,CAChB,KAAKjnB,QADW,EAEhB,IAFgB,EAGhBnS,OAHgB,EAIhBkC,GAJgB,CAApB;AAMH;AACJ;;AAED9B,EAAAA,OAAO;;;AACH,SAAKqe,UAAL,CAAgB,IAAhB;;AAEA,UAAMxe,OAAO,GAAG,KAAKkS,QAAL,CAAc7E,GAAd,EAAhB;;AACA,UAAA,KAAK4R,YAAL,UAAA,iBAAA,SAAA,MAAmB9e,SAAnB;AACA,WAAO,KAAK8e,YAAZ;;AAEA,QAAIjf,OAAJ,EAAa;AACT,UAAImB,sCAAJ,EAAa;AACT8b,QAAAA,sBAAoB,CAAC,KAAK/K,QAAN,EAAgB,IAAhB,CAApB;AACH;AACJ;;AAED,WAAO,KAAKmnB,MAAZ;AACH;;AAEDpC,EAAAA,gBAAgB,CACZ9C,cADY,EAEZ7T,gBAFY,EAGZrK,UAHY,EAIZ0H,mBAJY;;;AAMZ,UAAMmY,eAAe,GAAG,KAAK1jB,UAAL,EAAxB;;AAEA,QAAI,CAAC0jB,eAAL,EAAsB;AAClB,aAAO,IAAP;AACH;;AAED,UAAMwD,cAAc,GAChB,CAAA,MACInF,cACH,SADG,IAAAA,cAAc,WAAd,SAAA,GAAAA,cAAc,CACfpgB,uBAFH,UAAA,iBAAA,SAAA,MAE4B1G,KAF5B,MAEsCyoB,eAH1C;;AAKA,QACI,CAAC,KAAKyD,gBAAN,IACApF,cADA,IAEAhrB,GAAG,CAACI,YAAJ,CAAiBusB,eAAjB,EAAkC3B,cAAlC,CAFA,IAGA,CAACmF,cAJL,EAKE;AACE,aAAO;AAAEt5B,QAAAA,OAAO,EAAEM,SAAX;AAAsB40B,QAAAA,aAAa,EAAE;AAArC,OAAP;AACH;;AAED,UAAMsE,sBAAsB,GAAG,KAAKC,QAAL,CAAc,IAAd,CAA/B;;AAEA,QACI,CAACtF,cAAD,IACA,CAAChrB,GAAG,CAACI,YAAJ,CAAiBusB,eAAjB,EAAkC3B,cAAlC,CADD,IAEAmF,cAHJ,EAIE;AACE,aAAO;AACHt5B,QAAAA,OAAO,EAAEw5B,sBADN;AAEHtE,QAAAA,aAAa,EAAE;AAFZ,OAAP;AAIH;;AAED,UAAMn1B,OAAO,GAAG,KAAKkS,QAArB;AACA,QAAIyE,IAAI,GAAmC,IAA3C;AACA,QAAIwe,aAAa,GAAG,KAApB;AACA,QAAIlyB,YAAJ;;AAEA,QAAI,KAAKu2B,gBAAL,IAAyBC,sBAA7B,EAAqD;AACjD,YAAMP,SAAS,GAAwB;AACnC9pB,QAAAA,SAAS,EAAE2mB,eADwB;AAEnC3B,QAAAA,cAFmC;AAGnC7T,QAAAA,gBAHmC;AAInC3C,QAAAA,mBAJmC;AAKnCkJ,QAAAA,kBAAkB,EAAE;AALe,OAAvC;AAQA,YAAMqS,YAAY,GAAmC,EAArD;AAEAxiB,MAAAA,IAAI,GAAG3W,OAAO,CAAC2C,SAAR,CAAkBuT,UAAU,GAAG,UAAH,GAAgB,UAA5C,EACHgjB,SADG,EAEHC,YAFG,CAAP;AAKAhE,MAAAA,aAAa,GAAG,CAAC,CAACgE,YAAY,CAAChE,aAA/B;;AAEA,UACI,CAACxe,IAAD,IACA,KAAKvE,MAAL,CAAYiP,WAAZ,KACI5gB,qBAAA,CAA4BjB,gBAHpC,EAIE;AACEmX,QAAAA,IAAI,GAAG3W,OAAO,CAAC2C,SAAR,CAAkBuT,UAAU,GAAG,UAAH,GAAgB,WAA5C,EACH;AACI9G,UAAAA,SAAS,EAAE2mB,eADf;AAEInY,UAAAA,mBAFJ;AAGIkJ,UAAAA,kBAAkB,EAAE;AAHxB,SADG,EAMHqS,YANG,CAAP;AASAhE,QAAAA,aAAa,GAAG,IAAhB;AACH;;AAEDlyB,MAAAA,YAAY,GAAGk2B,YAAY,CAACl2B,YAA5B;AACH;;AAED,WAAO;AACHhD,MAAAA,OAAO,EAAE0W,IADN;AAEH1T,MAAAA,YAFG;AAGHkyB,MAAAA;AAHG,KAAP;AAKH;;AAEDkE,EAAAA,YAAY,CAACM,UAAD;AACR,SAAKH,gBAAL,GAAwBG,UAAU,IAAI,CAAC,KAAKvnB,MAAL,CAAYiP,WAAnD;;AAEA,QAAIjgB,sCAAJ,EAAa;AACT8b,MAAAA,sBAAoB,CAAC,KAAK/K,QAAN,EAAgB,CAAC,KAAKqnB,gBAAtB,CAApB;AACH;AACJ;;AAEDpY,EAAAA,QAAQ,CAACwY,kBAAD;;;AACJ,UAAM35B,OAAO,GAAG,KAAKoS,UAAL,MAAqB,IAArC;AACA,QAAIwnB,cAAc,GAAG,IAArB;;AAEA,SACI,IAAI14B,CAAC,GAAGiI,GAAG,CAACG,gBAAJ,CAAqBtJ,OAArB,CADZ,EAEIkB,CAFJ,EAGIA,CAAC,GAAGiI,GAAG,CAACG,gBAAJ,CAAqBpI,CAArB,CAHR,EAIE;AACE,YAAM24B,CAAC,GAAG,MAAA/5B,mBAAmB,CAAC,KAAKmS,QAAN,EAAgB/Q,CAAhB,CAAnB,UAAA,iBAAA,SAAA,MAAuCyB,QAAjD;;AAIA,UAAIk3B,CAAJ,EAAO;AACH,YAAI,CAACA,CAAC,CAACN,gBAAP,EAAyB;AACrBK,UAAAA,cAAc,GAAG,KAAjB;AACH;AACJ;AACJ;;AAED,QAAI9d,GAAG,GAAG8d,cAAc,GAClB,KAAKznB,MAAL,CAAYiP,WAAZ,GACI,KAAKmY,gBADT,GAEI,KAHc,GAIlBj5B,SAJN;;AAMA,QAAIwb,GAAG,IAAI6d,kBAAX,EAA+B;AAC3B,YAAM7H,OAAO,GAAG,KAAK7f,QAAL,CAAcwL,cAAd,CAA6BkK,iBAA7B,EAAhB;;AAEA,UAAImK,OAAJ,EAAa;AACThW,QAAAA,GAAG,GAAGgW,OAAO,KAAK,KAAK2H,QAAL,CAAc,IAAd,CAAlB;AACH;AACJ;;AAED,WAAO3d,GAAP;AACH;;AAED2d,EAAAA,QAAQ,CAACK,WAAD;;;AACJ,UAAMhE,eAAe,GAAG,KAAK1jB,UAAL,EAAxB;AACA,QAAI6G,KAAJ;;AAEA,QAAI6c,eAAJ,EAAqB;AACjB,UACIgE,WAAW,IACX,KAAK7nB,QAAL,CAAcvP,SAAd,CAAwB0T,WAAxB,CAAoC0f,eAApC,CAFJ,EAGE;AACE,eAAOA,eAAP;AACH;;AAED7c,MAAAA,KAAK,GAAG,MAAA,KAAKogB,MAAL,UAAA,iBAAA,SAAA,MAAahsB,KAArB;;AAEA,UAAI,CAAC4L,KAAL,EAAY;AACRA,QAAAA,KAAK,GACD,KAAKhH,QAAL,CAAcvP,SAAd,CAAwBkkB,SAAxB,CAAkC;AAC9BzX,UAAAA,SAAS,EAAE2mB,eADmB;AAE9BjP,UAAAA,kBAAkB,EAAE;AAFU,SAAlC,KAGMvmB,SAJV;;AAMA,YAAI2Y,KAAJ,EAAW;AACP,eAAK8gB,QAAL,CAAc9gB,KAAd;AACH;AACJ;AACJ;;AAED,WAAOA,KAAP;AACH;;AAED8gB,EAAAA,QAAQ,CAAC/5B,OAAD;AACJ,QAAIA,OAAJ,EAAa;AACT,WAAKq5B,MAAL,GAAc,IAAItsB,eAAJ,CAAoB,KAAKkF,QAAL,CAAc7G,SAAlC,EAA6CpL,OAA7C,CAAd;AACH,KAFD,MAEO;AACH,aAAO,KAAKq5B,MAAZ;AACH;AACJ;;AAEDxD,EAAAA,aAAa,CACT71B,OADS,EAET4tB,KAFS;AAIT,UAAM8G,eAAe,GAAG9G,KAAK,CAAC8G,eAA9B;AAEA,UAAMnuB,aAAa,GAAG4C,GAAG,CAACG,gBAAJ,CAAqB,KAAK8I,UAAL,EAArB,CAAtB;AACA,UAAM0mB,SAAS,GACXvyB,aAAa,IACb2Y,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyC1L,aAAzC,CAFJ;AAGA,UAAMyzB,iBAAiB,GAAGlB,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAEn2B,QAArC;AACA,UAAMs3B,cAAc,GAAG,CAAAnB,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAErY,mBAAX,IACjBuZ,iBADiB,GAEjB15B,SAFN;AAGA,QAAI45B,qBAAJ;;AAEA,UAAMC,WAAW,GAAIx3B,QAAD;AAChB,UAAIyL,MAAM,GAAGsmB,eAAe,CAAC/xB,QAAQ,CAAC6E,EAAV,CAA5B;AACA,UAAI2Z,QAAJ;;AAEA,UAAI/S,MAAJ,EAAY;AACR+S,QAAAA,QAAQ,GAAG/S,MAAM,CAAC+S,QAAlB;AACH,OAFD,MAEO;AACHA,QAAAA,QAAQ,GAAG,KAAKA,QAAL,CAAc,IAAd,CAAX;AAEA/S,QAAAA,MAAM,GAAGsmB,eAAe,CAAC/xB,QAAQ,CAAC6E,EAAV,CAAf,GAA+B;AACpC2Z,UAAAA;AADoC,SAAxC;AAGH;;AAED,aAAOA,QAAP;AACH,KAfD;;AAiBA,QAAI8Y,cAAJ,EAAoB;AAChBC,MAAAA,qBAAqB,GAAGD,cAAc,CAAC7nB,UAAf,EAAxB;;AAEA,UACI,CAAC+nB,WAAW,CAACF,cAAD,CAAZ,IACAC,qBADA,IAEAtM,KAAK,CAACze,SAAN,KAAoB+qB,qBAFpB,IAGA/wB,GAAG,CAACI,YAAJ,CAAiBqkB,KAAK,CAACze,SAAvB,EAAkC+qB,qBAAlC,CAJJ,EAKE;AACE;AACAtM,QAAAA,KAAK,CAACyH,gBAAN,GAAyB,IAAzB;AACA,eAAOrqB,UAAU,CAACyqB,aAAlB;AACH;AACJ;;AAED,UAAMtU,QAAQ,GAAGgZ,WAAW,CAAC,IAAD,CAA5B;AACA,UAAMrE,eAAe,GAAG,KAAK1jB,UAAL,EAAxB;;AAEA,QAAI0jB,eAAJ,EAAqB;AACjB,UAAI3U,QAAQ,KAAK,IAAjB,EAAuB;AACnB,YAAI2U,eAAe,KAAK91B,OAApB,IAA+Bg6B,iBAAnC,EAAsD;AAClD,cAAI,CAACE,qBAAL,EAA4B;AACxBA,YAAAA,qBAAqB,GAAGF,iBAAiB,CAAC5nB,UAAlB,EAAxB;AACH;;AAED,cACI8nB,qBAAqB,IACrB,CAACC,WAAW,CAACH,iBAAD,CADZ,IAEA7wB,GAAG,CAACI,YAAJ,CACIqkB,KAAK,CAACze,SADV,EAEI+qB,qBAFJ,CAFA,IAMAA,qBAAqB,KAAKtM,KAAK,CAACze,SAPpC,EAQE;AACEye,YAAAA,KAAK,CAACyH,gBAAN,GAAyB,IAAzB;AACA,mBAAOrqB,UAAU,CAACyqB,aAAlB;AACH;AACJ;;AAED,YACIK,eAAe,KAAK91B,OAApB,IACAmJ,GAAG,CAACI,YAAJ,CAAiBusB,eAAjB,EAAkC91B,OAAlC,CAFJ,EAGE;AACE4tB,UAAAA,KAAK,CAACyH,gBAAN,GAAyB,IAAzB;AACA,iBAAOrqB,UAAU,CAACyqB,aAAlB;AACH;;AAED,cAAMrnB,MAAM,GAAGsmB,eAAe,CAAC,KAAKltB,EAAN,CAA9B;AACA,YAAIyR,KAAJ;;AAEA,YAAI,WAAW7K,MAAf,EAAuB;AACnB6K,UAAAA,KAAK,GAAG7K,MAAM,CAAC6K,KAAf;AACH,SAFD,MAEO;AACHA,UAAAA,KAAK,GAAG7K,MAAM,CAAC6K,KAAP,GAAe,KAAKwgB,QAAL,CAAc,IAAd,CAAvB;AACH;;AAED,YAAIxgB,KAAK,IAAI2U,KAAK,CAACkG,eAAN,CAAsB7a,KAAtB,CAAb,EAA2C;AACvC2U,UAAAA,KAAK,CAAC8H,kBAAN,GAA2BI,eAA3B;AACAlI,UAAAA,KAAK,CAACyH,gBAAN,GAAyB,IAAzB;;AAEA,cAAIpc,KAAK,KAAK2U,KAAK,CAAC3T,IAApB,EAA0B;AACtB2T,YAAAA,KAAK,CAACsG,KAAN,GAAc,IAAd;AACAtG,YAAAA,KAAK,CAACmH,YAAN,GAAqB9b,KAArB;AACA,mBAAOjO,UAAU,CAACoqB,aAAlB;AACH,WAJD,MAIO;AACH,mBAAOpqB,UAAU,CAACyqB,aAAlB;AACH;AACJ;AACJ;AACJ;;AAED,WAAOn1B,SAAP;AACH;;;;MAQQ85B;AAOT91B,EAAAA,YAAYvE,SAA4BqL;AAHhC,iBAAA,GAA2C,EAA3C;AACA,mBAAA,GAA6C,EAA7C;;AAQA,cAAA,GAAQ;AACZ,YAAMC,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;;AAGA,WAAK1F,QAAL,CAAcwL,cAAd,CAA6BwL,cAA7B,CAA4C,KAAKjQ,QAAjD;;AAEA,YAAMjT,GAAG,GAAGsF,GAAG,CAACN,QAAhB;AAEA,YAAMlE,aAAa,GAAGsC,GAAG,CAACK,gBAAJ,CAAqBzD,GAArB,CAAtB;;AAEA,UAAIc,aAAJ,EAAmB;AACf,aAAKmS,QAAL,CAAcnS,aAAd;AACH;;AAEDd,MAAAA,GAAG,CAAC6N,gBAAJ,CAAqB,WAArB,EAAkC,KAAKymB,YAAvC,EAAqD,IAArD;AACAhvB,MAAAA,GAAG,CAACuI,gBAAJ,CAAqB,SAArB,EAAgC,KAAK8iB,UAArC,EAAiD,IAAjD;AACArrB,MAAAA,GAAG,CAACuI,gBAAJ,CAAqB7P,0BAArB,EAAiD,KAAKu2B,YAAtD;AACH,KAjBO;;AA8FA,2BAAA,GAAsB33B,QAAD;AACzB,aAAO,KAAK43B,UAAL,CAAgB53B,QAAQ,CAAC6E,EAAzB,CAAP;AACH,KAFO;;AAIA,iBAAA,GAAYxH,OAAD;AACf,UAAIA,OAAJ,EAAa;AACT,aAAKw6B,cAAL,CAAoBx6B,OAApB,EAA6B,IAA7B,EAAmC,IAAnC;AACH;AACJ,KAJO;;AAMA,qBAAA,GAAgBkB,CAAD;AACnB,UAAIA,CAAC,CAACsL,MAAN,EAAc;AACV,aAAKguB,cAAL,CAAoBt5B,CAAC,CAACsL,MAAtB,EAA6C,IAA7C;AACH;AACJ,KAJO;;AA4DA,mBAAA,GAAc2R,KAAD;AACjB,UAAIA,KAAK,CAAC1c,GAAN,KAAcw0B,IAAI,CAACx2B,KAAnB,IAA4B0e,KAAK,CAAC1c,GAAN,KAAcw0B,IAAI,CAACv2B,MAAnD,EAA2D;AACvD;AACH;;;AAGD,UAAIye,KAAK,CAAC2Y,OAAN,IAAiB3Y,KAAK,CAACsc,MAAvB,IAAiCtc,KAAK,CAAC6Y,QAAvC,IAAmD7Y,KAAK,CAACuc,OAA7D,EAAsE;AAClE;AACH;;AAED,YAAM16B,OAAO,GAAG,KAAKiS,QAAL,CAAcwL,cAAd,CAA6BkK,iBAA7B,EAAhB;;AAEA,UAAI3nB,OAAJ,EAAa;AACT,aAAK26B,cAAL,CAAoB36B,OAApB,EAA6Bme,KAA7B;AACH;AACJ,KAfO;;AAiBA,qBAAA,GAAgBjd,CAAD;;;AACnB,YAAMlB,OAAO,GAAGkB,CAAC,CAACqd,YAAF,GAAiB,CAAjB,CAAhB;AACA,YAAMqc,MAAM,GAAG,MAAA15B,CAAC,CAACsD,MAAF,UAAA,iBAAA,SAAA,MAAUo2B,MAAzB;;AAEA,UAAI56B,OAAO,IAAI46B,MAAM,KAAKt6B,SAAtB,IAAmC,CAACY,CAAC,CAAC25B,gBAA1C,EAA4D;AACxD,YAAID,MAAM,KAAKp6B,wBAAA,CAA+Bf,KAA9C,EAAqD;AACjD,eAAKq7B,cAAL,CAAoB96B,OAApB;AACH,SAFD,MAEO;AACH,eAAK+6B,eAAL,CAAqB/6B,OAArB;AACH;;AAEDkB,QAAAA,CAAC,CAAC4lB,wBAAF;AACH;AACJ,KAbO;;AA1LJ,SAAK7U,QAAL,GAAgBlS,OAAhB;AACA,SAAK4X,IAAL,GAAYvM,SAAZ;AACArL,IAAAA,OAAO,CAAC0f,SAAR,CAAkB,KAAKqT,KAAvB;AACH;;AAqBD3yB,EAAAA,OAAO;AACH,UAAMkL,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,SAAK1F,QAAL,CAAcwL,cAAd,CAA6B4a,gBAA7B,CACI73B,iBAAA,CAAwB1D,cAD5B;;AAIA,SAAKk+B,QAAL,GAAgB,EAAhB;;AAEA,QAAI,KAAK5iB,YAAT,EAAuB;AACnB/M,MAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAKkM,YAAtB;AACA,aAAO,KAAKA,YAAZ;AACH;;AAED,SAAKnG,QAAL,CAAcwL,cAAd,CAA6B+J,WAA7B,CAAyC,KAAKxO,QAA9C;;AAEA3N,IAAAA,GAAG,CAACN,QAAJ,CAAamJ,mBAAb,CAAiC,WAAjC,EAA8C,KAAKmmB,YAAnD,EAAiE,IAAjE;AACAhvB,IAAAA,GAAG,CAAC6I,mBAAJ,CAAwB,SAAxB,EAAmC,KAAKwiB,UAAxC,EAAoD,IAApD;AACArrB,IAAAA,GAAG,CAAC6I,mBAAJ,CAAwBnQ,0BAAxB,EAAoD,KAAKu2B,YAAzD;AAEA54B,IAAAA,MAAM,CAACC,IAAP,CAAY,KAAK44B,UAAjB,EAA6B7a,OAA7B,CAAsCub,UAAD;AACjC,UAAI,KAAKV,UAAL,CAAgBU,UAAhB,CAAJ,EAAiC;AAC7B,aAAKV,UAAL,CAAgBU,UAAhB,EAA4B96B,OAA5B;;AACA,eAAO,KAAKo6B,UAAL,CAAgBU,UAAhB,CAAP;AACH;AACJ,KALD;AAMH;;AAEDr4B,EAAAA,cAAc,CACV5C,OADU,EAEVgS,KAFU,EAGV/P,GAHU;AAKV,QAAId,sCAAJ,EAAa;;AAIb,UAAM+5B,WAAW,GAAG,IAAIpmB,QAAJ,CAChB,KAAK7C,QADW,EAEhBjS,OAFgB,EAGhB,KAAKm7B,kBAHW,EAIhBnpB,KAJgB,EAKhB/P,GALgB,CAApB;AAQA,SAAKs4B,UAAL,CAAgBW,WAAW,CAAC1zB,EAA5B,IAAkC0zB,WAAlC;;AAEA,UAAMzd,cAAc,GAAG,KAAKxL,QAAL,CAAcwL,cAAd,CAA6BkK,iBAA7B,EAAvB;AAGA;;;AACA,QACIlK,cAAc,IACdtU,GAAG,CAACI,YAAJ,CAAiBvJ,OAAjB,EAA0Byd,cAA1B,CADA,IAEA,CAAC,KAAKrF,YAHV,EAIE;AACE,WAAKA,YAAL,GAAoB,KAAKT,IAAL,GAAYjK,UAAZ,CAAuB;AACvC,eAAO,KAAK0K,YAAZ;;AAEA,YACIqF,cAAc,KACd,KAAKxL,QAAL,CAAcwL,cAAd,CAA6BkK,iBAA7B,EAFJ,EAGE;AACE,eAAK6S,cAAL,CAAoB/c,cAApB,EAAoC,IAApC,EAA0C,IAA1C;AACH;AACJ,OATmB,EASjB,CATiB,CAApB;AAUH;;AAED,WAAOyd,WAAP;AACH;;AAEDE,EAAAA,sBAAsB;AAClB,SAAKJ,QAAL,GAAgB,EAAhB;AACH;;AAkBOR,EAAAA,cAAc,CAClBx6B,OADkB,EAElBq7B,aAFkB,EAGlBC,WAHkB;;;AAKlB,QAAI,KAAKljB,YAAT,EAAuB;AACnB,WAAKT,IAAL,GAAYzL,YAAZ,CAAyB,KAAKkM,YAA9B;;AACA,aAAO,KAAKA,YAAZ;AACH;;AAED,UAAMmjB,MAAM,GAAyB,EAArC;AAEA,QAAIC,QAAQ,GAAG,IAAf;;AAEA,SACI,IAAI1rB,EAAE,GAAG9P,OADb,EAEI8P,EAFJ,EAGIA,EAAE,GAAG3G,GAAG,CAACG,gBAAJ,CAAqBwG,EAArB,CAHT,EAIE;AACE,YAAMnN,QAAQ,GAAG,MAAA7C,mBAAmB,CAAC,KAAKmS,QAAN,EAAgBnC,EAAhB,CAAnB,UAAA,iBAAA,SAAA,MAAwCnN,QAAzD;;AAEA,UAAIA,QAAJ,EAAc;AACV44B,QAAAA,MAAM,CAAC54B,QAAQ,CAAC6E,EAAV,CAAN,GAAsB,IAAtB;;AAEA,YAAIg0B,QAAQ,IAAIF,WAAZ,IAA2BxrB,EAAE,KAAK9P,OAAtC,EAA+C;AAC3Cw7B,UAAAA,QAAQ,GAAG,KAAX;AACH;;AAED,YAAIH,aAAa,IAAI,CAACG,QAAtB,EAAgC;AAC5B,eAAKR,QAAL,CAAcr4B,QAAQ,CAAC6E,EAAvB,IAA6B7E,QAA7B;AACA,gBAAM+2B,UAAU,GACZ/2B,QAAQ,CAACwe,QAAT,MACCnhB,OAAO,KAAK8P,EAAZ,KACI,CAACnN,QAAQ,CAAC0P,QAAT,GAAoBopB,SAArB,IACG94B,QAAQ,CAAC82B,QAAT,CAAkB,KAAlB,MAA6Bz5B,OAFpC,CAFL;AAMA2C,UAAAA,QAAQ,CAACy2B,YAAT,CAAsBM,UAAtB;AACH;;AAED8B,QAAAA,QAAQ,GAAG,KAAX;AACH;AACJ;;AAED,SAAK,MAAMh0B,EAAX,IAAiB9F,MAAM,CAACC,IAAP,CAAY,KAAKq5B,QAAjB,CAAjB,EAA6C;AACzC,YAAMr4B,QAAQ,GAAG,KAAKq4B,QAAL,CAAcxzB,EAAd,CAAjB;;AAEA,UAAI,EAAE7E,QAAQ,CAAC6E,EAAT,IAAe+zB,MAAjB,CAAJ,EAA8B;AAC1B54B,QAAAA,QAAQ,CAACy2B,YAAT,CAAsB,KAAtB;AACAz2B,QAAAA,QAAQ,CAACo3B,QAAT,CAAkBz5B,SAAlB;AACA,eAAO,KAAK06B,QAAL,CAAcxzB,EAAd,CAAP;AACH;AACJ;AACJ;;AAkCOszB,EAAAA,cAAc,CAClB96B,OADkB,EAElB2V,YAFkB;AAIlB,UAAM5V,OAAO,GAAG,KAAKkS,QAArB;AACA,UAAM3G,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0BpgB,OAA1B,EAAmCC,OAAnC,CAAZ;AACA,UAAM2C,QAAQ,GAAG,CAAA2I,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAE3I,QAAL,MAAiB2I,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEoV,mBAAtB,CAAjB;AACA,UAAMoV,eAAe,GAAGnzB,QAAQ,SAAR,IAAAA,QAAQ,WAAR,SAAA,GAAAA,QAAQ,CAAEyP,UAAV,EAAxB;;AAEA,QACIzP,QAAQ,IACRmzB,eADA,KAEC91B,OAAO,KAAK81B,eAAZ,IACInzB,QAAQ,CAAC0P,QAAT,GAAoBopB,SAApB,IACGz7B,OAAO,KAAK2C,QAAQ,CAAC82B,QAAT,CAAkB,KAAlB,CAJpB,CADJ,EAME;AACE,YAAM/iB,IAAI,GAAG3W,OAAO,CAAC2C,SAAR,CAAkBkxB,QAAlB,CAA2B;AACpCzkB,QAAAA,SAAS,EAAE2mB,eADyB;AAEpC3B,QAAAA,cAAc,EAAEn0B,OAFoB;AAGpC6mB,QAAAA,kBAAkB,EAAE;AAHgB,OAA3B,CAAb;;AAMA,UACInQ,IAAI,KACH,CAACf,YAAD,IACIA,YAAY,IACTmgB,eAAe,CAACvf,aAAhB,CACI,IAAIxR,qBAAJ,CAA0B;AACtByR,QAAAA,EAAE,EAAE,UADkB;AAEtBC,QAAAA,KAAK,EAAEqf,eAFe;AAGtBpf,QAAAA,IAHsB;AAItBf,QAAAA;AAJsB,OAA1B,CADJ,CAHJ,CADR,EAYE;AACE,YAAIA,YAAJ,EAAkB;AACd;AACA;AACA;AACA;AACAA,UAAAA,YAAY,CAAC0hB,cAAb;AACA1hB,UAAAA,YAAY,CAACmR,wBAAb;AACH;;AAEDpQ,QAAAA,IAAI,CAAC6L,KAAL;AAEA,eAAO7L,IAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;;AAEOqkB,EAAAA,eAAe,CACnB/6B,OADmB,EAEnB2V,YAFmB,EAGnB+lB,aAHmB;;;AAKnB,UAAM37B,OAAO,GAAG,KAAKkS,QAArB;AACA,UAAM3G,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0BpgB,OAA1B,EAAmCC,OAAnC,CAAZ;AACA,UAAM0gB,mBAAmB,GAAGpV,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEoV,mBAAjC;AACA,QAAI/d,QAAQ,GAAG,CAAA2I,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAE3I,QAAL,KAAiB+d,mBAAhC;AACA,UAAMoV,eAAe,GAAGnzB,QAAQ,SAAR,IAAAA,QAAQ,WAAR,SAAA,GAAAA,QAAQ,CAAEyP,UAAV,EAAxB;;AAEA,QACIzP,QAAQ,IACRmzB,eADA,IAEA3sB,GAAG,CAACI,YAAJ,CAAiBusB,eAAjB,EAAkC91B,OAAlC,CAHJ,EAIE;AACE,UAAI0W,IAAJ;;AAEA,UAAI1W,OAAO,KAAK81B,eAAZ,IAA+B4F,aAAnC,EAAkD;AAC9ChlB,QAAAA,IAAI,GAAG/T,QAAQ,CAAC82B,QAAT,CAAkB,IAAlB,CAAP;AACH,OAFD,MAEO;AACH,cAAMlzB,aAAa,GAAG4C,GAAG,CAACG,gBAAJ,CAAqBwsB,eAArB,CAAtB;AACA,cAAMgD,SAAS,GAAGvyB,aAAa,GACzB2Y,OAAO,CAACiB,iBAAR,CAA0BpgB,OAA1B,EAAmCwG,aAAnC,CADyB,GAEzBjG,SAFN;AAIAqC,QAAAA,QAAQ,GAAGm2B,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAEn2B,QAAtB;AACA+T,QAAAA,IAAI,GAAG/T,QAAQ,SAAR,IAAAA,QAAQ,WAAR,SAAA,GAAAA,QAAQ,CAAE82B,QAAV,CAAmB,IAAnB,CAAP;AACH;;AAED,UACI/iB,IAAI,KACH,CAACf,YAAD,IACIA,YAAY,IACTmgB,eAAe,CAACvf,aAAhB,CACI,IAAIxR,qBAAJ,CAA0B;AACtByR,QAAAA,EAAE,EAAE,UADkB;AAEtBC,QAAAA,KAAK,EAAEqf,eAFe;AAGtBpf,QAAAA,IAHsB;AAItBf,QAAAA;AAJsB,OAA1B,CADJ,CAHJ,CADR,EAYE;AACE,YAAIhT,QAAJ,EAAc;AACVA,UAAAA,QAAQ,CAACy2B,YAAT,CAAsB,KAAtB;;AAEA,cAAI1Y,mBAAJ,EAAyB;AACrB,kBAAA3gB,OAAO,CAACuC,SAAR,UAAA,iBAAA,SAAA,MAAmBojB,UAAUplB,UAA7B;AACH;AACJ,SAPH;AAUE;;;AACAoW,QAAAA,IAAI,CAAC6L,KAAL;AAEA,eAAO7L,IAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;;AAEDilB,EAAAA,SAAS,CACL37B,OADK,EAEL46B,MAFK;AAIL,WAAOA,MAAM,KAAKp6B,wBAAA,CAA+Bf,KAA1C,GACD,KAAKq7B,cAAL,CAAoB96B,OAApB,CADC,GAED,KAAK+6B,eAAL,CAAqB/6B,OAArB,CAFN;AAGH;;AAED26B,EAAAA,cAAc,CACV36B,OADU,EAEVme,KAFU,EAGVud,aAHU;AAKV,UAAM37B,OAAO,GAAG,KAAKkS,QAArB;AACA,UAAM3G,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0BpgB,OAA1B,EAAmCC,OAAnC,CAAZ;;AAEA,QAAIsL,GAAG,KAAK,CAAAA,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAE3I,QAAL,MAAiB2I,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEoV,mBAAtB,CAAL,CAAP,EAAwD;AACpD3gB,MAAAA,OAAO,CAAC0d,cAAR,CAAuB4a,gBAAvB,CACI73B,iBAAA,CAAwB1D,cAD5B;;AAIA,UAAIwO,GAAG,CAACsV,aAAJ,CAAkBzC,KAAlB,CAAJ,EAA8B;AAC1B;AACH;;AAED,UAAIA,KAAK,CAAC1c,GAAN,KAAcw0B,IAAI,CAACx2B,KAAvB,EAA8B;AAC1B,aAAKq7B,cAAL,CAAoB96B,OAApB,EAA6Bme,KAA7B;AACH,OAFD,MAEO,IAAIA,KAAK,CAAC1c,GAAN,KAAcw0B,IAAI,CAACv2B,MAAvB,EAA+B;AAClC;AACA;AACA,cAAM+d,cAAc,GAChB1d,OAAO,CAAC0d,cAAR,CAAuBkK,iBAAvB,EADJ;AAGA5nB,QAAAA,OAAO,CAAC0d,cAAR,CAAuBya,iBAAvB,CACI13B,iBAAA,CAAwB1D,cAD5B,EAEI;AACI,cACI2gB,cAAc,KACV1d,OAAO,CAAC0d,cAAR,CAAuBkK,iBAAvB,EADJ;AAGA;AACE+T,UAAAA,aAAa,IAAI,CAACje,cAAnB,IACG,CAACie,aALL,CADJ,EAOE;AACE;AACA;AACH;;AAED,eAAKX,eAAL,CAAqB/6B,OAArB,EAA8Bme,KAA9B,EAAqCud,aAArC;AACH,SAhBL,EAiBI,CAjBJ;AAmBH;AACJ;AACJ;;;;AAGL,SAASze,sBAAT,CACIC,WADJ,EAEIhF,MAFJ;AAII,MAAI/W,sCAAJ,EAAa;AACT,UAAMnB,OAAO,GAAGkd,WAAW,CAAC7P,GAAZ,EAAhB;;AAEA,QAAIrN,OAAJ,EAAa;AACT,UAAIkY,MAAJ,EAAY;AACRlY,QAAAA,OAAO,CAACoT,KAAR,CAAc+J,cAAd,CAA6B,oBAA7B;AACH,OAFD,MAEO;AACHnd,QAAAA,OAAO,CAACoT,KAAR,CAAcI,WAAd,CAA0B,oBAA1B,EAAgD,WAAhD;AACH;AACJ;AACJ;AACJ;;ACtzBD;;;;MAUaooB,gCACDhT;AAKRtkB,EAAAA,YAAY8G;AACR;;AAiBI,kBAAA,GAAaub,wBAAD;AAChB,WAAKuC,MAAL,CAAYvC,wBAAZ,EAAsCrmB,SAAtC;AACH,KAFO;;AAhBJ,SAAKu7B,QAAL,GAAgBC,qBAAa,CAAC1wB,SAAS,EAAV,CAA7B;;AACA,SAAKywB,QAAL,CAAc1U,SAAd,CAAwB,KAAK4U,SAA7B;AACH;;AAED57B,EAAAA,OAAO;AACH,UAAMA,OAAN;;AAEA,QAAI,KAAK07B,QAAT,EAAmB;AACf,WAAKA,QAAL,CAAcrU,WAAd,CAA0B,KAAKuU,SAA/B;;AAEAC,MAAAA,sBAAc,CAAC,KAAKH,QAAN,CAAd;AAEA,aAAO,KAAKA,QAAZ;AACH;AACJ;;AAMDre,EAAAA,yBAAyB,CAACmJ,wBAAD;;;AACrB,UAAA,KAAKkV,QAAL,UAAA,iBAAA,SAAA,MAAe3S,OAAOvC,yBAAtB;AACH;;AAEDA,EAAAA,wBAAwB;;;AACpB,WAAO,CAAC,EAAC,MAAA,KAAKkV,QAAL,UAAA,iBAAA,SAAA,MAAelV,0BAAhB,CAAR;AACH;;;;AC5CL;;;;AA2BA,IAAIsV,kBAAkB,GAAG,CAAzB;AAEA,MAAMC,WAAW,GAAG,aAApB;;AAEA,SAASjf,oBAAT,CACIC,WADJ,EAEIhF,MAFJ,EAGIikB,UAHJ,EAII9a,MAJJ,EAKIF,QALJ,EAMIib,UANJ;AAQI,MAAIj7B,sCAAJ,EAAa;AACT,UAAMnB,OAAO,GAAGkd,WAAW,CAAC7P,GAAZ,EAAhB;;AAEA,QAAIrN,OAAJ,EAAa;AACT,UAAIkY,MAAJ,EAAY;AACRlY,QAAAA,OAAO,CAACoT,KAAR,CAAc+J,cAAd,CAA6B,qBAA7B;AACH,OAFD,MAEO;AACHnd,QAAAA,OAAO,CAACoT,KAAR,CAAcI,WAAd,CACI,qBADJ,EAEI2oB,UAAU,GACN,GADJ,GAEI9a,MAFJ,GAGI,GAHJ,IAIKF,QAAQ,GAAG,QAAH,GAAc,UAJ3B,IAKI,GALJ,GAMI,GANJ,IAOKib,UAAU,cAAcA,aAAd,GAA8B,aAP7C,CAFJ;AAWH;AACJ;AACJ;AACJ;AAED;;;;;AAGA,MAAMC,qBAAN,SAAoCtnB,iBAApC;AACIzQ,EAAAA,YACItE,SACAD,SACAkC;AAEA,UAAMlC,OAAN,EAAeC,OAAf,EAAwB0U,2BAA2B,CAACE,SAApD,EAA+D3S,GAA/D;;AAEA,SAAKoT,YAAL,CAAkB,CAAC0D,UAAD,EAAyB9C,UAAzB;;;AACd,YAAMnG,EAAE,GAAG9P,OAAO,CAACqN,GAAR,EAAX;AACA,YAAM8B,SAAS,GAAGW,EAAE,KAAI,MAAAoP,OAAO,CAACyC,OAAR,CAAgB5hB,OAAhB,EAAyB+P,EAAzB,CAAA,UAAA,iBAAA,SAAA,MAA8BsC,YAAlC,CAApB;AACA,YAAMO,KAAK,GAAGoG,UAAU,CAACpG,KAAzB;AACA,UAAI6G,OAAJ;;AAEA,UAAIrK,SAAS,IAAIwD,KAAjB,EAAwB;AACpB,cAAM2pB,cAAc,GAAG,MACnB3pB,KACH,CAACoB,uBAFqB,UAAA,iBAAA,SAAA,MAEI1G,KAF3B;AAIA,cAAM/B,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CACRpgB,OADQ,EAERu8B,cAAc,IAAI3pB,KAFV,CAAZ;;AAKA,YAAIrH,GAAJ,EAAS;AACLkO,UAAAA,OAAO,GAAG,MAAAid,mBAAmB,CAACQ,gBAApB,CACNl3B,OADM,EAENuL,GAFM,EAGN6D,SAHM,EAINwD,KAJM,EAKNrS,SALM,EAMN2V,UANM,EAON,IAPM,CAAA,UAAA,iBAAA,SAAA,MAQPjW,OARH;AASH;;AAED,YAAIwZ,OAAJ,EAAa;AACT9G,UAAAA,mBAAW,CAAC8G,OAAD,CAAX;AACH;AACJ;AACJ,KAhCD;AAiCH;;;;MAGQ5E,kBACD7C;AAYRzN,EAAAA,YACIvE,SACAC,SACA8d,WACA9L,OACA/P,KACAs6B;AAEA,UAAMx8B,OAAN,EAAeC,OAAf,EAAwBgS,KAAxB;AAdI,oBAAA,GAAc,CAAd;AAgBJ,SAAKqP,MAAL,GAAcrP,KAAK,CAACxK,EAApB;AACA,SAAKgX,UAAL,GAAkBV,SAAlB;AACA,SAAK0e,eAAL,GAAuBD,cAAvB;;AAEA,QAAI,CAACx8B,OAAO,CAAC2e,UAAb,EAAyB;AACrB,WAAKO,YAAL,GAAoB,IAAIod,qBAAJ,CAChB,KAAKnqB,QADW,EAEhBnS,OAFgB,EAGhBkC,GAHgB,CAApB;AAKH;;AAED,QAAId,sCAAJ,EAAa;AACT8b,MAAAA,oBAAoB,CAChB,KAAK/K,QADW,EAEhB,KAFgB,EAGhB,KAAK1K,EAHW,EAIhB,KAAK6Z,MAJW,EAKhB,KAAK8D,SALW,EAMhB,KAAKsX,WANW,CAApB;AAQH;AACJ;;AAEDC,EAAAA,UAAU,CAACvb,QAAD;AACN,QAAI,KAAKgE,SAAL,KAAmBhE,QAAvB,EAAiC;AAC7B,WAAKgE,SAAL,GAAiBhE,QAAjB;AAEA,YAAMnhB,OAAO,GAAG,KAAKoS,UAAL,EAAhB;;AAEA,UAAIpS,OAAJ,EAAa;AACT,cAAMu8B,cAAc,GAAG,KAAKC,eAA5B;AACA,cAAMzX,KAAK,GAAGwX,cAAc,CACvBrlB,GADS,CACJhW,CAAD,IAAOA,CAAC,CAACmM,GAAF,EADF,EAET2b,OAFS,CAEDhpB,OAFC,CAAd;;AAIA,YAAImhB,QAAJ,EAAc;AACV,cAAI4D,KAAK,GAAG,CAAZ,EAAe;AACXwX,YAAAA,cAAc,CAACrvB,IAAf,CACI,IAAIH,eAAJ,CACI,KAAKkF,QAAL,CAAc7G,SADlB,EAEIpL,OAFJ,CADJ;AAMH;AACJ,SATD,MASO;AACH,cAAI+kB,KAAK,IAAI,CAAb,EAAgB;AACZwX,YAAAA,cAAc,CAACjZ,MAAf,CAAsByB,KAAtB,EAA6B,CAA7B;AACH;AACJ;AACJ;;AAED,UAAI5jB,sCAAJ,EAAa;AACT8b,QAAAA,oBAAoB,CAChB,KAAK/K,QADW,EAEhB,KAFgB,EAGhB,KAAK1K,EAHW,EAIhB,KAAK6Z,MAJW,EAKhB,KAAK8D,SALW,EAMhB,KAAKsX,WANW,CAApB;AAQH;;AAED,WAAKE,cAAL,CAAoBxb,QAApB;AACH;AACJ;;AAED2Q,EAAAA,OAAO,CAAC8K,WAAD;AACH,QAAI,CAACA,WAAL,EAAkB;AACd,WAAKH,WAAL,GAAmB,EAAER,kBAArB;AACH;;AAED,WAAO,KAAKQ,WAAZ;AACH;;AAEDt6B,EAAAA,QAAQ,CAAC6P,KAAD;AACJ,QAAIA,KAAK,CAACxK,EAAV,EAAc;AACV,WAAK6Z,MAAL,GAAcrP,KAAK,CAACxK,EAApB;AACH;;AAED,SAAK2K,MAAL,GAAc,EAAE,GAAGH;AAAL,KAAd;AACH;;AAED7R,EAAAA,OAAO;;;AACH,SAAKu8B,UAAL,CAAgB,KAAhB;;AACA,SAAKle,UAAL,CAAgB,IAAhB;;AACA,UAAA,KAAKS,YAAL,UAAA,iBAAA,SAAA,MAAmB9e,SAAnB;AACA,WAAO,KAAK8e,YAAZ;AACA,SAAKud,eAAL,GAAuB,EAAvB;;AACA,SAAKxd,OAAL;AACH;;AAEDmC,EAAAA,QAAQ;AACJ,WAAO,CAAC,CAAC,KAAKgE,SAAd;AACH;;AAEDxe,EAAAA,QAAQ,CAAC3G,OAAD;AACJ,WAAOmJ,GAAG,CAACI,YAAJ,CAAiB,KAAK6I,UAAL,EAAjB,EAAoCpS,OAApC,CAAP;AACH;;AAEDi3B,EAAAA,gBAAgB,CACZ9C,cADY,EAEZ7T,gBAFY,EAGZrK,UAHY,EAIZ0H,mBAJY;;;AAMZ,UAAMkf,gBAAgB,GAAG,KAAKzqB,UAAL,EAAzB;;AAEA,QAAI,CAACyqB,gBAAL,EAAuB;AACnB,aAAO,IAAP;AACH;;AAED,UAAM98B,OAAO,GAAG,KAAKkS,QAArB;AACA,QAAIyE,IAAI,GAAmC,IAA3C;AACA,QAAIwe,aAAa,GAAG,KAApB;AACA,QAAIlyB,YAAJ;AAEA,UAAMmM,SAAS,GACXglB,cAAc,KACd,MAAAjV,OAAO,CAACyC,OAAR,CAAgB5hB,OAAhB,EAAyBo0B,cAAzB,CAAA,UAAA,iBAAA,SAAA,MAA0C/hB,YAD5B,CADlB;;AAIA,QAAIjD,SAAJ,EAAe;AACX,YAAM8pB,SAAS,GAAwB;AACnC9pB,QAAAA,SADmC;AAEnCglB,QAAAA,cAFmC;AAGnC7T,QAAAA,gBAHmC;AAInC3C,QAAAA,mBAJmC;AAKnCkJ,QAAAA,kBAAkB,EAAE;AALe,OAAvC;AAQA,YAAMqS,YAAY,GAAmC,EAArD;AAEAxiB,MAAAA,IAAI,GAAG3W,OAAO,CAAC2C,SAAR,CAAkBuT,UAAU,GAAG,UAAH,GAAgB,UAA5C,EACHgjB,SADG,EAEHC,YAFG,CAAP;;AAKA,UAAI,CAACxiB,IAAD,IAAS,KAAKvE,MAAL,CAAY2qB,SAArB,KAAkC,MAAA/8B,OAAO,CAACuC,SAAR,UAAA,iBAAA,SAAA,MAAmBgf,QAArD,CAAJ,EAAmE;AAC/D5K,QAAAA,IAAI,GAAG3W,OAAO,CAAC2C,SAAR,CAAkBuT,UAAU,GAAG,UAAH,GAAgB,WAA5C,EACH;AACI9G,UAAAA,SADJ;AAEIwO,UAAAA,mBAFJ;AAGIkJ,UAAAA,kBAAkB,EAAE;AAHxB,SADG,EAMHqS,YANG,CAAP;AASAhE,QAAAA,aAAa,GAAG,IAAhB;AACH,OAXD,MAWO;AACHA,QAAAA,aAAa,GAAG,CAAC,CAACgE,YAAY,CAAChE,aAA/B;AACH;;AAEDlyB,MAAAA,YAAY,GAAGk2B,YAAY,CAACl2B,YAA5B;AACH;;AAED,WAAO;AACHhD,MAAAA,OAAO,EAAE0W,IADN;AAEH1T,MAAAA,YAFG;AAGHkyB,MAAAA;AAHG,KAAP;AAKH;;AAEOyH,EAAAA,cAAc,CAACxb,QAAD,EAAoB4b,WAApB;AAClB,UAAM/8B,OAAO,GAAG,KAAKoS,UAAL,EAAhB;AACA,QAAIyoB,gBAAgB,GAAG,KAAvB;;AAEA,QAAI76B,OAAJ,EAAa;AACT,YAAMs0B,QAAQ,GAAGyI,WAAW,GACtB,KAAKP,eAAL,CAAqBtlB,GAArB,CAA0BhW,CAAD,IAAOA,CAAC,CAACmM,GAAF,EAAhC,CADsB,GAEtB,CAACrN,OAAD,CAFN;;AAIA,WAAK,MAAM8P,EAAX,IAAiBwkB,QAAjB,EAA2B;AACvB,YAAIxkB,EAAJ,EAAQ;AACJ,gBAAMktB,WAAW,GAAyB;AACtCx1B,YAAAA,EAAE,EAAE,KAAK6Z,MAD6B;AAEtCrhB,YAAAA;AAFsC,WAA1C;AAKA,gBAAMme,KAAK,GAAGgD,QAAQ,GAChB,IAAI/b,oBAAJ,CAAyB43B,WAAzB,CADgB,GAEhB,IAAI33B,sBAAJ,CAA2B23B,WAA3B,CAFN;AAIAltB,UAAAA,EAAE,CAACyG,aAAH,CAAiB4H,KAAjB;;AAEA,cAAIA,KAAK,CAAC0c,gBAAV,EAA4B;AACxBA,YAAAA,gBAAgB,GAAG,IAAnB;AACH;AACJ;AACJ;AACJ;;AAED,WAAOA,gBAAP;AACH;;AAEO7b,EAAAA,OAAO;AACX,QAAI7d,sCAAJ,EAAa;AACT8b,MAAAA,oBAAoB,CAAC,KAAK/K,QAAN,EAAgB,IAAhB,CAApB;AACH;AACJ;;;;MAQQ+qB;AAgBT34B,EAAAA,YACIvE;AAEAm9B,EAAAA,0BACAC;AAgGI,4BAAA,GAAuB76B,SAAD;AAC1B,YAAMkF,EAAE,GAAGlF,SAAS,CAACkF,EAArB;AACA,YAAM6Z,MAAM,GAAG/e,SAAS,CAAC+e,MAAzB;AACA,YAAMvf,IAAI,GAAG,KAAKs7B,MAAL,CAAY/b,MAAZ,CAAb;AAEA,aAAO,KAAKgc,WAAL,CAAiB71B,EAAjB,CAAP;;AAEA,UAAI1F,IAAJ,EAAU;AACN,eAAOA,IAAI,CAAC0F,EAAD,CAAX;;AAEA,YAAI9F,MAAM,CAACC,IAAP,CAAYG,IAAZ,EAAkBoB,MAAlB,KAA6B,CAAjC,EAAoC;AAChC,iBAAO,KAAKk6B,MAAL,CAAY/b,MAAZ,CAAP;;AAEA,cAAI,KAAKC,QAAL,KAAkBD,MAAtB,EAA8B;AAC1B,iBAAKqE,SAAL,CAAeplB,SAAf;AACH;AACJ;AACJ;AACJ,KAlBO;;AAoBA,mBAAA,GAAc6d,KAAD;;;AACjB,UAAIA,KAAK,CAAC1c,GAAN,KAAcw0B,IAAI,CAACv2B,MAAvB,EAA+B;AAC3B;AACH;;AAED,YAAMK,OAAO,GAAG,KAAKkS,QAArB;AACA,YAAMjS,OAAO,GAAGD,OAAO,CAAC0d,cAAR,CAAuBkK,iBAAvB,EAAhB;;AAEA,UAAI3nB,OAAJ,EAAa;AACT,cAAMsL,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0BpgB,OAA1B,EAAmCC,OAAnC,CAAZ;AACA,cAAMsC,SAAS,GAAGgJ,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEhJ,SAAvB;;AAEA,YACIgJ,GAAG,IACH,CAACA,GAAG,CAAC3I,QADL,KAEAL,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAE6e,QAAX,EAFA,KAGA,CAAC7V,GAAG,CAACsV,aAAJ,CAAkBzC,KAAlB,CAJL,EAKE;AACE,gBAAMmD,QAAQ,GAAGhf,SAAS,CAAC+e,MAA3B;;AAEA,cAAIC,QAAJ,EAAc;AACV,kBAAMxf,IAAI,GAAG,KAAKs7B,MAAL,CAAY9b,QAAZ,CAAb;;AAEA,gBAAIxf,IAAJ,EAAU;AACN,oBAAMw7B,YAAY,GAAG57B,MAAM,CAACC,IAAP,CAAYG,IAAZ,EAChBoV,GADgB,CACX1P,EAAD;;;AACD,sBAAM+1B,CAAC,GAAGz7B,IAAI,CAAC0F,EAAD,CAAd;AACA,sBAAMsI,EAAE,GAAGytB,CAAC,CAACnrB,UAAF,EAAX;AACA,oBAAIzP,QAAJ;;AAEA,oBAAImN,EAAJ,EAAQ;AACJnN,kBAAAA,QAAQ,GAAG,MAAA7C,mBAAmB,CAC1B,KAAKmS,QADqB,EAE1BnC,EAF0B,CAAnB,UAAA,iBAAA,SAAA,MAGRnN,QAHH;AAIH;;AAED,uBAAO46B,CAAC,IAAIztB,EAAL,IAAWnN,QAAX,GACD;AACImN,kBAAAA,EADJ;AAEIwtB,kBAAAA,YAAY,EAAEC,CAAC,CAACzL,OAAF,CAAU,IAAV;AAFlB,iBADC,GAKD;AAAEwL,kBAAAA,YAAY,EAAE;AAAhB,iBALN;AAMH,eAnBgB,EAoBhBr3B,MApBgB,CAoBRu3B,CAAD,IAAOA,CAAC,CAACF,YAAF,GAAiB,CApBf,EAqBhBriB,IArBgB,CAqBX,CAACC,CAAD,EAAIC,CAAJ,KACFD,CAAC,CAACoiB,YAAF,GAAiBniB,CAAC,CAACmiB,YAAnB,GACM,CAAC,CADP,GAEMpiB,CAAC,CAACoiB,YAAF,GAAiBniB,CAAC,CAACmiB,YAAnB,GACA,CADA,GAEA,CA1BO,CAArB;;AA6BA,kBAAIA,YAAY,CAACp6B,MAAjB,EAAyB;AACrB,sBAAM4yB,eAAe,GAAGwH,YAAY,CAAC,CAAD,CAAZ,CAAgBxtB,EAAxC;;AAEA,oBAAIgmB,eAAJ,EAAqB;AACjB,wBAAA/1B,OAAO,CAAC4C,QAAR,UAAA,iBAAA,SAAA,MAAkBg4B,eACd7E,iBACA3X,OACA,KAHJ;AAKH;AACJ;AACJ;AACJ;AACJ;AACJ;AACJ,KApEO;AAqWR;;;;;;;AAKQ,iBAAA,GAAW,CACfV,cADe,EAEfjZ,MAFe;;;AAIf,YAAM8G,GAAG,GACLmS,cAAc,IACdyB,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyCwL,cAAzC,CAFJ;;AAKA,UAAI,CAACnS,GAAD,IAAQ,CAACmS,cAAb,EAA6B;AACzB;AACH;;AAED,YAAMggB,YAAY,GAAG,KAAKC,OAA1B;;AAEA,WACI,IAAIx8B,CAAC,GAAuBuc,cADhC,EAEIvc,CAFJ,EAGIA,CAAC,GAAGiI,GAAG,CAACG,gBAAJ,CAAqBpI,CAArB,CAHR,EAIE;AACE;AACA;AACA;AACA;AAEA,YAAIu8B,YAAY,CAACjmB,GAAb,CAAiBtW,CAAjB,CAAJ,EAAyB;AACrBu8B,UAAAA,YAAY,CAACtlB,MAAb,CAAoBjX,CAApB;AACAya,UAAAA,gBAAgB,CAAC,KAAK1J,QAAN,EAAgB/Q,CAAhB,EAAmBg7B,WAAnB,CAAhB;AACH;AACJ;;AAED,YAAM55B,SAAS,GAAGgJ,GAAG,CAAChJ,SAAtB;AAGA;;AACA,YACIA,SAAS,KACT,MAAAxC,mBAAmB,CAAC,KAAKmS,QAAN,EAAgBwL,cAAhB,CAAnB,UAAA,iBAAA,SAAA,MAAoDnb,SAD3C,CADb,UAAA,iBAAA,SAAA,MAGGwvB,SAHH;;AAKA,UAAI,CAAAxvB,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAE+e,MAAX,MAAsB,KAAKC,QAA/B,EAAyC;AACrC,aAAKqc,yBAAL,GACIr7B,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAE+P,QAAX,GAAsBurB,kBAD1B;AAGA;AACH;;;AAGD,UACIp5B,MAAM,CAACsqB,yBAAP,IACA,KAAK6O,yBADL,KAEAr7B,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAE+P,QAAX,GAAsBwrB,kBAFtB,CADJ,EAIE;AACE,aAAKnY,SAAL,CAAepjB,SAAf;AACH,OAND,MAMO;AACH;AACA,cAAM+I,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AACAtM,QAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAK4xB,2BAAtB,EAHG;AAKH;;AACA,aAAKA,2BAAL,GAAmCzyB,GAAG,CAACqC,UAAJ,CAC/B,MAAM,KAAKqwB,sBAAL,CAA4BtgB,cAA5B,CADyB,EAE/B,GAF+B,CAAnC;AAIH;AACJ,KAjEO;;AA5dJ,SAAKxL,QAAL,GAAgBlS,OAAhB;AACA,SAAK4X,IAAL,GAAY5X,OAAO,CAACqL,SAApB;AACA,SAAKiyB,WAAL,GAAmB,EAAnB;AACA,SAAKD,MAAL,GAAc,EAAd;AACA,SAAKM,OAAL,GAAe,IAAIrxB,OAAJ,EAAf;AACA,SAAK2xB,IAAL,GAAY,EAAZ;AACA,SAAKC,yBAAL,GAAiCf,wBAAjC;AACA,SAAKgB,gBAAL,GAAwBf,eAAxB;AACA,SAAKZ,cAAL,GAAsB,EAAtB;;AAEA,QAAI,CAACx8B,OAAO,CAAC2e,UAAb,EAAyB;AACrB3e,MAAAA,OAAO,CAAC6B,IAAR,CAAagd,cAAb;AACH;;AAED,UAAMvT,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AACAtM,IAAAA,GAAG,CAACuI,gBAAJ,CAAqB,SAArB,EAAgC,KAAK8iB,UAArC,EAAiD,IAAjD;AAEA32B,IAAAA,OAAO,CAAC0f,SAAR,CAAkB;AACd,WAAKxN,QAAL,CAAcwL,cAAd,CAA6B0J,SAA7B,CAAuC,KAAKnO,QAA5C;AACH,KAFD;AAGH;;AAED7Y,EAAAA,OAAO;AACH,UAAMkL,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEAtM,IAAAA,GAAG,CAAC6I,mBAAJ,CAAwB,SAAxB,EAAmC,KAAKwiB,UAAxC,EAAoD,IAApD;;AAGAh1B,IAAAA,MAAM,CAACC,IAAP,CAAY,KAAK07B,WAAjB,EAA8B3d,OAA9B,CAAuC0U,WAAD;AAClC,UAAI,KAAKiJ,WAAL,CAAiBjJ,WAAjB,CAAJ,EAAmC;AAC/B,aAAKiJ,WAAL,CAAiBjJ,WAAjB,EAA8Bj0B,OAA9B;;AACA,eAAO,KAAKk9B,WAAL,CAAiBjJ,WAAjB,CAAP;AACH;AACJ,KALD;AAOA/oB,IAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAK4xB,2BAAtB;AACAzyB,IAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAKiyB,kBAAtB;AAEA,SAAKf,MAAL,GAAc,EAAd;AACA,WAAO,KAAK9b,QAAZ;AACA,SAAKib,cAAL,GAAsB,EAAtB;AAEA,SAAKmB,OAAL,GAAe,IAAIrxB,OAAJ,EAAf;AACA,SAAK2xB,IAAL,GAAY,EAAZ;;AAEA,SAAK/rB,QAAL,CAAcwL,cAAd,CAA6B+J,WAA7B,CAAyC,KAAKxO,QAA9C;AACH;;AAEDzW,EAAAA,eAAe,CACXvC,OADW,EAEXgS,KAFW,EAGX/P,GAHW;;;AAKX,QAAId,sCAAJ,EAAa;;AAIb,UAAMmB,SAAS,GAAG,IAAIsS,SAAJ,CACd,KAAK3C,QADS,EAEdjS,OAFc,EAGd,KAAKo+B,mBAHS,EAIdpsB,KAJc,EAKd/P,GALc,EAMd,KAAKs6B,cANS,CAAlB;AASA,UAAM/0B,EAAE,GAAGlF,SAAS,CAACkF,EAArB;AACA,UAAM6Z,MAAM,GAAGrP,KAAK,CAACxK,EAArB;AAEA,SAAK61B,WAAL,CAAiB71B,EAAjB,IAAuBlF,SAAvB;AAEA,QAAIR,IAAI,GAAG,KAAKs7B,MAAL,CAAY/b,MAAZ,CAAX;;AACA,QAAI,CAACvf,IAAL,EAAW;AACPA,MAAAA,IAAI,GAAG,KAAKs7B,MAAL,CAAY/b,MAAZ,IAAsB,EAA7B;AACH;;AACDvf,IAAAA,IAAI,CAAC0F,EAAD,CAAJ,GAAWlF,SAAX;;AAGA,QACI6G,GAAG,CAACI,YAAJ,CACIvJ,OADJ,EAEI,MAAA,KAAKiS,QAAL,CAAcwL,cAAd,CAA6BkK,iBAA7B,EAAA,UAAA,iBAAA,KAAA,GAAoD,IAFxD,CADJ,EAKE;AACE,UAAItG,MAAM,KAAK,KAAKC,QAApB,EAA8B;AAC1B,aAAKoE,SAAL,CAAepjB,SAAf;AACH,OAFD,MAEO;AACHA,QAAAA,SAAS,CAACo6B,UAAV,CAAqB,IAArB;AACH;AACJ;;AAED,WAAOp6B,SAAP;AACH;;AA4FDmxB,EAAAA,WAAW,CAACzzB,OAAD;AACP,WAAO,KAAK09B,OAAL,CAAalmB,GAAb,CAAiBxX,OAAjB,CAAP;AACH;;AAEDq+B,EAAAA,YAAY;AACR,QAAI,KAAKF,kBAAT,EAA6B;AACzB;AACH;;AAED,SAAKA,kBAAL,GAA0B,KAAKxmB,IAAL,GAAYjK,UAAZ,CAAuB;AAC7C,aAAO,KAAKywB,kBAAZ;;AACA,WAAKG,aAAL;AACH,KAHyB,EAGvB,GAHuB,CAA1B;AAIH;;AAED5Y,EAAAA,SAAS,CAACpjB,SAAD;AACL,UAAM+e,MAAM,GAAG/e,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAE+e,MAA1B;AACA,UAAMC,QAAQ,GAAG,KAAKA,QAAtB;;AAEA,QAAIA,QAAQ,KAAKD,MAAjB,EAAyB;AACrB;AACH;;AAED,SAAKC,QAAL,GAAgBD,MAAhB;;AAEA,QAAIC,QAAJ,EAAc;AACV,YAAMxf,IAAI,GAAG,KAAKs7B,MAAL,CAAY9b,QAAZ,CAAb;;AAEA,UAAIxf,IAAJ,EAAU;AACN,aAAK,MAAM0F,EAAX,IAAiB9F,MAAM,CAACC,IAAP,CAAYG,IAAZ,CAAjB,EAAoC;AAChCA,UAAAA,IAAI,CAAC0F,EAAD,CAAJ,CAASk1B,UAAT,CAAoB,KAApB;AACH;AACJ;AACJ;;AAED,QAAIrb,MAAJ,EAAY;AACR,YAAMvf,IAAI,GAAG,KAAKs7B,MAAL,CAAY/b,MAAZ,CAAb;;AAEA,UAAIvf,IAAJ,EAAU;AACN,aAAK,MAAM0F,EAAX,IAAiB9F,MAAM,CAACC,IAAP,CAAYG,IAAZ,CAAjB,EAAoC;AAChCA,UAAAA,IAAI,CAAC0F,EAAD,CAAJ,CAASk1B,UAAT,CAAoB,IAApB;AACH;AACJ;AACJ;;AAED,SAAKiB,yBAAL,GACIr7B,SAAS,SAAT,IAAAA,SAAS,WAAT,SAAA,GAAAA,SAAS,CAAE+P,QAAX,GAAsBurB,kBAD1B;AAGA,SAAKS,YAAL;AACH;;AAED9b,EAAAA,KAAK,CACDgc,oBADC,EAEDC,YAFC,EAGDC,cAHC;AAKD,UAAMnzB,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CACR,KAAKlO,QADG,EAERssB,oBAFQ,CAAZ;AAKA,UAAMj8B,SAAS,GAAGgJ,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEhJ,SAAvB;;AAEA,QAAIA,SAAJ,EAAe;AACX,WAAKojB,SAAL,CAAepjB,SAAf;AAEA,YAAM0P,KAAK,GAAG1P,SAAS,CAAC+P,QAAV,EAAd;AACA,YAAMqsB,aAAa,GAAGp8B,SAAS,CAAC8P,UAAV,EAAtB;;AAEA,UAAIssB,aAAJ,EAAmB;AACf,YAAIF,YAAY,KAAKl+B,SAArB,EAAgC;AAC5Bk+B,UAAAA,YAAY,GAAGxsB,KAAK,CAAC2sB,cAArB;AACH;;AAED,YACI,CAACH,YAAD,IACA,KAAKvsB,QAAL,CAAcsL,kBAAd,CAAiCoJ,wBAAjC,EADA,IAEA,KAAK1U,QAAL,CAAcwL,cAAd,CAA6B4H,UAA7B,CAAwC;AACpClW,UAAAA,SAAS,EAAEuvB;AADyB,SAAxC,CAHJ,EAME;AACE,iBAAO,IAAP;AACH;;AAED,YAAID,cAAc,KAAKn+B,SAAvB,EAAkC;AAC9Bm+B,UAAAA,cAAc,GAAGzsB,KAAK,CAAC4sB,gBAAvB;AACH;;AAED,YACI,CAACH,cAAD,IACA,KAAKxsB,QAAL,CAAcwL,cAAd,CAA6B6H,YAA7B,CAA0CoZ,aAA1C,CAFJ,EAGE;AACE,iBAAO,IAAP;AACH;;AAED,aAAKzsB,QAAL,CAAcwL,cAAd,CAA6B+E,UAA7B,CAAwCkc,aAAxC;AACH;AACJ,KAlCD,MAkCO,IAAIv9B,sCAAJ,EAAa;AAChBC,MAAAA,OAAO,CAACC,KAAR,CAAc,8BAAd,EAA8Ck9B,oBAA9C;AACH;;AAED,WAAO,KAAP;AACH;;AAED1I,EAAAA,aAAa,CACT71B,OADS,EAET4tB,KAFS;;;AAIT,UAAM6G,eAAe,GAAG7G,KAAK,CAAC6G,eAA9B;AACA,UAAMoK,gBAAgB,GAAG,MAAAjR,KAAK,CAAC+H,UAAN,UAAA,iBAAA,SAAA,MAAkBrzB,SAA3C;;AAEA,QAAImyB,eAAJ,EAAqB;AACjB,WAAK,MAAMvzB,CAAX,IAAgB,KAAKq7B,cAArB,EAAqC;AACjC,cAAMzsB,EAAE,GAAG5O,CAAC,CAACmM,GAAF,EAAX;;AAEA,YAAIyC,EAAE,KAAK3G,GAAG,CAACI,YAAJ,CAAiBvJ,OAAjB,EAA0B8P,EAA1B,KAAiCA,EAAE,KAAK9P,OAA7C,CAAN,EAA6D;AACzD;AACA;AACA,iBAAOgL,UAAU,CAACwqB,WAAlB;AACH;AACJ;AACJ;;AAED,UAAM1Z,GAAG,GACL2Y,eAAe,MAAKoK,gBAAgB,SAAhB,IAAAA,gBAAgB,WAAhB,SAAA,GAAAA,gBAAgB,CAAExd,MAAvB,CAAf,IACC,CAACoT,eAAD,KACGoK,gBAAgB,SAAhB,IAAAA,gBAAgB,WAAhB,SAAA,GAAAA,gBAAgB,CAAExsB,QAAlB,GAA6BwrB,kBADhC,CADD,GAGMv9B,SAHN,GAIM0K,UAAU,CAACwqB,WALrB;;AAOA,QAAI1Z,GAAG,KAAKxb,SAAZ,EAAuB;AACnBstB,MAAAA,KAAK,CAACyH,gBAAN,GAAyB,IAAzB;AACH;;AAED,WAAOvZ,GAAP;AACH;;AAEOwiB,EAAAA,aAAa;;;AACjB,UAAMv+B,OAAO,GAAG,KAAKkS,QAArB;AACA,UAAMT,IAAI,GAAGzR,OAAO,CAACqL,SAAR,GAAoBL,QAApB,CAA6ByG,IAA1C;AACA,UAAM8P,QAAQ,GAAG,KAAKA,QAAtB;AAEA,UAAMwd,KAAK,GAAG,KAAK1B,MAAnB;AACA,UAAM2B,eAAe,GAAkB,EAAvC;AACA,UAAMC,cAAc,GAAkB,EAAtC;AACA,UAAM9B,wBAAwB,GAAG,KAAKe,yBAAtC;AACA,UAAMgB,wBAAwB,GAAkB/B,wBAAwB,GAClEh2B,KAAK,CAAC+S,IAAN,CACI9Q,GAAG,CAAC7B,gBAAJ,CACIkK,IADJ,EAEI0rB,wBAFJ,CADJ,CADkE,GAOlE,EAPN;AAQA,UAAMgC,uBAAuB,GAAkB,EAA/C;;AAEA,SAAK,MAAM7d,MAAX,IAAqB3f,MAAM,CAACC,IAAP,CAAYm9B,KAAZ,CAArB,EAAyC;AACrC,YAAMK,cAAc,GAAGL,KAAK,CAACzd,MAAD,CAA5B;;AAEA,WAAK,MAAM7Z,EAAX,IAAiB9F,MAAM,CAACC,IAAP,CAAYw9B,cAAZ,CAAjB,EAA8C;AAC1C,cAAM78B,SAAS,GAAG68B,cAAc,CAAC33B,EAAD,CAAhC;AACA,cAAMsI,EAAE,GAAGxN,SAAS,CAAC8P,UAAV,EAAX;AACA,cAAMJ,KAAK,GAAG1P,SAAS,CAAC+P,QAAV,EAAd;AACA,cAAMwrB,kBAAkB,GAAG7rB,KAAK,CAAC6rB,kBAAjC;;AAEA,YAAI/tB,EAAJ,EAAQ;AACJ,cAAIuR,MAAM,KAAKC,QAAf,EAAyB;AACrB4d,YAAAA,uBAAuB,CAAChyB,IAAxB,CAA6B4C,EAA7B;;AAEA,gBAAI,CAAC,KAAK6tB,yBAAV,EAAqC;AACjCoB,cAAAA,eAAe,CAAC7xB,IAAhB,CAAqB4C,EAArB;AACH;AACJ,WAND,MAMO,IAAI+tB,kBAAJ,EAAwB;AAC3BoB,YAAAA,wBAAwB,CAAC/xB,IAAzB,CAA8B4C,EAA9B;AACH,WAFM,MAEA;AACHkvB,YAAAA,cAAc,CAAC9xB,IAAf,CAAoB4C,EAApB;AACH;AACJ;AACJ;AACJ;;AAED,UAAM2tB,YAAY,GAAG,KAAKC,OAA1B;AACA,UAAM0B,kBAAkB,GACpBL,eAAe,CAAC77B,MAAhB,GAAyB,CAAzB,GACM,CAAC,GAAG67B,eAAJ,EAAqB,GAAGE,wBAAxB,CADN,GAEM3+B,SAHV;AAKA,UAAM++B,YAAY,GAAmC,EAArD;AACA,UAAMC,eAAe,GAA+B,IAAIjzB,OAAJ,EAApD;;AAEA,UAAMkzB,MAAM,GAAG,CAACv/B,OAAD,EAAuBw/B,IAAvB;;;AACX,YAAMrpB,OAAO,GAAGnW,OAAO,CAACmW,OAAxB;;AAEA,UAAIA,OAAO,KAAK,QAAZ,IAAwBA,OAAO,KAAK,OAAxC,EAAiD;AAC7C;AACH;;AAED,UAAIsd,WAAW,GAAG,KAAlB;;AAEA,UAAIgK,YAAY,CAACjmB,GAAb,CAAiBxX,OAAjB,CAAJ,EAA+B;AAC3B,YAAIw/B,IAAJ,EAAU;AACN/L,UAAAA,WAAW,GAAG,IAAd;AACH,SAFD,MAEO;AACHgK,UAAAA,YAAY,CAACtlB,MAAb,CAAoBnY,OAApB;AACA2b,UAAAA,gBAAgB,CAAC5b,OAAD,EAAUC,OAAV,EAAmBk8B,WAAnB,CAAhB;AACH;AACJ,OAPD,MAOO,IACHsD,IAAI,IACJ,EAAC,MAAA,KAAKtB,gBAAL,UAAA,iBAAA,SAAA,iBAAwBl+B,SAASk/B,wBAAlC,CADA,IAEAvjB,gBAAgB,CAAC5b,OAAD,EAAUC,OAAV,EAAmBk8B,WAAnB,EAAgC,MAAhC,CAHb,EAIL;AACEuB,QAAAA,YAAY,CAAC1lB,GAAb,CAAiB/X,OAAjB,EAA0B,IAA1B;AACAyzB,QAAAA,WAAW,GAAG,IAAd;AACH;;AAED,UAAIA,WAAJ,EAAiB;AACb4L,QAAAA,YAAY,CAACnyB,IAAb,CACI,IAAIH,eAAJ,CAAoBhN,OAAO,CAACqL,SAA5B,EAAuCpL,OAAvC,CADJ;AAGAs/B,QAAAA,eAAe,CAACvnB,GAAhB,CAAoB/X,OAApB,EAA6B,IAA7B;AACH;AACJ,KA/BD;;AAiCA,UAAMy/B,IAAI,GAAIz/B,OAAD;AACT,WACI,IAAI8P,EAAE,GAAG3G,GAAG,CAACU,oBAAJ,CAAyB7J,OAAzB,CADb,EAEI8P,EAFJ,EAGIA,EAAE,GAAG3G,GAAG,CAACY,qBAAJ,CAA0B+F,EAA1B,CAHT,EAIE;AACE,YAAIyT,IAAI,GAAG,KAAX;AACA,YAAImc,iBAAiB,GAAG,KAAxB;AACA,YAAIC,oBAAoB,GAAG,KAA3B;;AAEA,YAAIP,kBAAJ,EAAwB;AACpB,gBAAMQ,QAAQ,GAAG7/B,OAAO,CAACqe,SAAR,CAAkBtO,EAAlB,CAAjB;;AAEA,eAAK,MAAMiT,CAAX,IAAgBqc,kBAAhB,EAAoC;AAChC,gBAAItvB,EAAE,KAAKiT,CAAX,EAAc;AACVQ,cAAAA,IAAI,GAAG,IAAP;AACA;AACH;;AAED,gBAAIpa,GAAG,CAACI,YAAJ,CAAiBuG,EAAjB,EAAqBiT,CAArB,CAAJ,EAA6B;AACzB2c,cAAAA,iBAAiB,GAAG,IAApB;AACA;AACH,aAHD,MAGO,IAAIv2B,GAAG,CAACI,YAAJ,CAAiBwZ,CAAjB,EAAoB6c,QAApB,CAAJ,EAAmC;AACtC;AACA;AACA;AACA;AACAD,cAAAA,oBAAoB,GAAG,IAAvB;AACH;AACJ;;AAED,cAAID,iBAAJ,EAAuB;AACnBD,YAAAA,IAAI,CAAC3vB,EAAD,CAAJ;AACH,WAFD,MAEO,IAAI,CAACyT,IAAD,IAAS,CAACoc,oBAAd,EAAoC;AACvCJ,YAAAA,MAAM,CAACzvB,EAAD,EAAoB,IAApB,CAAN;AACH;AACJ,SA1BD,MA0BO;AACHyvB,UAAAA,MAAM,CAACzvB,EAAD,EAAoB,KAApB,CAAN;AACH;AACJ;AACJ,KAxCD;;AA0CA,QAAI,CAACsvB,kBAAL,EAAyB;AACrBH,MAAAA,wBAAwB,CAACvf,OAAzB,CAAkCxe,CAAD,IAAOq+B,MAAM,CAACr+B,CAAD,EAAI,KAAJ,CAA9C;AACH;;AAED89B,IAAAA,cAAc,CAACtf,OAAf,CAAwBxe,CAAD,IAAOq+B,MAAM,CAACr+B,CAAD,EAAI,IAAJ,CAApC;;AAEA,QAAIsQ,IAAJ,EAAU;AACNiuB,MAAAA,IAAI,CAACjuB,IAAD,CAAJ;AACH;;AAED,UAAA,KAAKwsB,IAAL,UAAA,iBAAA,SAAA,MACM9mB,IAAKhW,CAAD,IAAOA,CAAC,CAACmM,GAAF,IACZqS,QAASxe,CAAD;AACL,UAAIA,CAAC,IAAI,CAACo+B,eAAe,CAACjyB,GAAhB,CAAoBnM,CAApB,CAAV,EAAkC;AAC9Bq+B,QAAAA,MAAM,CAACr+B,CAAD,EAAI,KAAJ,CAAN;AACH;AACJ,MANL;AAQA,SAAK88B,IAAL,GAAYqB,YAAZ;AACA,SAAK3B,OAAL,GAAe4B,eAAf;AACH;AA0ED;;;;;;;AAKQvB,EAAAA,sBAAsB,CAC1B8B,cAD0B;AAG1B,UAAM52B,aAAa,GAAG42B,cAAc,SAAd,IAAAA,cAAc,WAAd,SAAA,GAAAA,cAAc,CAAE52B,aAAtC;;AAEA,QAAI,CAAC42B,cAAD,IAAmB,CAAC52B,aAAxB,EAAuC;AACnC;AACH;;AAED,UAAMqC,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyC4tB,cAAzC,CAAZ;AACA,UAAMv9B,SAAS,GAAGgJ,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEhJ,SAAvB;AACA,UAAMgf,QAAQ,GAAG,KAAKA,QAAtB;;AAEA,QACK,CAAChf,SAAD,IAAc,CAACgf,QAAhB,IACChf,SAAS,IAAIgf,QAAQ,KAAKhf,SAAS,CAAC+e,MAFzC,EAGE;AACE;AACH;;AAED,UAAMlS,SAAS,GAAG7D,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAE1J,IAAL,CAAUwQ,UAAV,EAAlB;;AAEA,QAAIjD,SAAJ,EAAe;AACX,UAAIqK,OAAO,GAAG,KAAKvH,QAAL,CAAcvP,SAAd,CAAwBkkB,SAAxB,CAAkC;AAC5CzX,QAAAA,SAD4C;AAE5C0X,QAAAA,kBAAkB,EAAE;AAFwB,OAAlC,CAAd;;AAKA,UAAIrN,OAAJ,EAAa;AACT,YACIqmB,cAAc,CAACrrB,uBAAf,CAAuCgF,OAAvC,IACAzO,QAAQ,CAAC+0B,2BAFb,EAGE;AACEtmB,UAAAA,OAAO,GAAG,KAAKvH,QAAL,CAAcvP,SAAd,CAAwBixB,QAAxB,CAAiC;AACvCxkB,YAAAA,SADuC;AAEvC0X,YAAAA,kBAAkB,EAAE;AAFmB,WAAjC,CAAV;;AAKA,cAAI,CAACrN,OAAL,EAAc;AACV;AACA,kBAAM,IAAIxY,KAAJ,CAAU,uBAAV,CAAN;AACH;AACJ;;AAED,aAAKiR,QAAL,CAAcwL,cAAd,CAA6B8E,KAA7B,CAAmC/I,OAAnC;;AAEA;AACH;AACJ;AAGD;;;AACAqmB,IAAAA,cAAc,CAACjiB,IAAf;AACH;;;;ACj8BL;;;;;AAmCA,MAAMmiB,cAAc,gBAAG,CAAC,OAAD,EAAU,UAAV,EAAsB,oBAAtB,EAA4CnjC,IAA5C,CAAiD,IAAjD,CAAvB;;AAEA,MAAMojC,iBAAN,SAAgCjrB,iBAAhC;AAIIzQ,EAAAA,YACItE,SACAD,SACAkgC,cACAh+B;AAEA,UAAMlC,OAAN,EAAeC,OAAf,EAAwB0U,2BAA2B,CAACG,KAApD,EAA2D5S,GAA3D;;AAQI,2BAAA,GAAsB8W,UAAD;;;AACzB,YAAM5J,SAAS,GAAG,KAAK+C,QAAL,CAAc7E,GAAd,EAAlB;;AACA,YAAMsF,KAAK,GAAGoG,UAAU,CAACpG,KAAzB;;AAEA,UAAIxD,SAAS,IAAIwD,KAAjB,EAAwB;AACpB,cAAMrH,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyC9C,SAAzC,CAAZ;AAEA,YAAIqK,OAAJ;;AAEA,YAAIlO,GAAJ,EAAS;AACLkO,UAAAA,OAAO,GAAG,MAAAid,mBAAmB,CAACQ,gBAApB,CACN,KAAKhlB,QADC,EAEN3G,GAFM,EAGNhL,SAHM,EAINqS,KAJM,EAKNrS,SALM,EAMN,CAACyY,UAAU,CAACtF,OANN,EAON,IAPM,CAAA,UAAA,iBAAA,SAAA,MAQPzT,OARH;AASH;;AAED,cAAMkgC,SAAS,GAAG,MAAA,KAAKC,aAAL,EAAA,UAAA,iBAAA,SAAA,MAAsB9yB,KAAxC;;AACA,YAAI6yB,SAAJ,EAAe;AACX1mB,UAAAA,OAAO,GAAG0mB,SAAV;AACH;;AAED,YAAI1mB,OAAJ,EAAa;AACT9G,UAAAA,mBAAW,CAAC8G,OAAD,CAAX;AACH;AACJ;AACJ,KA9BO;;AANJ,SAAKvH,QAAL,GAAgBlS,OAAhB;AACA,SAAKogC,aAAL,GAAqBF,YAArB;;AAEA,SAAK5qB,YAAL,CAAkB,KAAK+qB,kBAAvB;AACH;;;AAoCL;;;AACA,MAAMC,eAAe,GAAG,CAAxB;AACA,MAAMC,gBAAgB,GAAG,CAAzB;AACA,MAAMC,kBAAkB,GAAG,CAA3B;MAUa1rB,cACD9C;AAmBRzN,EAAAA,YACIvE,SACAC,SACA8d,WACA9L,OACA/P;;;AAEA,UAAMlC,OAAN,EAAeC,OAAf,EAAwBgS,KAAxB;AAlBI,iBAAA,GAA6C,EAA7C;;AAiQA,wBAAA,GAAmBwuB,OAAD;AACtB,WAAK,MAAM//B,KAAX,IAAoB+/B,OAApB,EAA6B;AACzB,cAAM1wB,EAAE,GAAGrP,KAAK,CAAC+L,MAAjB;AACA,cAAMhF,EAAE,GAAGyJ,aAAa,CAAC,KAAK0G,IAAN,EAAY7H,EAAZ,CAAxB;AAEA,YAAI2wB,aAAJ;AACA,YAAIC,YAAY,GAAG,KAAKC,aAAxB;;AAEA,YAAIlgC,KAAK,CAACmgC,iBAAN,IAA2B,IAA/B,EAAqC;AACjCH,UAAAA,aAAa,GACThgC,KAAK,CAACmgC,iBAAN,IAA2B,IAA3B,GACMpgC,YAAA,CAAmBvC,OADzB,GAEMuC,YAAA,CAAmBxC,gBAH7B;;AAKA,cAAIyiC,aAAa,KAAKjgC,YAAA,CAAmBvC,OAAzC,EAAkD;AAC9CyiC,YAAAA,YAAY,GAAGl5B,EAAf;AACH;AACJ,SATD,MASO;AACHi5B,UAAAA,aAAa,GAAGjgC,YAAA,CAAmBzC,SAAnC;AACH;;AAED,YAAI,KAAK8iC,QAAL,CAAcr5B,EAAd,MAAsBi5B,aAA1B,EAAyC;AACrC,cAAIA,aAAa,KAAKngC,SAAtB,EAAiC;AAC7B,mBAAO,KAAKugC,QAAL,CAAcr5B,EAAd,CAAP;;AAEA,gBAAIk5B,YAAY,KAAKl5B,EAArB,EAAyB;AACrB,qBAAO,KAAKm5B,aAAZ;AACH;AACJ,WAND,MAMO;AACH,iBAAKE,QAAL,CAAcr5B,EAAd,IAAoBi5B,aAApB;AACA,iBAAKE,aAAL,GAAqBD,YAArB;AACH;;AAED,gBAAM9S,KAAK,GAAG,KAAKkT,QAAL,CAAchxB,EAAd,CAAd;;AAEA,cAAI8d,KAAJ,EAAW;AACP9d,YAAAA,EAAE,CAACyG,aAAH,CAAiB,IAAIvR,eAAJ,CAAoB4oB,KAApB,CAAjB;AACH;AACJ;AACJ;AACJ,KAxCO;;AA7OJ,SAAKjW,IAAL,GAAY5X,OAAO,CAACqL,SAApB;AACA,SAAK21B,mBAAL,GAA2B,MAAA/uB,KAAK,CAAC+uB,mBAAN,UAAA,iBAAA,KAAA,GAA6B,GAAxD;;AAEA,QAAI,KAAK5uB,MAAL,CAAY6uB,UAAZ,IAA0B,KAAK7uB,MAAL,CAAY8uB,eAA1C,EAA2D;AACvD,WAAKC,qBAAL,GAA6B,IAAIC,oBAAJ,CACzB,KAAKC,eADoB,EAEzB;AAAEC,QAAAA,SAAS,EAAE,CAAC,CAAD,EAAI,IAAJ,EAAU,GAAV,EAAe,IAAf,EAAqB,CAArB;AAAb,OAFyB,CAA7B;;AAIA,WAAKC,aAAL;AACH;;AAED,SAAK9iB,UAAL,GAAkBV,SAAlB;;AACA,UAAMmiB,YAAY,GAAG,MACjBjuB,KAAK,CAACuvB,eAAN,GAAwB,KAAKvG,QAA7B,GAAwC16B,SAD5C;;AAGA,QAAI,CAACP,OAAO,CAAC2e,UAAb,EAAyB;AACrB,WAAKO,YAAL,GAAoB,IAAI+gB,iBAAJ,CAChB,KAAK9tB,QADW,EAEhBnS,OAFgB,EAGhBkgC,YAHgB,EAIhBh+B,GAJgB,CAApB;AAMH;AACJ;;AAED9B,EAAAA,OAAO;;;AACH,SAAKqe,UAAL,CAAgB,IAAhB;;AAEA,QAAI,KAAK0iB,qBAAT,EAAgC;AAC5B,WAAKA,qBAAL,CAA2BM,UAA3B;;AACA,aAAO,KAAKN,qBAAZ;AACH;;AAED,WAAO,KAAKlG,QAAZ;AACA,WAAO,KAAK2F,aAAZ;AACA,WAAO,KAAKc,YAAZ;AACA,WAAO,KAAKppB,YAAZ;;AAEA,QAAI,KAAKqpB,UAAT,EAAqB;AACjB,WAAKA,UAAL;;AACA,aAAO,KAAKA,UAAZ;AACH;;AAED,UAAMr2B,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,QAAI,KAAKgqB,gBAAT,EAA2B;AACvBt2B,MAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAKy1B,gBAAtB;AACA,aAAO,KAAKA,gBAAZ;AACH;;AAED,QAAI,KAAKvpB,YAAT,EAAuB;AACnB/M,MAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAKkM,YAAtB;AACA,aAAO,KAAKA,YAAZ;AACH;;AAED,UAAA,KAAK6G,YAAL,UAAA,iBAAA,SAAA,MAAmB9e,SAAnB;AACA,WAAO,KAAK8e,YAAZ;AACH;;AAED2iB,EAAAA,UAAU,CAAC5hC,OAAD;AACN,QAAIA,OAAJ,EAAa;AACT,WAAKg7B,QAAL,GAAgB,IAAIjuB,eAAJ,CAAoB,KAAK4K,IAAzB,EAA+B3X,OAA/B,CAAhB;AACH,KAFD,MAEO;AACH,WAAKg7B,QAAL,GAAgB16B,SAAhB;AACH;;AAED,QACI,CAAC,KAAK6R,MAAL,CAAY6uB,UAAZ,IAA0B,KAAK7uB,MAAL,CAAY8uB,eAAvC,KACA,CAAC,KAAKU,gBAFV,EAGE;AACE,WAAKA,gBAAL,GAAwB,KAAKhqB,IAAL,GAAYjK,UAAZ,CAAuB;;;AAC3C,eAAO,KAAKi0B,gBAAZ;AAEA,cAAME,OAAO,GAAoC,EAAjD;;AAEA,YAAI,KAAK7G,QAAL,KAAkB,KAAK8G,YAA3B,EAAyC;AACrCD,UAAAA,OAAO,CAAC30B,IAAR,CAAa,KAAK8tB,QAAlB;AACA6G,UAAAA,OAAO,CAAC30B,IAAR,CAAa,KAAK40B,YAAlB;AACA,eAAKA,YAAL,GAAoB,KAAK9G,QAAzB;AACH;;AAED,aAAK,MAAM+G,IAAX,IAAmBF,OAAnB,EAA4B;AACxB,gBAAM/xB,EAAE,GAAGiyB,IAAI,SAAJ,IAAAA,IAAI,WAAJ,SAAA,GAAAA,IAAI,CAAE10B,GAAN,EAAX;;AAEA,cAAIyC,EAAE,IAAI,CAAA,MAAA,KAAK2xB,YAAL,UAAA,iBAAA,SAAA,MAAmBp0B,IAAIyC,GAAvB,MAA+B,IAAzC,EAA+C;AAC3C,kBAAMkC,KAAK,GAAG,KAAKG,MAAnB;;AAEA,gBACIrC,EAAE,KACDkC,KAAK,CAACivB,eAAN,KAA0B3gC,SAA1B,IACG0R,KAAK,CAACgvB,UAFR,CADN,EAIE;AACE,oBAAMpT,KAAK,GAAG,KAAKkT,QAAL,CAAchxB,EAAd,CAAd;;AAEA,kBAAI8d,KAAJ,EAAW;AACP9d,gBAAAA,EAAE,CAACyG,aAAH,CAAiB,IAAIvR,eAAJ,CAAoB4oB,KAApB,CAAjB;AACH;AACJ;AACJ;AACJ;AACJ,OA9BuB,CAAxB;AA+BH;AACJ;;AAEDoU,EAAAA,UAAU;;;AACN,WAAO,CAAA,MAAA,KAAKhH,QAAL,UAAA,iBAAA,SAAA,MAAe3tB,KAAf,KAAwB,IAA/B;AACH;;AAED4pB,EAAAA,gBAAgB,CACZ9C,cADY,EAEZ7T,gBAFY,EAGZrK,UAHY,EAIZ0H,mBAJY;;;AAMZ,UAAMxO,SAAS,GAAG,KAAKiD,UAAL,EAAlB;AACA,UAAMknB,cAAc,GAChBnqB,SAAS,IACT,CAAA,MACIglB,cACH,SADG,IAAAA,cAAc,WAAd,SAAA,GAAAA,cAAc,CACfpgB,uBAFH,UAAA,iBAAA,SAAA,MAE4B1G,KAF5B,MAEsC8B,SAJ1C;;AAMA,QAAI,CAACA,SAAL,EAAgB;AACZ,aAAO,IAAP;AACH;;AAED,QAAIuH,IAAI,GAAmC,IAA3C;AACA,QAAIwe,aAAa,GAAG,KAApB;AACA,QAAIlyB,YAAJ;;AAEA,QACI,KAAKmP,MAAL,CAAY2D,QAAZ,IACAwjB,cADA,IAECnF,cAAc,IAAI,CAAChrB,GAAG,CAACI,YAAJ,CAAiB4F,SAAjB,EAA4BglB,cAA5B,CAHxB,EAIE;AACE,YAAM8E,SAAS,GAAwB;AACnC9E,QAAAA,cADmC;AAEnC7T,QAAAA,gBAFmC;AAGnCnR,QAAAA,SAHmC;AAInCwO,QAAAA,mBAJmC;AAKnCkJ,QAAAA,kBAAkB,EAAE;AALe,OAAvC;AAQA,YAAMqS,YAAY,GAAmC,EAArD;AAEAxiB,MAAAA,IAAI,GAAG,KAAKzE,QAAL,CAAcvP,SAAd,CACHuT,UAAU,GAAG,UAAH,GAAgB,UADvB,EAELgjB,SAFK,EAEMC,YAFN,CAAP;AAIAhE,MAAAA,aAAa,GAAG,CAAC,CAACgE,YAAY,CAAChE,aAA/B;AACAlyB,MAAAA,YAAY,GAAGk2B,YAAY,CAACl2B,YAA5B;AACH;;AAED,WAAO;AACHhD,MAAAA,OAAO,EAAE0W,IADN;AAEH1T,MAAAA,YAFG;AAGHkyB,MAAAA;AAHG,KAAP;AAKH;;AAEDW,EAAAA,aAAa,CACT71B,OADS,EAET4tB,KAFS;;;AAIT,QAAI,CAAC6I,mBAAmB,CAACmC,SAAzB,EAAoC;AAChC,aAAO,CAAA,MAAAhL,KAAK,CAAC+H,UAAN,UAAA,iBAAA,SAAA,MAAkBnV,iBAAlB,IACDxV,UAAU,CAACyqB,aADV,GAEDn1B,SAFN;AAGH;;AAED,UAAM;AACFihC,MAAAA,eADE;AAEFN,MAAAA,eAFE;AAGFgB,MAAAA,UAAU,GAAG;AAHX,QAIF,KAAK9vB,MAJT;AAKA,UAAM6jB,YAAY,GAAG,KAAK5jB,UAAL,EAArB;;AAEA,QACI4jB,YAAY,KACXuL,eAAe,IAAIN,eAAnB,IAAsCgB,UAD3B,CAAZ,KAEC,CAAC94B,GAAG,CAACI,YAAJ,CAAiBysB,YAAjB,EAA+BpI,KAAK,CAAC3T,IAArC,CAAD,IACG,CAAA,MACI2T,KAAK,CAAC3T,IAAN,CACFlG,uBAFF,UAAA,iBAAA,SAAA,MAE2B1G,KAF3B,MAEqC2oB,YALzC,CADJ,EAOE;AACE,UAAI9B,KAAJ;;AAEA,UAAIqN,eAAJ,EAAqB;AACjB,cAAMjtB,OAAO,GAAG,MAAA,KAAK0mB,QAAL,UAAA,iBAAA,SAAA,MAAe3tB,KAA/B;;AAEA,YAAIiH,OAAO,IAAIsZ,KAAK,CAACkG,eAAN,CAAsBxf,OAAtB,CAAf,EAA+C;AAC3C4f,UAAAA,KAAK,GAAG5f,OAAR;AACH;AACJ;;AAED,UAAI,CAAC4f,KAAD,IAAU+N,UAAd,EAA0B;AACtB/N,QAAAA,KAAK,GAAG,KAAKjiB,QAAL,CAAcvP,SAAd,CAAwBwjB,WAAxB,CAAoC;AACxC/W,UAAAA,SAAS,EAAE6mB,YAD6B;AAExCnP,UAAAA,kBAAkB,EAAE;AAFoB,SAApC,CAAR;AAIH;;AAED,UAAI,CAACqN,KAAD,IAAU+M,eAAd,EAA+B;AAC3B/M,QAAAA,KAAK,GAAG,KAAKjiB,QAAL,CAAcvP,SAAd,CAAwBwqB,WAAxB,CAAoC;AACxC/d,UAAAA,SAAS,EAAE6mB,YAD6B;AAExCnP,UAAAA,kBAAkB,EAAE,IAFoB;AAGxC5Q,UAAAA,UAAU,EAAE2X,KAAK,CAAC3X,UAHsB;AAIxC6d,UAAAA,eAAe,EAAGhkB,EAAD;;;AACb,kBAAMtI,EAAE,GAAGyJ,aAAa,CAAC,KAAK0G,IAAN,EAAY7H,EAAZ,CAAxB;AACA,kBAAM0M,UAAU,GAAG,KAAKqkB,QAAL,CAAcr5B,EAAd,CAAnB;AAEA,mBACIwuB,YAAY,KAAKlmB,EAAjB,IACA,CAAC,EAAC,MAAA,KAAK2xB,YAAL,UAAA,iBAAA,SAAA,MAAmBp0B,IAAIyC,GAAxB,CADD,IAEA8d,KAAK,CAACkG,eAAN,CAAsBhkB,EAAtB,CAFA,KAGC0M,UAAU,KAAKhc,YAAA,CAAmBvC,OAAlC,IACIue,UAAU,KACPhc,YAAA,CAAmBxC,gBADtB,KAEIijC,eAAe,KACZzgC,YAAA,CAAmBxC,gBADtB,IAEG,CAAC,KAAK2iC,aAJb,CAJL,CADJ;AAWH;AAnBuC,SAApC,CAAR;AAqBH;;AAED,UAAIzM,KAAJ,EAAW;AACPtG,QAAAA,KAAK,CAACsG,KAAN,GAAc,IAAd;AACAtG,QAAAA,KAAK,CAACmH,YAAN,GAAqBb,KAArB;AACAtG,QAAAA,KAAK,CAAC8H,kBAAN,GAA2BM,YAA3B;AACApI,QAAAA,KAAK,CAACyH,gBAAN,GAAyB,IAAzB;AACA,eAAOrqB,UAAU,CAACoqB,aAAlB;AACH;AACJ;;AAED,WAAO90B,SAAP;AACH;;AA4COghC,EAAAA,aAAa;AACjB,UAAMthC,OAAO,GAAG,KAAKoS,UAAL,EAAhB;;AAEA,QACI,KAAKsvB,UAAL,IACA,CAAC1hC,OADD,IAEA,OAAO6F,gBAAP,KAA4B,WAHhC,EAIE;AACE;AACH;;AAED,UAAMwF,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AACA,UAAMolB,WAAW,GAAI,KAAK0E,YAAL,GAAoB,IAAIp1B,OAAJ,EAAzC;AACA,UAAM61B,gBAAgB,GAAG,KAAKjwB,QAAL,CAAcvP,SAAvC;AACA,QAAIy/B,WAAW,GAA4B,KAAK9pB,YAAL,GAAoB,EAA/D;AAEA,UAAM+pB,QAAQ,GAAGj5B,GAAG,CAACC,sBAAJ,CACZi5B,SAAD;AACI,WAAK,MAAMC,QAAX,IAAuBD,SAAvB,EAAkC;AAC9B,cAAM71B,MAAM,GAAG81B,QAAQ,CAAC91B,MAAxB;AACA,cAAMoV,OAAO,GAAG0gB,QAAQ,CAACC,YAAzB;AACA,cAAMC,KAAK,GAAGF,QAAQ,CAACG,UAAvB;;AAEA,YAAIH,QAAQ,CAAC/9B,IAAT,KAAkB,YAAtB,EAAoC;AAChC,cAAI+9B,QAAQ,CAACI,aAAT,KAA2B,UAA/B,EAA2C;AACvCP,YAAAA,WAAW,CAACj1B,IAAZ,CAAiB;AACblN,cAAAA,OAAO,EAAEwM,MADI;AAEbjI,cAAAA,IAAI,EAAE+7B;AAFO,aAAjB;AAIH;AACJ,SAPD,MAOO;AACH,eAAK,IAAI3vB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiR,OAAO,CAAC1e,MAA5B,EAAoCyN,CAAC,EAArC,EAAyC;AACrCwxB,YAAAA,WAAW,CAACj1B,IAAZ,CAAiB;AACblN,cAAAA,OAAO,EAAE4hB,OAAO,CACZjR,CADY,CADH;AAIbpM,cAAAA,IAAI,EAAEg8B;AAJO,aAAjB;AAMH;;AAED,eAAK,IAAI5vB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6xB,KAAK,CAACt/B,MAA1B,EAAkCyN,CAAC,EAAnC,EAAuC;AACnCwxB,YAAAA,WAAW,CAACj1B,IAAZ,CAAiB;AACblN,cAAAA,OAAO,EAAEwiC,KAAK,CAAC7xB,CAAD,CADD;AAEbpM,cAAAA,IAAI,EAAE87B;AAFO,aAAjB;AAIH;AACJ;AACJ;;AAEDsC,MAAAA,aAAa;AAChB,KAlCY,CAAjB;;AAqCA,UAAMC,UAAU,GAAG,CAAC5iC,OAAD,EAAuBkY,MAAvB;;;AACf,YAAM5D,OAAO,GAAGyoB,WAAW,CAAC1vB,GAAZ,CAAgBrN,OAAhB,CAAhB;;AAEA,UAAIsU,OAAO,IAAI4D,MAAf,EAAuB;AACnB,cAAA,KAAKgpB,qBAAL,UAAA,iBAAA,SAAA,MAA4B2B,UAAU7iC,QAAtC;AACA+8B,QAAAA,WAAW,CAAC5kB,MAAZ,CAAmBnY,OAAnB;AACH;;AAED,UAAI,CAACsU,OAAD,IAAY,CAAC4D,MAAjB,EAAyB;AACrB6kB,QAAAA,WAAW,CAAChlB,GAAZ,CAAgB/X,OAAhB,EAAyB,IAAzB;AACA,cAAA,KAAKkhC,qBAAL,UAAA,iBAAA,SAAA,MAA4B4B,QAAQ9iC,QAApC;AACH;AACJ,KAZD;;AAcA,UAAM+iC,aAAa,GAAI/iC,OAAD;AAClB,YAAMoW,WAAW,GAAG8rB,gBAAgB,CAAC9rB,WAAjB,CAA6BpW,OAA7B,CAApB;AACA,YAAMsU,OAAO,GAAGyoB,WAAW,CAAC1vB,GAAZ,CAAgBrN,OAAhB,CAAhB;;AAEA,UAAIsU,OAAJ,EAAa;AACT,YAAI,CAAC8B,WAAL,EAAkB;AACdwsB,UAAAA,UAAU,CAAC5iC,OAAD,EAAU,IAAV,CAAV;AACH;AACJ,OAJD,MAIO;AACH,YAAIoW,WAAJ,EAAiB;AACbwsB,UAAAA,UAAU,CAAC5iC,OAAD,CAAV;AACH;AACJ;AACJ,KAbD;;AAeA,UAAMgjC,cAAc,GAAIhjC,OAAD;AACnB,YAAM;AAAE6C,QAAAA;AAAF,UAAYogC,gBAAgB,CAACjjC,OAAD,CAAlC;;AAEA,UAAI6C,KAAK,IAAIA,KAAK,KAAK,IAAvB,EAA6B;AACzB,YACIA,KAAK,CAACuP,UAAN,OAAuBpS,OAAvB,IACAkiC,gBAAgB,CAAC9rB,WAAjB,CAA6BpW,OAA7B,CAFJ,EAGE;AACE4iC,UAAAA,UAAU,CAAC5iC,OAAD,CAAV;AACH,SALD,MAKO;AACH;AACH;AACJ;;AAED,YAAM20B,MAAM,GAAG/mB,uBAAuB,CAClCvC,GAAG,CAACN,QAD8B,EAElC/K,OAFkC,EAGjCoG,IAAD;AACI,cAAM;AAAEvD,UAAAA,KAAF;AAASF,UAAAA;AAAT,YAAsBsgC,gBAAgB,CACxC78B,IADwC,CAA5C;;AAIA,YAAIvD,KAAK,IAAIA,KAAK,KAAK,IAAvB,EAA6B;AACzB,iBAAOmI,UAAU,CAACyqB,aAAlB;AACH;;AAED,cAAM+D,sBAAsB,GAAG72B,QAAQ,SAAR,IAAAA,QAAQ,WAAR,SAAA,GAAAA,QAAQ,CAAE82B,QAAV,CAAmB,IAAnB,CAA/B;;AAEA,YACI92B,QAAQ,IACRA,QAAQ,CAACyP,UAAT,OAA0BhM,IAD1B,IAEAozB,sBAFA,IAGAA,sBAAsB,KAAKpzB,IAJ/B,EAKE;AACE,iBAAO4E,UAAU,CAACyqB,aAAlB;AACH;;AAED,YAAIyM,gBAAgB,CAAC9rB,WAAjB,CAA6BhQ,IAA7B,CAAJ,EAAuD;AACnDw8B,UAAAA,UAAU,CAACx8B,IAAD,CAAV;AACH;;AAED,eAAO4E,UAAU,CAACwqB,WAAlB;AACH,OA5BiC,CAAtC;;AA+BA,UAAIb,MAAJ,EAAY;AACRA,QAAAA,MAAM,CAACQ,WAAP,GAAqBn1B,OAArB;;AAEA,eAAO20B,MAAM,CAACY,QAAP,EAAP,EAA0B;AACtB;AACH;AACJ;AACJ,KApDD;;AAsDA,UAAM2N,UAAU,GAAIljC,OAAD;AACf,YAAMsU,OAAO,GAAGyoB,WAAW,CAAC1vB,GAAZ,CAAgBrN,OAAhB,CAAhB;;AAEA,UAAIsU,OAAJ,EAAa;AACTsuB,QAAAA,UAAU,CAAC5iC,OAAD,EAAU,IAAV,CAAV;AACH;;AAED,WACI,IAAI8P,EAAE,GAAG3G,GAAG,CAACU,oBAAJ,CAAyB7J,OAAzB,CADb,EAEI8P,EAFJ,EAGIA,EAAE,GAAG3G,GAAG,CAACY,qBAAJ,CAA0B+F,EAA1B,CAHT,EAIE;AACEozB,QAAAA,UAAU,CAACpzB,EAAD,CAAV;AACH;AACJ,KAdD;;AAgBA,UAAM6yB,aAAa,GAAG;AAClB,UAAI,CAAC,KAAKvqB,YAAN,IAAsB+pB,WAAW,CAACj/B,MAAtC,EAA8C;AAC1C,aAAKkV,YAAL,GAAoB/M,GAAG,CAACqC,UAAJ,CAAe;AAC/B,iBAAO,KAAK0K,YAAZ;;AAEA,eAAK,MAAM;AAAEpY,YAAAA,OAAF;AAAWuE,YAAAA;AAAX,WAAX,IAAgC49B,WAAhC,EAA6C;AACzC,oBAAQ59B,IAAR;AACI,mBAAK+7B,gBAAL;AACIyC,gBAAAA,aAAa,CAAC/iC,OAAD,CAAb;AACA;;AACJ,mBAAKqgC,eAAL;AACI2C,gBAAAA,cAAc,CAAChjC,OAAD,CAAd;AACA;;AACJ,mBAAKugC,kBAAL;AACI2C,gBAAAA,UAAU,CAACljC,OAAD,CAAV;AACA;AATR;AAWH;;AAEDmiC,UAAAA,WAAW,GAAG,KAAK9pB,YAAL,GAAoB,EAAlC;AACH,SAlBmB,EAkBjB,CAlBiB,CAApB;AAmBH;AACJ,KAtBD;;AAwBA,UAAM4qB,gBAAgB,GAClBjjC,OADqB;AAGrB,YAAM8b,GAAG,GAGL,EAHJ;;AAKA,WACI,IAAIhM,EAAE,GAAuB9P,OADjC,EAEI8P,EAFJ,EAGIA,EAAE,GAAG3G,GAAG,CAACG,gBAAJ,CAAqBwG,EAArB,CAHT,EAIE;AACE,cAAMqzB,GAAG,GAAGrjC,mBAAmB,CAAC,KAAKmS,QAAN,EAAgBnC,EAAhB,CAA/B;;AAEA,YAAIqzB,GAAJ,EAAS;AACL,cAAIA,GAAG,CAACxgC,QAAJ,IAAgB,CAACmZ,GAAG,CAACnZ,QAAzB,EAAmC;AAC/BmZ,YAAAA,GAAG,CAACnZ,QAAJ,GAAewgC,GAAG,CAACxgC,QAAnB;AACH;;AAED,cAAIwgC,GAAG,CAACtgC,KAAR,EAAe;AACXiZ,YAAAA,GAAG,CAACjZ,KAAJ,GAAYsgC,GAAG,CAACtgC,KAAhB;AACA;AACH;AACJ;AACJ;;AAED,aAAOiZ,GAAP;AACH,KA5BD;;AA8BAqmB,IAAAA,WAAW,CAACj1B,IAAZ,CAAiB;AAAElN,MAAAA,OAAF;AAAWuE,MAAAA,IAAI,EAAE87B;AAAjB,KAAjB;AACAsC,IAAAA,aAAa;AAEbP,IAAAA,QAAQ,CAACU,OAAT,CAAiB9iC,OAAjB,EAA0B;AACtBojC,MAAAA,SAAS,EAAE,IADW;AAEtBC,MAAAA,OAAO,EAAE,IAFa;AAGtBC,MAAAA,UAAU,EAAE,IAHU;AAItBC,MAAAA,eAAe,EAAE,CAAC,UAAD;AAJK,KAA1B;;AAOA,SAAK7B,UAAL,GAAkB;AACdU,MAAAA,QAAQ,CAACZ,UAAT;AACH,KAFD;AAGH;;AAEDV,EAAAA,QAAQ,CAAC9gC,OAAD;AACJ,UAAMwH,EAAE,GAAGyJ,aAAa,CAAC,KAAK0G,IAAN,EAAY3X,OAAZ,CAAxB;;AAEA,QAAIwH,EAAE,IAAI,KAAKq5B,QAAf,EAAyB;AACrB,YAAMrkB,UAAU,GACZ,KAAKqkB,QAAL,CAAcr5B,EAAd,KAAqBhH,YAAA,CAAmBzC,SAD5C;AAEA,YAAMylC,SAAS,GAAG,KAAKxI,QAAL,GACZ,KAAKA,QAAL,CAAc3tB,GAAd,OAAwBrN,OADZ,GAEZM,SAFN;AAIA,aAAO;AACHkjC,QAAAA,SADG;AAEHhnB,QAAAA;AAFG,OAAP;AAIH;;AAED,WAAOlc,SAAP;AACH;;;AAQL;;;;;;;;;;;;;;;AAaA,SAASmjC,WAAT,CACIC,GADJ,EAEIC,GAFJ,EAGIC,GAHJ,EAIIC,GAJJ,EAKIC,GALJ,EAMIC,GANJ,EAOIC,GAPJ,EAQIC,GARJ;AAUI,QAAMC,SAAS,GAAGN,GAAG,GAAGE,GAAN,GAAYA,GAAG,GAAGF,GAAlB,GAAwBI,GAAG,GAAGN,GAAN,GAAYA,GAAG,GAAGM,GAAlB,GAAwB,CAAlE;AACA,QAAMG,SAAS,GAAGN,GAAG,GAAGE,GAAN,GAAYA,GAAG,GAAGF,GAAlB,GAAwBI,GAAG,GAAGN,GAAN,GAAYA,GAAG,GAAGM,GAAlB,GAAwB,CAAlE;AAEA,SAAOC,SAAS,KAAK,CAAd,GACDC,SADC,GAEDA,SAAS,KAAK,CAAd,GACAD,SADA,GAEAt1B,IAAI,CAACw1B,IAAL,CAAUF,SAAS,GAAGA,SAAZ,GAAwBC,SAAS,GAAGA,SAA9C,CAJN;AAKH;;MAEYE;AAOT//B,EAAAA,YAAYvE,SAA4BqL;AAQhC,cAAA,GAAQ;AACZ,YAAMC,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEAtM,MAAAA,GAAG,CAACuI,gBAAJ,CAAqB,SAArB,EAAgC,KAAK8iB,UAArC,EAAiD,IAAjD;AACArrB,MAAAA,GAAG,CAACuI,gBAAJ,CAAqB/P,uBAArB,EAA8C,KAAKy2B,YAAnD;AACAjvB,MAAAA,GAAG,CAACuI,gBAAJ,CACI9P,8BADJ,EAEI,KAAKwgC,mBAFT;;AAKA,WAAKryB,QAAL,CAAcwL,cAAd,CAA6B0J,SAA7B,CAAuC,KAAKnO,QAA5C;AACH,KAXO;;AA4DA,wBAAA,GAAmBnW,KAAD;AACtB,aAAO,KAAK0hC,OAAL,CAAa1hC,KAAK,CAAC2E,EAAnB,CAAP;AACH,KAFO;;AAIA,iBAAA,GAAYxH,OAAD;;AAEf;AACA;AACA;AACA;AACA;;;AACA,UAAIwkC,uBAAuB,GAAGxkC,OAA9B;AACA,UAAIykC,uBAAuB,GAAGzkC,OAA9B;;AAEA,WACI,IAAI8P,EAAE,GACF3G,GAAG,CAACG,gBAAJ,CAAqBtJ,OAArB,CAFR,EAGI8P,EAHJ,EAIIA,EAAE,GAAG3G,GAAG,CAACG,gBAAJ,CAAqBwG,EAArB,CAJT,EAKE;AACE;AACA;AACA;AACA,cAAMjN,KAAK,GAAG,MAAA/C,mBAAmB,CAAC,KAAKmS,QAAN,EAAgBnC,EAAhB,CAAnB,UAAA,iBAAA,SAAA,MAAwCjN,KAAtD;;AAEA,YAAIA,KAAJ,EAAW;AACPA,UAAAA,KAAK,CAAC++B,UAAN,CAAiB6C,uBAAjB;AACAD,UAAAA,uBAAuB,GAAGlkC,SAA1B;AACH;;AAED,YACI,CAACkkC,uBAAD,IACA,KAAKvyB,QAAL,CAAcvP,SAAd,CAAwB0T,WAAxB,CAAoCtG,EAApC,CAFJ,EAGE;AACE00B,UAAAA,uBAAuB,GAAGC,uBAAuB,GAAG30B,EAApD;AACH;AACJ;AACJ,KAjCO;;AA+cA,mBAAA,GAAa,MAAOqO,KAAP;;;AACjB,UAAI,KAAKumB,kBAAT,EAA6B;AACzB,aAAK/sB,IAAL,GAAYzL,YAAZ,CAAyB,KAAKw4B,kBAA9B;;AACA,eAAO,KAAKA,kBAAZ;AACH;;AAED,YAAA,KAAKC,oBAAL,UAAA,iBAAA,SAAA,iBAA4B,MAA5B;AAGA;;AACA,UAAIxmB,KAAK,CAAC2Y,OAAN,IAAiB3Y,KAAK,CAACsc,MAAvB,IAAiCtc,KAAK,CAAC6Y,QAAvC,IAAmD7Y,KAAK,CAACuc,OAA7D,EAAsE;AAClE;AACH;;AAED,YAAMj5B,GAAG,GAAG0c,KAAK,CAAC1c,GAAlB;AACA,UAAImjC,QAAJ;;AAEA,UAAInjC,GAAG,KAAKw0B,IAAI,CAACp3B,SAAjB,EAA4B;AACxB+lC,QAAAA,QAAQ,GAAGpkC,SAAA,CAAgB3B,SAA3B;AACH,OAFD,MAEO,IAAI4C,GAAG,KAAKw0B,IAAI,CAACl3B,UAAjB,EAA6B;AAChC6lC,QAAAA,QAAQ,GAAGpkC,SAAA,CAAgBzB,UAA3B;AACH,OAFM,MAEA,IAAI0C,GAAG,KAAKw0B,IAAI,CAACr3B,OAAjB,EAA0B;AAC7BgmC,QAAAA,QAAQ,GAAGpkC,SAAA,CAAgB5B,OAA3B;AACH,OAFM,MAEA,IAAI6C,GAAG,KAAKw0B,IAAI,CAACn3B,SAAjB,EAA4B;AAC/B8lC,QAAAA,QAAQ,GAAGpkC,SAAA,CAAgB1B,SAA3B;AACH,OAFM,MAEA,IAAI2C,GAAG,KAAKw0B,IAAI,CAACh3B,QAAjB,EAA2B;AAC9B2lC,QAAAA,QAAQ,GAAGpkC,SAAA,CAAgBvB,QAA3B;AACH,OAFM,MAEA,IAAIwC,GAAG,KAAKw0B,IAAI,CAACj3B,MAAjB,EAAyB;AAC5B4lC,QAAAA,QAAQ,GAAGpkC,SAAA,CAAgBxB,MAA3B;AACH,OAFM,MAEA,IAAIyC,GAAG,KAAKw0B,IAAI,CAAC/2B,IAAjB,EAAuB;AAC1B0lC,QAAAA,QAAQ,GAAGpkC,SAAA,CAAgBtB,IAA3B;AACH,OAFM,MAEA,IAAIuC,GAAG,KAAKw0B,IAAI,CAAC92B,GAAjB,EAAsB;AACzBylC,QAAAA,QAAQ,GAAGpkC,SAAA,CAAgBrB,GAA3B;AACH;;AAED,UAAI,CAACylC,QAAL,EAAe;AACX;AACH;;AAED,YAAM9S,OAAO,GAAG,KAAK7f,QAAL,CAAcwL,cAAd,CAA6BkK,iBAA7B,EAAhB;;AAEA,UAAI,CAACmK,OAAD,KAAa,MAAM,KAAK+S,eAAL,CAAqB/S,OAArB,EAA8BrwB,GAA9B,CAAnB,CAAJ,EAA4D;AACxD;AACH;;AAED,WAAKqjC,UAAL,CAAgBhT,OAAhB,EAAyB8S,QAAzB,EAAmCzmB,KAAnC;AACH,KA9CO;;AAgDA,qBAAA,GAAgBjd,CAAD;;;AACnB,YAAMlB,OAAO,GAAGkB,CAAC,CAACqd,YAAF,GAAiB,CAAjB,CAAhB;AACA,YAAM9c,GAAG,GAAG,MAAAP,CAAC,CAACsD,MAAF,UAAA,iBAAA,SAAA,MAAU/C,GAAtB;;AAEA,UAAIzB,OAAO,IAAIyB,GAAG,KAAKnB,SAAnB,IAAgC,CAACY,CAAC,CAAC25B,gBAAvC,EAAyD;AACrD,aAAKiK,UAAL,CAAgB9kC,OAAhB,EAAyByB,GAAzB;;AACAP,QAAAA,CAAC,CAAC4lB,wBAAF;AACH;AACJ,KARO;;AAUA,4BAAA,GAAuB5lB,CAAD;;;AAC1B,YAAMsL,MAAM,GAAGtL,CAAC,CAACqd,YAAF,GAAiB,CAAjB,CAAf;AACA,UAAIwmB,gBAAgB,GAAG,MAAA7jC,CAAC,CAACsD,MAAF,UAAA,iBAAA,SAAA,MAAUugC,gBAAjC;;AAEA,UAAIv4B,MAAJ,EAAY;AACR,cAAMlB,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0B,KAAKlO,QAA/B,EAAyCzF,MAAzC,CAAZ;AACA,cAAM3J,KAAK,GAAGyI,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEzI,KAAnB;;AAEA,YAAIA,KAAJ,EAAW;AACP,cACIkiC,gBAAgB,IAChB,CAAC57B,GAAG,CAACI,YAAJ,CAAiB1G,KAAK,CAACuP,UAAN,EAAjB,EAAqC2yB,gBAArC,CAFL,EAGE;AACEA,YAAAA,gBAAgB,GAAGzkC,SAAnB;AACH;;AAEDuC,UAAAA,KAAK,CAAC++B,UAAN,CAAiBmD,gBAAjB;AAEA7jC,UAAAA,CAAC,CAAC4lB,wBAAF;AACH;AACJ;AACJ,KArBO;;AAhlBJ,SAAK7U,QAAL,GAAgBlS,OAAhB;AACA,SAAK4X,IAAL,GAAYvM,SAAZ;AACA,SAAKm5B,OAAL,GAAe,EAAf;AAEAxkC,IAAAA,OAAO,CAAC0f,SAAR,CAAkB,KAAKqT,KAAvB;AACH;;AAeD3yB,EAAAA,OAAO;;;AACH,UAAMkL,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,SAAK1F,QAAL,CAAcwL,cAAd,CAA6B+J,WAA7B,CAAyC,KAAKxO,QAA9C;;AAEA,UAAA,KAAK2rB,oBAAL,UAAA,iBAAA,SAAA,iBAA4B,MAA5B;;AAEA,QAAI,KAAKD,kBAAT,EAA6B;AACzBr5B,MAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAKw4B,kBAAtB;AACA,aAAO,KAAKA,kBAAZ;AACH;;AAEDr5B,IAAAA,GAAG,CAAC6I,mBAAJ,CAAwB,SAAxB,EAAmC,KAAKwiB,UAAxC,EAAoD,IAApD;AACArrB,IAAAA,GAAG,CAAC6I,mBAAJ,CAAwBrQ,uBAAxB,EAAiD,KAAKy2B,YAAtD;AACAjvB,IAAAA,GAAG,CAAC6I,mBAAJ,CACIpQ,8BADJ,EAEI,KAAKwgC,mBAFT;AAKA5iC,IAAAA,MAAM,CAACC,IAAP,CAAY,KAAK4iC,OAAjB,EAA0B7kB,OAA1B,CAAmCslB,OAAD;AAC9B,UAAI,KAAKT,OAAL,CAAaS,OAAb,CAAJ,EAA2B;AACvB,aAAKT,OAAL,CAAaS,OAAb,EAAsB7kC,OAAtB;;AACA,eAAO,KAAKokC,OAAL,CAAaS,OAAb,CAAP;AACH;AACJ,KALD;AAMH;;AAEDliC,EAAAA,WAAW,CACP9C,OADO,EAEPgS,KAFO,EAGP/P,GAHO;AAKP,QAAId,sCAAJ,EAAa;;AAIb,UAAM8jC,QAAQ,GAAG,IAAIpwB,KAAJ,CACb,KAAK5C,QADQ,EAEbjS,OAFa,EAGb,KAAKklC,eAHQ,EAIblzB,KAJa,EAKb/P,GALa,CAAjB;AAOA,SAAKsiC,OAAL,CAAaU,QAAQ,CAACz9B,EAAtB,IAA4By9B,QAA5B;AACA,WAAOA,QAAP;AACH;;AAyCDtJ,EAAAA,SAAS,CACLwJ,WADK,EAEL1jC,GAFK;AAIL,WAAO,KAAKqjC,UAAL,CAAgBK,WAAhB,EAA6B1jC,GAA7B,CAAP;AACH;;AAEOqjC,EAAAA,UAAU,CACdK,WADc,EAEd1jC,GAFc,EAGdkU,YAHc;;;AAKd,UAAM5V,OAAO,GAAG,KAAKkS,QAArB;AACA,UAAM3G,GAAG,GAAG4T,OAAO,CAACiB,iBAAR,CAA0BpgB,OAA1B,EAAmColC,WAAnC,EAAgD;AACxD9kB,MAAAA,QAAQ,EAAE;AAD8C,KAAhD,CAAZ;;AAIA,QACI,CAAC/U,GAAD,IACA,CAACA,GAAG,CAACzI,KADL,IAEAyI,GAAG,CAACkV,iBAFJ,IAGC7K,YAAY,IAAIrK,GAAG,CAACsV,aAAJ,CAAkBjL,YAAlB,CAJrB,EAKE;AACE,aAAO,IAAP;AACH;;AAED,UAAM9S,KAAK,GAAGyI,GAAG,CAACzI,KAAlB;AACA,UAAMsM,SAAS,GAAGtM,KAAK,CAACuP,UAAN,EAAlB;;AAEA,QAAI9G,GAAG,CAACmV,mBAAR,EAA6B;AACzB,YAAM9d,QAAQ,GAAG2I,GAAG,CAAC3I,QAArB;;AAEA,UAAIA,QAAQ,IAAI,CAACA,QAAQ,CAACwe,QAAT,CAAkB,IAAlB,CAAjB,EAA0C;AACtC;AACA;AACA,aACI,IAAIrR,EAAE,GACF3G,GAAG,CAACG,gBAAJ,CAAqB3G,QAAQ,CAACyP,UAAT,EAArB,CAFR,EAGItC,EAAE,IAAIA,EAAE,KAAKX,SAHjB,EAIIW,EAAE,GAAG3G,GAAG,CAACG,gBAAJ,CAAqBwG,EAArB,CAJT,EAKE;AACE,cACI,MAAA,MAAAhQ,mBAAmB,CAACC,OAAD,EAAU+P,EAAV,CAAnB,UAAA,iBAAA,SAAA,MAAkCnN,QAAlC,UAAA,iBAAA,SAAA,MAA4Cwe,SACxC,KAFR,EAIE;AACE,mBAAO,IAAP;AACH;AACJ;AACJ,OAjBD,MAiBO;AACH,eAAO,IAAP;AACH;AACJ;;AAED,QAAI,CAAChS,SAAL,EAAgB;AACZ,aAAO,IAAP;AACH;;AAED,UAAMzM,SAAS,GAAG3C,OAAO,CAAC2C,SAA1B;AACA,UAAM0iC,UAAU,GAAGviC,KAAK,CAACwP,QAAN,EAAnB;AACA,UAAMgzB,SAAS,GAAGD,UAAU,CAACC,SAAX,IAAwB7kC,eAAA,CAAsBlC,IAAhE;AACA,UAAMgnC,MAAM,GAAGD,SAAS,KAAK7kC,eAAA,CAAsBlC,IAAnD;AACA,UAAMinC,UAAU,GACZD,MAAM,IAAID,SAAS,KAAK7kC,eAAA,CAAsBjC,QADlD;AAEA,UAAMinC,YAAY,GACdF,MAAM,IAAID,SAAS,KAAK7kC,eAAA,CAAsBhC,UADlD;AAEA,UAAMinC,YAAY,GAAGJ,SAAS,KAAK7kC,eAAA,CAAsB9B,UAAzD;AACA,UAAMgnC,MAAM,GAAGD,YAAY,IAAIJ,SAAS,KAAK7kC,eAAA,CAAsB/B,IAAnE;AACA,UAAMknC,QAAQ,GAAGP,UAAU,CAACQ,MAA5B;AAEA,QAAIlvB,IAAJ;AACA,QAAImvB,iBAAJ;AAEA,QAAIC,kBAAJ;AACA,QAAIC,gBAAgB,GAAG,CAAvB;AACA,QAAIC,gBAAgB,GAAG,CAAvB;;AAEA,QAAIN,MAAJ,EAAY;AACRI,MAAAA,kBAAkB,GAAGX,WAAW,CAACx2B,qBAAZ,EAArB;AACAo3B,MAAAA,gBAAgB,GAAGn3B,IAAI,CAACq3B,IAAL,CAAUH,kBAAkB,CAACp7B,IAA7B,CAAnB;AACAs7B,MAAAA,gBAAgB,GAAGp3B,IAAI,CAACs3B,KAAL,CAAWJ,kBAAkB,CAACl7B,KAA9B,CAAnB;AACH;;AAED,QAAIU,GAAG,CAACoW,GAAR,EAAa;AACT,UAAIjgB,GAAG,KAAKjB,SAAA,CAAgBzB,UAA5B,EAAwC;AACpC0C,QAAAA,GAAG,GAAGjB,SAAA,CAAgB1B,SAAtB;AACH,OAFD,MAEO,IAAI2C,GAAG,KAAKjB,SAAA,CAAgB1B,SAA5B,EAAuC;AAC1C2C,QAAAA,GAAG,GAAGjB,SAAA,CAAgBzB,UAAtB;AACH;AACJ;;AAED,QACK0C,GAAG,KAAKjB,SAAA,CAAgB3B,SAAxB,IAAqC0mC,UAAtC,IACC9jC,GAAG,KAAKjB,SAAA,CAAgBzB,UAAxB,KAAuCymC,YAAY,IAAIE,MAAvD,CAFL,EAGE;AACEhvB,MAAAA,IAAI,GAAGhU,SAAS,CAACkxB,QAAV,CAAmB;AACtBO,QAAAA,cAAc,EAAEgR,WADM;AAEtBh2B,QAAAA,SAFsB;AAGtB0X,QAAAA,kBAAkB,EAAE;AAHE,OAAnB,CAAP;;AAMA,UAAInQ,IAAI,IAAIgvB,MAAZ,EAAoB;AAChB,cAAMS,aAAa,GAAGv3B,IAAI,CAACq3B,IAAL,CAClBvvB,IAAI,CAAC/H,qBAAL,GAA6BjE,IADX,CAAtB;;AAIA,YAAI,CAAC+6B,YAAD,IAAiBO,gBAAgB,GAAGG,aAAxC,EAAuD;AACnDzvB,UAAAA,IAAI,GAAGpW,SAAP;AACH;AACJ,OARD,MAQO,IAAI,CAACoW,IAAD,IAASivB,QAAb,EAAuB;AAC1BjvB,QAAAA,IAAI,GAAGhU,SAAS,CAACkkB,SAAV,CAAoB;AACvBzX,UAAAA,SADuB;AAEvB0X,UAAAA,kBAAkB,EAAE;AAFG,SAApB,CAAP;AAIH;AACJ,KAxBD,MAwBO,IACFplB,GAAG,KAAKjB,SAAA,CAAgB5B,OAAxB,IAAmC2mC,UAApC,IACC9jC,GAAG,KAAKjB,SAAA,CAAgB1B,SAAxB,KAAsC0mC,YAAY,IAAIE,MAAtD,CAFE,EAGL;AACEhvB,MAAAA,IAAI,GAAGhU,SAAS,CAACmxB,QAAV,CAAmB;AACtBM,QAAAA,cAAc,EAAEgR,WADM;AAEtBh2B,QAAAA,SAFsB;AAGtB0X,QAAAA,kBAAkB,EAAE;AAHE,OAAnB,CAAP;;AAMA,UAAInQ,IAAI,IAAIgvB,MAAZ,EAAoB;AAChB,cAAMU,aAAa,GAAGx3B,IAAI,CAACs3B,KAAL,CAClBxvB,IAAI,CAAC/H,qBAAL,GAA6B/D,KADX,CAAtB;;AAIA,YAAI,CAAC66B,YAAD,IAAiBW,aAAa,GAAGL,gBAArC,EAAuD;AACnDrvB,UAAAA,IAAI,GAAGpW,SAAP;AACH;AACJ,OARD,MAQO,IAAI,CAACoW,IAAD,IAASivB,QAAb,EAAuB;AAC1BjvB,QAAAA,IAAI,GAAGhU,SAAS,CAACixB,QAAV,CAAmB;AACtBxkB,UAAAA,SADsB;AAEtB0X,UAAAA,kBAAkB,EAAE;AAFE,SAAnB,CAAP;AAIH;AACJ,KAxBM,MAwBA,IAAIplB,GAAG,KAAKjB,SAAA,CAAgBtB,IAA5B,EAAkC;AACrC,UAAIwmC,MAAJ,EAAY;AACRhjC,QAAAA,SAAS,CAACwqB,WAAV,CAAsB;AAClB/d,UAAAA,SADkB;AAElBglB,UAAAA,cAAc,EAAEgR,WAFE;AAGlBte,UAAAA,kBAAkB,EAAE,IAHF;AAIlB5Q,UAAAA,UAAU,EAAE,IAJM;AAKlB6d,UAAAA,eAAe,EAAGhkB,EAAD;;;AACb,gBAAI,CAACpN,SAAS,CAAC0T,WAAV,CAAsBtG,EAAtB,CAAL,EAAgC;AAC5B,qBAAO,KAAP;AACH;;AAED,kBAAMq2B,aAAa,GAAGv3B,IAAI,CAACq3B,IAAL,CAClB,MAAAn2B,EAAE,CAACnB,qBAAH,GAA2BjE,IAA3B,UAAA,iBAAA,KAAA,GAAmC,CADjB,CAAtB;;AAIA,gBACIoF,EAAE,KAAKq1B,WAAP,IACAY,gBAAgB,IAAII,aAFxB,EAGE;AACE,qBAAO,IAAP;AACH;;AAEDzvB,YAAAA,IAAI,GAAG5G,EAAP;AACA,mBAAO,KAAP;AACH;AAvBiB,SAAtB;AAyBH,OA1BD,MA0BO;AACH4G,QAAAA,IAAI,GAAGhU,SAAS,CAACkkB,SAAV,CAAoB;AACvBzX,UAAAA,SADuB;AAEvB0X,UAAAA,kBAAkB,EAAE;AAFG,SAApB,CAAP;AAIH;AACJ,KAjCM,MAiCA,IAAIplB,GAAG,KAAKjB,SAAA,CAAgBrB,GAA5B,EAAiC;AACpC,UAAIumC,MAAJ,EAAY;AACRhjC,QAAAA,SAAS,CAACwqB,WAAV,CAAsB;AAClB/d,UAAAA,SADkB;AAElBglB,UAAAA,cAAc,EAAEgR,WAFE;AAGlBte,UAAAA,kBAAkB,EAAE,IAHF;AAIlBiN,UAAAA,eAAe,EAAGhkB,EAAD;;;AACb,gBAAI,CAACpN,SAAS,CAAC0T,WAAV,CAAsBtG,EAAtB,CAAL,EAAgC;AAC5B,qBAAO,KAAP;AACH;;AAED,kBAAMq2B,aAAa,GAAGv3B,IAAI,CAACq3B,IAAL,CAClB,MAAAn2B,EAAE,CAACnB,qBAAH,GAA2BjE,IAA3B,UAAA,iBAAA,KAAA,GAAmC,CADjB,CAAtB;;AAIA,gBACIoF,EAAE,KAAKq1B,WAAP,IACAY,gBAAgB,IAAII,aAFxB,EAGE;AACE,qBAAO,IAAP;AACH;;AAEDzvB,YAAAA,IAAI,GAAG5G,EAAP;AACA,mBAAO,KAAP;AACH;AAtBiB,SAAtB;AAwBH,OAzBD,MAyBO;AACH4G,QAAAA,IAAI,GAAGhU,SAAS,CAACixB,QAAV,CAAmB;AACtBxkB,UAAAA,SADsB;AAEtB0X,UAAAA,kBAAkB,EAAE;AAFE,SAAnB,CAAP;AAIH;AACJ,KAhCM,MAgCA,IAAIplB,GAAG,KAAKjB,SAAA,CAAgBxB,MAA5B,EAAoC;AACvC0D,MAAAA,SAAS,CAACwqB,WAAV,CAAsB;AAClBiH,QAAAA,cAAc,EAAEgR,WADE;AAElBh2B,QAAAA,SAFkB;AAGlB0X,QAAAA,kBAAkB,EAAE,IAHF;AAIlB5Q,QAAAA,UAAU,EAAE,IAJM;AAKlB6d,QAAAA,eAAe,EAAGhkB,EAAD;AACb,cAAI,CAACpN,SAAS,CAAC0T,WAAV,CAAsBtG,EAAtB,CAAL,EAAgC;AAC5B,mBAAO,KAAP;AACH;;AAED,cACIb,qCAAqC,CACjC,KAAK0I,IAD4B,EAEjC7H,EAFiC,EAGjCjN,KAAK,CAACk+B,mBAH2B,CADzC,EAME;AACErqB,YAAAA,IAAI,GAAG5G,EAAP;AACA,mBAAO,KAAP;AACH;;AAED,iBAAO,IAAP;AACH;AAtBiB,OAAtB,EADuC;;AA2BvC,UAAI41B,MAAM,IAAIhvB,IAAd,EAAoB;AAChB,cAAM2vB,aAAa,GAAGz3B,IAAI,CAACq3B,IAAL,CAClBvvB,IAAI,CAAC/H,qBAAL,GAA6BjE,IADX,CAAtB;AAGAhI,QAAAA,SAAS,CAACwqB,WAAV,CAAsB;AAClBiH,UAAAA,cAAc,EAAEzd,IADE;AAElBvH,UAAAA,SAFkB;AAGlB0X,UAAAA,kBAAkB,EAAE,IAHF;AAIlBiN,UAAAA,eAAe,EAAGhkB,EAAD;AACb,gBAAI,CAACpN,SAAS,CAAC0T,WAAV,CAAsBtG,EAAtB,CAAL,EAAgC;AAC5B,qBAAO,KAAP;AACH;;AAED,kBAAMq2B,aAAa,GAAGv3B,IAAI,CAACq3B,IAAL,CAClBn2B,EAAE,CAACnB,qBAAH,GAA2BjE,IADT,CAAtB;;AAGA,gBACIq7B,gBAAgB,GAAGI,aAAnB,IACAE,aAAa,IAAIF,aAFrB,EAGE;AACE,qBAAO,IAAP;AACH;;AACDzvB,YAAAA,IAAI,GAAG5G,EAAP;AACA,mBAAO,KAAP;AACH;AApBiB,SAAtB;AAsBH;;AAED+1B,MAAAA,iBAAiB,GAAG,KAApB;AACH,KAxDM,MAwDA,IAAIpkC,GAAG,KAAKjB,SAAA,CAAgBvB,QAA5B,EAAsC;AACzCyD,MAAAA,SAAS,CAACwqB,WAAV,CAAsB;AAClBiH,QAAAA,cAAc,EAAEgR,WADE;AAElBh2B,QAAAA,SAFkB;AAGlB0X,QAAAA,kBAAkB,EAAE,IAHF;AAIlBiN,QAAAA,eAAe,EAAGhkB,EAAD;AACb,cAAI,CAACpN,SAAS,CAAC0T,WAAV,CAAsBtG,EAAtB,CAAL,EAAgC;AAC5B,mBAAO,KAAP;AACH;;AAED,cACIb,qCAAqC,CACjC,KAAK0I,IAD4B,EAEjC7H,EAFiC,EAGjCjN,KAAK,CAACk+B,mBAH2B,CADzC,EAME;AACErqB,YAAAA,IAAI,GAAG5G,EAAP;AACA,mBAAO,KAAP;AACH;;AAED,iBAAO,IAAP;AACH;AArBiB,OAAtB,EADyC;;AA0BzC,UAAI41B,MAAM,IAAIhvB,IAAd,EAAoB;AAChB,cAAM4vB,YAAY,GAAG13B,IAAI,CAACq3B,IAAL,CACjBvvB,IAAI,CAAC/H,qBAAL,GAA6BjE,IADZ,CAArB;AAGAhI,QAAAA,SAAS,CAACwqB,WAAV,CAAsB;AAClBiH,UAAAA,cAAc,EAAEzd,IADE;AAElBvH,UAAAA,SAFkB;AAGlB0X,UAAAA,kBAAkB,EAAE,IAHF;AAIlB5Q,UAAAA,UAAU,EAAE,IAJM;AAKlB6d,UAAAA,eAAe,EAAGhkB,EAAD;AACb,gBAAI,CAACpN,SAAS,CAAC0T,WAAV,CAAsBtG,EAAtB,CAAL,EAAgC;AAC5B,qBAAO,KAAP;AACH;;AAED,kBAAMq2B,aAAa,GAAGv3B,IAAI,CAACq3B,IAAL,CAClBn2B,EAAE,CAACnB,qBAAH,GAA2BjE,IADT,CAAtB;;AAGA,gBACIq7B,gBAAgB,GAAGI,aAAnB,IACAG,YAAY,IAAIH,aAFpB,EAGE;AACE,qBAAO,IAAP;AACH;;AACDzvB,YAAAA,IAAI,GAAG5G,EAAP;AACA,mBAAO,KAAP;AACH;AArBiB,SAAtB;AAuBH;;AAED+1B,MAAAA,iBAAiB,GAAG,IAApB;AACH,KAxDM,MAwDA,IAAIH,MAAJ,EAAY;AACf,YAAMzvB,UAAU,GAAGxU,GAAG,KAAKjB,SAAA,CAAgB5B,OAA3C;AACA,YAAM8kC,GAAG,GAAGqC,gBAAZ,CAFe;;AAIf,YAAMpC,GAAG,GAAG/0B,IAAI,CAACq3B,IAAL,CAAUH,kBAAmB,CAACn7B,GAA9B,CAAZ;AACA,YAAMi5B,GAAG,GAAGoC,gBAAZ,CALe;;AAOf,YAAMnC,GAAG,GAAGj1B,IAAI,CAACs3B,KAAL,CAAWJ,kBAAmB,CAACj7B,MAA/B,CAAZ;AACA,UAAIgM,aAAJ;AACA,UAAI0vB,YAAJ;AACA,UAAIC,gBAAgB,GAAG,CAAvB;AAEA9jC,MAAAA,SAAS,CAACsxB,OAAV,CAAkB;AACd7kB,QAAAA,SADc;AAEdglB,QAAAA,cAAc,EAAEgR,WAFF;AAGdlvB,QAAAA,UAHc;AAIdoe,QAAAA,SAAS,EAAGvkB,EAAD;AACP;AACA;AACA,gBAAMzB,IAAI,GAAGyB,EAAE,CAACnB,qBAAH,EAAb;AAEA,gBAAMm1B,GAAG,GAAGl1B,IAAI,CAACq3B,IAAL,CAAU53B,IAAI,CAAC3D,IAAf,CAAZ;AACA,gBAAMq5B,GAAG,GAAGn1B,IAAI,CAACq3B,IAAL,CAAU53B,IAAI,CAAC1D,GAAf,CAAZ;AACA,gBAAMq5B,GAAG,GAAGp1B,IAAI,CAACs3B,KAAL,CAAW73B,IAAI,CAACzD,KAAhB,CAAZ;AACA,gBAAMq5B,GAAG,GAAGr1B,IAAI,CAACs3B,KAAL,CAAW73B,IAAI,CAACxD,MAAhB,CAAZ;;AAEA,cACKoL,UAAU,IAAI0tB,GAAG,GAAGM,GAArB,IACC,CAAChuB,UAAD,IAAe4tB,GAAG,GAAGE,GAF1B,EAGE;AACE;AACA,mBAAO,IAAP;AACH;;AAED,gBAAM0C,kBAAkB,GACpB73B,IAAI,CAACq3B,IAAL,CAAUr3B,IAAI,CAACE,GAAL,CAAS80B,GAAT,EAAcI,GAAd,CAAV,IACAp1B,IAAI,CAACs3B,KAAL,CAAWt3B,IAAI,CAACC,GAAL,CAAS60B,GAAT,EAAcI,GAAd,CAAX,CAFJ;AAGA,gBAAM4C,QAAQ,GAAG93B,IAAI,CAACq3B,IAAL,CAAUr3B,IAAI,CAACE,GAAL,CAAS80B,GAAG,GAAGF,GAAf,EAAoBM,GAAG,GAAGF,GAA1B,CAAV,CAAjB;;AAEA,cACI2C,kBAAkB,GAAG,CAArB,IACAC,QAAQ,IAAID,kBAFhB,EAGE;AACE;AACA,kBAAME,YAAY,GAAGF,kBAAkB,GAAGC,QAA1C;;AAEA,gBAAIC,YAAY,GAAGH,gBAAnB,EAAqC;AACjC3vB,cAAAA,aAAa,GAAG/G,EAAhB;AACA02B,cAAAA,gBAAgB,GAAGG,YAAnB;AACH;AACJ,WAXD,MAWO,IAAIH,gBAAgB,KAAK,CAAzB,EAA4B;AAC/B;AACA,kBAAMI,QAAQ,GAAGnD,WAAW,CACxBC,GADwB,EAExBC,GAFwB,EAGxBC,GAHwB,EAIxBC,GAJwB,EAKxBC,GALwB,EAMxBC,GANwB,EAOxBC,GAPwB,EAQxBC,GARwB,CAA5B;;AAWA,gBACIsC,YAAY,KAAKjmC,SAAjB,IACAsmC,QAAQ,GAAGL,YAFf,EAGE;AACEA,cAAAA,YAAY,GAAGK,QAAf;AACA/vB,cAAAA,aAAa,GAAG/G,EAAhB;AACH;AACJ,WApBM,MAoBA,IAAI02B,gBAAgB,GAAG,CAAvB,EAA0B;AAC7B;AACA,mBAAO,KAAP;AACH;;AAED,iBAAO,IAAP;AACH;AAhEa,OAAlB;AAmEA9vB,MAAAA,IAAI,GAAGG,aAAP;AACH;;AAED,QACIH,IAAI,KACH,CAACf,YAAD,IACIA,YAAY,IACTxG,SAAS,CAACoH,aAAV,CACI,IAAIxR,qBAAJ,CAA0B;AACtByR,MAAAA,EAAE,EAAE,OADkB;AAEtBC,MAAAA,KAAK,EAAEtH,SAFe;AAGtBuH,MAAAA,IAHsB;AAItBf,MAAAA;AAJsB,KAA1B,CADJ,CAHJ,CADR,EAYE;AACE,UAAIkwB,iBAAiB,KAAKvlC,SAA1B,EAAqC;AACjCqP,QAAAA,cAAc,CAAC,KAAKgI,IAAN,EAAYjB,IAAZ,EAAkBmvB,iBAAlB,CAAd;AACH;;AAED,UAAIlwB,YAAJ,EAAkB;AACdA,QAAAA,YAAY,CAAC0hB,cAAb;AACA1hB,QAAAA,YAAY,CAACmR,wBAAb;AACH;;AAEDpU,MAAAA,mBAAW,CAACgE,IAAD,CAAX;AAEA,aAAOA,IAAP;AACH;;AAED,WAAO,IAAP;AACH;;AAmF4B,QAAfmuB,eAAe,CACzB7kC,OADyB,EAEzByB,GAFyB;AAIzB,QACIzB,OAAO,CAACO,YAAR,CAAqB,eAArB,MAA0C,MAA1C,IACAP,OAAO,CAACuzB,YAAR,CAAqB,uBAArB,CAFJ,EAGE;AACE;AACA;AACA,aAAO,IAAP;AACH;;AAED,QAAI9hB,eAAe,CAACzR,OAAD,EAAU+/B,cAAV,CAAnB,EAA8C;AAC1C,UAAI8G,cAAc,GAAG,CAArB;AACA,UAAIC,YAAY,GAAG,CAAnB;AACA,UAAIC,UAAU,GAAG,CAAjB;AACA,UAAIC,QAAJ;;AAEA,UAAIhnC,OAAO,CAACmW,OAAR,KAAoB,OAApB,IAA+BnW,OAAO,CAACmW,OAAR,KAAoB,UAAvD,EAAmE;AAC/D,cAAM5R,IAAI,GAAIvE,OAA4B,CAACuE,IAA3C;AACA,cAAMsX,KAAK,GAAI7b,OAA4B,CAAC6b,KAA5C;AAEAkrB,QAAAA,UAAU,GAAG,CAAClrB,KAAK,IAAI,EAAV,EAAc3Y,MAA3B;;AAEA,YAAIqB,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,QAAjC,EAA2C;AACvC;AACA;AACA;AACA;AACA,cAAIwiC,UAAJ,EAAgB;AACZ,kBAAME,SAAS,GAAG99B,GAAG,CAACD,YAAJ,CAAiBlJ,OAAjB,CAAlB;;AAEA,gBAAIinC,SAAJ,EAAe;AACX,oBAAMC,aAAa,GAAGD,SAAS,CAACn2B,QAAV,GAAqB5N,MAA3C;AACA,oBAAM+S,UAAU,GACZxU,GAAG,KAAKw0B,IAAI,CAACn3B,SAAb,IAA0B2C,GAAG,KAAKw0B,IAAI,CAACr3B,OAD3C;AAGAqoC,cAAAA,SAAS,CAACE,MAAV,CACI,QADJ,EAEIlxB,UAAU,GAAG,UAAH,GAAgB,SAF9B,EAGI,WAHJ;;AAMA,kBAAIixB,aAAa,KAAKD,SAAS,CAACn2B,QAAV,GAAqB5N,MAA3C,EAAmD;AAC/C;AACA;AACA+jC,gBAAAA,SAAS,CAACE,MAAV,CACI,QADJ,EAEIlxB,UAAU,GAAG,SAAH,GAAe,UAF7B,EAGI,WAHJ;AAMA,uBAAO,IAAP;AACH,eAVD,MAUO;AACH8wB,gBAAAA,UAAU,GAAG,CAAb;AACH;AACJ;AACJ;AACJ,SAlCD,MAkCO;AACH,gBAAMK,QAAQ,GAAIpnC,OAA4B,CACzC6mC,cADL;;AAGA,cAAIO,QAAQ,KAAK,IAAjB,EAAuB;AACnB;AACA,mBAAO7iC,IAAI,KAAK,QAAhB;AACH;;AAEDsiC,UAAAA,cAAc,GAAGO,QAAQ,IAAI,CAA7B;AACAN,UAAAA,YAAY,GACP9mC,OAA4B,CAAC8mC,YAA7B,IAA6C,CADlD;AAEH;AACJ,OArDD,MAqDO,IAAI9mC,OAAO,CAAC+2B,eAAR,KAA4B,MAAhC,EAAwC;AAC3CiQ,QAAAA,QAAQ,GAAG,KAAKn1B,UAAU,CAAC,KAAK8F,IAAN,CAAf,EAA6B8K,OAAD;AACnC,eAAKkiB,oBAAL,GAA6B9oB,KAAD;AACxB,mBAAO,KAAK8oB,oBAAZ;AACAliB,YAAAA,OAAO,CAAC5G,KAAD,CAAP;AACH,WAHD;;AAKA,gBAAMxQ,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,cAAI,KAAK+sB,kBAAT,EAA6B;AACzBr5B,YAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAKw4B,kBAAtB;AACH;;AAED,gBAAM;AACF2C,YAAAA,UAAU,EAAEC,cADV;AAEFC,YAAAA,SAAS,EAAEC,aAFT;AAGFC,YAAAA,YAAY,EAAEC,gBAHZ;AAIFC,YAAAA,WAAW,EAAEC;AAJX,cAKFz+B,GAAG,CAACD,YAAJ,CAAiBlJ,OAAjB,KAA6B,EALjC;;AAQA,eAAK0kC,kBAAL,GAA0Br5B,GAAG,CAACqC,UAAJ,CAAe;;;AACrC,mBAAO,KAAKg3B,kBAAZ;AAEA,kBAAM;AACF2C,cAAAA,UADE;AAEFE,cAAAA,SAFE;AAGFE,cAAAA,YAHE;AAIFE,cAAAA;AAJE,gBAKFx+B,GAAG,CAACD,YAAJ,CAAiBlJ,OAAjB,KAA6B,EALjC;;AAOA,gBACIqnC,UAAU,KAAKC,cAAf,IACAC,SAAS,KAAKC,aADd,IAEAC,YAAY,KAAKC,gBAFjB,IAGAC,WAAW,KAAKC,eAJpB,EAKE;AACE,oBAAA,KAAKjD,oBAAL,UAAA,iBAAA,SAAA,iBAA4B,MAA5B;AACA;AACH;;AAEDkC,YAAAA,cAAc,GAAGY,YAAY,IAAI,CAAjC;AACAX,YAAAA,YAAY,GAAGa,WAAW,IAAI,CAA9B;AACAZ,YAAAA,UAAU,GAAG,CAAA,MAAA/mC,OAAO,CAAC6nC,WAAR,UAAA,iBAAA,SAAA,MAAqB3kC,MAArB,KAA+B,CAA5C;;AAEA,gBAAImkC,UAAU,IAAIE,SAAlB,EAA6B;AACzB,kBACIp+B,GAAG,CAACI,YAAJ,CAAiBvJ,OAAjB,EAA0BqnC,UAA1B,KACAl+B,GAAG,CAACI,YAAJ,CAAiBvJ,OAAjB,EAA0BunC,SAA1B,CAFJ,EAGE;AACE,oBAAIF,UAAU,KAAKrnC,OAAnB,EAA4B;AACxB,sBAAI8nC,WAAW,GAAG,KAAlB;;AAEA,wBAAMC,UAAU,GACZ3hC,IADe;AAGf,wBAAIA,IAAI,KAAKihC,UAAb,EAAyB;AACrBS,sBAAAA,WAAW,GAAG,IAAd;AACH,qBAFD,MAEO,IAAI1hC,IAAI,KAAKmhC,SAAb,EAAwB;AAC3B,6BAAO,IAAP;AACH;;AAED,0BAAMS,QAAQ,GAAG5hC,IAAI,CAACyhC,WAAtB;;AAEA,wBACIG,QAAQ,IACR,CAAC7+B,GAAG,CAACM,aAAJ,CAAkBrD,IAAlB,CAFL,EAGE;AACE,4BAAM6hC,GAAG,GAAGD,QAAQ,CAAC9kC,MAArB;;AAEA,0BAAI4kC,WAAJ,EAAiB;AACb,4BAAIP,SAAS,KAAKF,UAAlB,EAA8B;AAC1BP,0BAAAA,YAAY,IAAImB,GAAhB;AACH;AACJ,uBAJD,MAIO;AACHpB,wBAAAA,cAAc,IAAIoB,GAAlB;AACAnB,wBAAAA,YAAY,IAAImB,GAAhB;AACH;AACJ;;AAED,wBAAIC,IAAI,GAAG,KAAX;;AAEA,yBACI,IAAIhnC,CAAC,GAAGiI,GAAG,CAACM,aAAJ,CAAkBrD,IAAlB,CADZ,EAEIlF,CAAC,IAAI,CAACgnC,IAFV,EAGIhnC,CAAC,GAAGA,CAAC,CAAC6G,WAHV,EAIE;AACEmgC,sBAAAA,IAAI,GAAGH,UAAU,CAAC7mC,CAAD,CAAjB;AACH;;AAED,2BAAOgnC,IAAP;AACH,mBAtCD;;AAwCAH,kBAAAA,UAAU,CAAC/nC,OAAD,CAAV;AACH;AACJ;AACJ;;AAED,kBAAA,KAAK2kC,oBAAL,UAAA,iBAAA,SAAA,iBAA4B,KAA5B;AACH,WA9EyB,EA8EvB,CA9EuB,CAA1B;AA+EH,SAnGU,CAAX;AAoGH;;AAED,UAAIqC,QAAQ,IAAI,EAAE,MAAMA,QAAR,CAAhB,EAAmC;AAC/B,eAAO,IAAP;AACH;;AAED,UAAIH,cAAc,KAAKC,YAAvB,EAAqC;AACjC,eAAO,IAAP;AACH;;AAED,UACID,cAAc,GAAG,CAAjB,KACCplC,GAAG,KAAKw0B,IAAI,CAACn3B,SAAb,IACG2C,GAAG,KAAKw0B,IAAI,CAACr3B,OADhB,IAEG6C,GAAG,KAAKw0B,IAAI,CAAC/2B,IAHjB,CADJ,EAKE;AACE,eAAO,IAAP;AACH;;AAED,UACI2nC,cAAc,GAAGE,UAAjB,KACCtlC,GAAG,KAAKw0B,IAAI,CAACl3B,UAAb,IACG0C,GAAG,KAAKw0B,IAAI,CAACp3B,SADhB,IAEG4C,GAAG,KAAKw0B,IAAI,CAAC92B,GAHjB,CADJ,EAKE;AACE,eAAO,IAAP;AACH;AACJ;;AAED,WAAO,KAAP;AACH;;;;AC3+CL;;;;SAgBgBgpC,iBACZpiC,KACAhG,SACAG,0BAKAkoC;AAEA,MAAI,OAAOviC,gBAAP,KAA4B,WAAhC,EAA6C;AACzC,WAAO;AACH;AACH,KAFD;AAGH;;AAED,QAAMuF,SAAS,GAAGrL,OAAO,CAACqL,SAA1B;AAEA,MAAII,YAAJ;;AAEA,QAAM68B,UAAU,GAAIhG,SAAD;;;AACf,UAAME,YAAY,GAAG,IAAIlrB,GAAJ,EAArB;;AAEA,SAAK,MAAMirB,QAAX,IAAuBD,SAAvB,EAAkC;AAC9B,YAAM71B,MAAM,GAAG81B,QAAQ,CAAC91B,MAAxB;AACA,YAAMoV,OAAO,GAAG0gB,QAAQ,CAACC,YAAzB;AACA,YAAMC,KAAK,GAAGF,QAAQ,CAACG,UAAvB;;AAEA,UAAIH,QAAQ,CAAC/9B,IAAT,KAAkB,YAAtB,EAAoC;AAChC,YAAI+9B,QAAQ,CAACI,aAAT,KAA2BliC,oBAA/B,EAA2D;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAI,CAAC+hC,YAAY,CAAC/qB,GAAb,CAAiBhL,MAAjB,CAAL,EAA+B;AAC3BtM,YAAAA,wBAAwB,CACpBH,OADoB,EAEpByM,MAFoB,CAAxB;AAIH;AACJ;AACJ,OAhBD,MAgBO;AACH,aAAK,IAAImE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiR,OAAO,CAAC1e,MAA5B,EAAoCyN,CAAC,EAArC,EAAyC;AACrC,gBAAM23B,WAAW,GAAG1mB,OAAO,CAACjR,CAAD,CAA3B;AACA4xB,UAAAA,YAAY,CAAC9qB,GAAb,CAAiB6wB,WAAjB;AACAC,UAAAA,qBAAqB,CAACD,WAAD,EAAc,IAAd,CAArB;AACA,gBAAA,MAAAvoC,OAAO,CAACga,cAAR,EAAuB/B,UAAvB,UAAA,iBAAA,SAAA,eAAoCxL,OAApC;AACH;;AAED,aAAK,IAAImE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6xB,KAAK,CAACt/B,MAA1B,EAAkCyN,CAAC,EAAnC,EAAuC;AACnC43B,UAAAA,qBAAqB,CAAC/F,KAAK,CAAC7xB,CAAD,CAAN,CAArB;AACA,gBAAA,MAAA5Q,OAAO,CAACga,cAAR,EAAuB/B,UAAvB,UAAA,iBAAA,SAAA,eAAoCxL,OAApC;AACH;AACJ;AACJ;;AAED+1B,IAAAA,YAAY,CAACjqB,KAAb;AAEA,UAAAvY,OAAO,CAACuC,SAAR,UAAA,iBAAA,SAAA,MAAmB+7B,cAAnB;AACH,GA1CD;;AA4CA,WAASkK,qBAAT,CAA+BniC,IAA/B,EAA2Cwb,OAA3C;AACI,QAAI,CAACpW,YAAL,EAAmB;AACfA,MAAAA,YAAY,GAAGL,kBAAkB,CAACC,SAAD,CAAlB,CAA8BI,YAA7C;AACH;;AAEDg9B,IAAAA,WAAW,CAACpiC,IAAD,EAAsBwb,OAAtB,CAAX;AAEA,UAAM+S,MAAM,GAAG/mB,uBAAuB,CAClC7H,GADkC,EAElCK,IAFkC,EAGjCpG,OAAD;AACI,aAAOwoC,WAAW,CAACxoC,OAAD,EAAyB4hB,OAAzB,CAAlB;AACH,KALiC,CAAtC;;AAQA,QAAI+S,MAAJ,EAAY;AACR,aAAOA,MAAM,CAACY,QAAP,EAAP,EAA0B;AACtB;AACH;AACJ;AACJ;;AAED,WAASiT,WAAT,CAAqBxoC,OAArB,EAA2C4hB,OAA3C;;;AACI,QAAI,CAAC5hB,OAAO,CAACO,YAAb,EAA2B;AACvB;AACA,aAAOyK,UAAU,CAACwqB,WAAlB;AACH;;AAED,UAAMtkB,GAAG,GAAIlR,OAA8B,CAACmR,mBAA5C;;AAEA,QAAID,GAAG,IAAI1F,YAAX,EAAyB;AACrB,UAAIoW,OAAJ,EAAa;AACT,eAAOpW,YAAY,CAAC0F,GAAD,CAAnB;AACH,OAFD,MAEO;AACH,cAAA1F,YAAY,CAAC0F,GAAD,CAAZ,UAAA,iBAAA,KAAA,GAAA1F,YAAY,CAAC0F,GAAD,CAAZ,GAAsB,IAAInE,eAAJ,CAAoB3B,SAApB,EAA+BpL,OAA/B,CAAtB;AACH;AACJ;;AAED,QACIF,mBAAmB,CAACC,OAAD,EAAUC,OAAV,CAAnB,IACAA,OAAO,CAACuzB,YAAR,CAAqB/yB,oBAArB,CAFJ,EAGE;AACEN,MAAAA,wBAAwB,CAACH,OAAD,EAAUC,OAAV,EAAmB4hB,OAAnB,CAAxB;AACH;;AAED,WAAO5W,UAAU,CAACwqB,WAAlB;AACH;;AAED,QAAM4M,QAAQ,GAAGj5B,GAAG,CAACC,sBAAJ,CAA2Bi/B,UAA3B,CAAjB;;AAEA,MAAID,SAAJ,EAAe;AACXG,IAAAA,qBAAqB,CAACn9B,SAAS,GAAGL,QAAZ,CAAqByG,IAAtB,CAArB;AACH;;AAED4wB,EAAAA,QAAQ,CAACU,OAAT,CAAiB/8B,GAAjB,EAAsB;AAClBq9B,IAAAA,SAAS,EAAE,IADO;AAElBC,IAAAA,OAAO,EAAE,IAFS;AAGlBC,IAAAA,UAAU,EAAE,IAHM;AAIlBC,IAAAA,eAAe,EAAE,CAAC/iC,oBAAD;AAJC,GAAtB;AAOA,SAAO;AACH4hC,IAAAA,QAAQ,CAACZ,UAAT;AACH,GAFD;AAGH;;AChJD;;;;AAeA,MAAMiH,sBAAsB,GAAG,GAA/B;MAeaC,2BACD9f;AAgBRtkB,EAAAA,YAAYvE;AACR;AAZI,iBAAA,GAA4C,EAA5C;AACA,4BAAA,GAAsB,CAAtB;AACA,sBAAA,GAAwD,EAAxD;AACA,wBAAA,GAEJ,EAFI;AAMA,iCAAA,GAA2B,CAA3B;;AAuBA,iBAAA,GAAYmB,CAAD;AACf,UAAIA,CAAJ,EAAO;AACH,cAAMoT,OAAO,GAAG,KAAKq0B,eAArB;;AAEA,YAAIr0B,OAAJ,EAAa;AACT,gBAAMs0B,KAAK,GAAG73B,IAAI,CAACC,GAAL,KAAa,KAAK63B,wBAAhC;;AACA,gBAAMC,UAAU,GAAG,GAAnB;;AAEA,cAAIF,KAAK,IAAIE,UAAb,EAAyB;AACrB;AACA;AACA,mBAAO,KAAKH,eAAZ;AACAr0B,YAAAA,OAAO,CAACy0B,MAAR;AACH;AACJ;AACJ;AACJ,KAhBO;;AAmNR,gCAAA,GAA2B/oC,OAAD;;;AACtB,YAAM+C,QAAQ,GAAG,MAAAjD,mBAAmB,CAAC,KAAKmS,QAAN,EAAgBjS,OAAhB,CAAnB,UAAA,iBAAA,SAAA,MAA6C+C,QAA9D;AACA,YAAMmO,GAAG,GAAGD,aAAa,CAAC,KAAK0G,IAAN,EAAY3X,OAAZ,CAAzB;AACA,UAAIgpC,IAAI,GAAoC,KAAKC,aAAL,CAAmB/3B,GAAnB,CAA5C;;AAEA,UAAInO,QAAQ,IAAI+J,gBAAgB,CAAC9M,OAAO,CAACiJ,aAAT,EAAwBjJ,OAAxB,CAAhC,EAAkE;AAC9D,YAAI,CAACgpC,IAAL,EAAW;AACPA,UAAAA,IAAI,GAAG,KAAKC,aAAL,CAAmB/3B,GAAnB,IAA0B;AAC7BlR,YAAAA,OAAO,EAAE,IAAI+M,eAAJ,CAAoB,KAAK4K,IAAzB,EAA+B3X,OAA/B;AADoB,WAAjC;AAGH;;AAED+C,QAAAA,QAAQ,CAACisB,KAAT,CAAe/T,IAAf;AACA,cAAMiuB,aAAa,GAAGnmC,QAAQ,CAACisB,KAA/B;AACA,cAAMma,SAAS,GAAGH,IAAI,CAACG,SAAvB,CAT8D;;AAW9D,YAAI,KAAKC,uBAAL,CAA6BF,aAA7B,EAA4CC,SAA5C,CAAJ,EAA4D;AACxD,cAAIA,SAAJ,EAAe;AACXA,YAAAA,SAAS,CAACzpB,OAAV,CAAmB2pB,QAAD;AACd,oBAAMC,GAAG,GAAG,KAAKC,eAAL,CAAqBF,QAArB,CAAZ;;AAEA,kBAAIC,GAAG,IAAIA,GAAG,CAACp4B,GAAD,CAAd,EAAqB;AACjB,oBAAIxP,MAAM,CAACC,IAAP,CAAY2nC,GAAZ,EAAiBpmC,MAAjB,GAA0B,CAA9B,EAAiC;AAC7B,yBAAOomC,GAAG,CAACp4B,GAAD,CAAV;AACH,iBAFD,MAEO;AACH,yBAAO,KAAKq4B,eAAL,CAAqBF,QAArB,CAAP;AACH;AACJ;AACJ,aAVD;AAWH;;AAEDL,UAAAA,IAAI,CAACG,SAAL,GAAiBD,aAAjB;AACH;;AAEDA,QAAAA,aAAa,CAACxpB,OAAd,CAAuB4O,YAAD;AAClB,cAAIgb,GAAG,GAAG,KAAKC,eAAL,CAAqBjb,YAArB,CAAV;;AAEA,cAAI,CAACgb,GAAL,EAAU;AACNA,YAAAA,GAAG,GAAG,KAAKC,eAAL,CAAqBjb,YAArB,IAAqC,EAA3C;AACH;;;AAGDgb,UAAAA,GAAG,CAACp4B,GAAD,CAAH,GAAW83B,IAAX;;AAEA,eAAKQ,gBAAL,CAAsBlb,YAAtB;AACH,SAXD;AAYH,OAzCD,MAyCO,IAAI0a,IAAJ,EAAU;AACb,cAAMG,SAAS,GAAGH,IAAI,CAACG,SAAvB;;AAEA,YAAIA,SAAJ,EAAe;AACXA,UAAAA,SAAS,CAACzpB,OAAV,CAAmB2pB,QAAD;AACd,kBAAMC,GAAG,GAAG,KAAKC,eAAL,CAAqBF,QAArB,CAAZ;;AAEA,gBAAIC,GAAG,IAAIA,GAAG,CAACp4B,GAAD,CAAd,EAAqB;AACjB,kBAAIxP,MAAM,CAACC,IAAP,CAAY2nC,GAAZ,EAAiBpmC,MAAjB,GAA0B,CAA9B,EAAiC;AAC7B,uBAAOomC,GAAG,CAACp4B,GAAD,CAAV;AACH,eAFD,MAEO;AACH,uBAAO,KAAKq4B,eAAL,CAAqBF,QAArB,CAAP;AACH;AACJ;AACJ,WAVD;AAWH;;AAED,eAAO,KAAKJ,aAAL,CAAmB/3B,GAAnB,CAAP;AACH;AACJ,KAjED;;AAtOI,SAAKe,QAAL,GAAgBlS,OAAhB;AACA,SAAK4X,IAAL,GAAY5X,OAAO,CAACqL,SAApB;AAEArL,IAAAA,OAAO,CAAC0f,SAAR,CAAkB;AACd,WAAKxN,QAAL,CAAcwL,cAAd,CAA6B0J,SAA7B,CAAuC,KAAKnO,QAA5C;AACH,KAFD;AAGH;;AAED7Y,EAAAA,OAAO;AACH,SAAK8R,QAAL,CAAcwL,cAAd,CAA6B+J,WAA7B,CAAyC,KAAKxO,QAA9C;;AAEA,SAAK,MAAMvX,GAAX,IAAkBC,MAAM,CAACC,IAAP,CAAY,KAAK8nC,QAAjB,CAAlB,EAA8C;AAC1C,WAAKC,cAAL,CAAoBjoC,GAApB;AACH;;AAED,SAAKwnC,aAAL,GAAqB,EAArB;AACA,SAAKM,eAAL,GAAuB,EAAvB;AACH;;AAoBOG,EAAAA,cAAc,CAACjoC,GAAD,EAAckoC,aAAd;AAClB,UAAMxyB,CAAC,GAAG,KAAKsyB,QAAL,CAAchoC,GAAd,CAAV;;AAEA,QAAI0V,CAAJ,EAAO;AACH,YAAM9L,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,UAAIR,CAAC,CAACoa,KAAN,EAAa;AACTlmB,QAAAA,GAAG,CAACa,YAAJ,CAAiBiL,CAAC,CAACoa,KAAnB;AACH;;AAED,UAAIpa,CAAC,CAACyyB,cAAN,EAAsB;AAClBv+B,QAAAA,GAAG,CAACa,YAAJ,CAAiBiL,CAAC,CAACyyB,cAAnB;AACH;;AAED,UAAI,CAACD,aAAD,IAAkBxyB,CAAC,CAACoU,MAAxB,EAAgC;AAC5BpU,QAAAA,CAAC,CAACoU,MAAF;AACH,OAFD,MAEO,IAAIoe,aAAa,IAAIxyB,CAAC,CAACsL,OAAvB,EAAgC;AACnCtL,QAAAA,CAAC,CAACsL,OAAF,CAAU,IAAV;AACH;;AAED,aAAO,KAAKgnB,QAAL,CAAchoC,GAAd,CAAP;AACH;AACJ;;AAEO2nC,EAAAA,uBAAuB,CAAC3tB,GAAD,EAAgBD,IAAhB;AAC3B,QAAI,CAACA,IAAD,IAASC,GAAG,CAACvY,MAAJ,KAAesY,IAAI,CAACtY,MAAjC,EAAyC;AACrC,aAAO,IAAP;AACH;;AACD,SAAK,IAAIyN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8K,GAAG,CAACvY,MAAxB,EAAgC,EAAEyN,CAAlC,EAAqC;AACjC,UAAI8K,GAAG,CAAC9K,CAAD,CAAH,KAAW6K,IAAI,CAAC7K,CAAD,CAAnB,EAAwB;AACpB,eAAO,IAAP;AACH;AACJ;;AACD,WAAO,KAAP;AACH;AAED;;;;;;;;;AAOAyB,EAAAA,UAAU,CACNkc,YADM,EAENe,aAFM;AAIN,UAAMwa,CAAC,GAAG,KAAKN,eAAL,CAAqBjb,YAArB,CAAV;;AAEA,QAAIub,CAAJ,EAAO;AACH,WAAK,MAAM34B,GAAX,IAAkBxP,MAAM,CAACC,IAAP,CAAYkoC,CAAZ,CAAlB,EAAkC;AAC9B,YAAI/5B,EAAE,GAAG+5B,CAAC,CAAC34B,GAAD,CAAD,CAAOlR,OAAP,CAAeqN,GAAf,MAAwB,IAAjC;;AACA,YAAIyC,EAAJ,EAAQ;AACJ,cACKuf,aAAa,KACV7uB,6BAAA,CAAoCrD,UADvC,IAEG,CAAC,KAAK8U,QAAL,CAAcvP,SAAd,CAAwBwwB,YAAxB,CAAqCpjB,EAArC,CAFL,IAGCuf,aAAa,KACV7uB,6BAAA,CAAoCpD,SADvC,IAEG,CAAC,KAAK6U,QAAL,CAAcvP,SAAd,CAAwB0T,WAAxB,CAAoCtG,EAApC,EAAwC,IAAxC,CANT,EAOE;AACEA,YAAAA,EAAE,GAAG,IAAL;AACH;AACJ,SAXD,MAWO;AACH,iBAAO+5B,CAAC,CAAC34B,GAAD,CAAR;AACA,iBAAO,KAAK+3B,aAAL,CAAmB/3B,GAAnB,CAAP;AACH;;AAED,eAAOpB,EAAP;AACH;AACJ;;AAED,WAAO,IAAP;AACH;AAED;;;;;;;;;;AAQA8f,EAAAA,WAAW,CACPtB,YADO,EAEPxD,OAFO,EAGPuE,aAHO;AAKP,UAAMvf,EAAE,GAAG,KAAKsC,UAAL,CAAgBkc,YAAhB,EAA8Be,aAA9B,CAAX;;AAEA,QAAIvf,EAAJ,EAAQ;AACJ,aAAO;AACH0T,QAAAA,MAAM,EAAE3R,UAAU,CAAC,KAAK8F,IAAN,CAAV,CAAsB8K,OAAtB,CAA8B3S,EAA9B,CADL;AAEHi5B,QAAAA,MAAM,EAAE;AACJ;AACH;AAJE,OAAP;AAMH;;AAED,QAAIe,MAAJ;;AAEA,QAAIza,aAAa,KAAK7uB,6BAAA,CAAoCrD,UAA1D,EAAsE;AAClE2sC,MAAAA,MAAM,GAAG,GAAT;AACH,KAFD,MAEO,IACHza,aAAa,KAAK7uB,6BAAA,CAAoCpD,SADnD,EAEL;AACE0sC,MAAAA,MAAM,GAAG,GAAT;AACH,KAJM,MAIA;AACHA,MAAAA,MAAM,GAAG,GAAT;AACH;;AAED,UAAMroC,GAAG,GAAGqoC,MAAM,GAAGxb,YAArB;AACA,QAAInX,CAAC,GAAG,KAAKsyB,QAAL,CAAchoC,GAAd,CAAR;;AAEA,QAAI0V,CAAC,IAAIA,CAAC,CAAC4yB,OAAX,EAAoB;AAChB,aAAO5yB,CAAC,CAAC4yB,OAAT;AACH;;AAED5yB,IAAAA,CAAC,GAAG,KAAKsyB,QAAL,CAAchoC,GAAd,IAAqB;AACrB8vB,MAAAA,KAAK,EAAE,KAAK5Z,IAAL,GAAYjK,UAAZ,CAAuB;AAC1B,YAAIyJ,CAAC,CAACyyB,cAAN,EAAsB;AAClB,eAAKjyB,IAAL,GAAYzL,YAAZ,CAAyBiL,CAAC,CAACyyB,cAA3B;AACH;;AAED,eAAO,KAAKH,QAAL,CAAchoC,GAAd,CAAP;;AAEA,YAAI0V,CAAC,CAACsL,OAAN,EAAe;AACXtL,UAAAA,CAAC,CAACsL,OAAF,CAAU,IAAV;AACH;AACJ,OAVM,EAUJqI,OAVI;AADc,KAAzB;AAcA,UAAMkf,OAAO,GAAG,KAAKn4B,UAAU,CAAC,KAAK8F,IAAN,CAAf,EACZ,CAAC8K,OAAD,EAAU8I,MAAV;AACIpU,MAAAA,CAAC,CAACsL,OAAF,GAAYA,OAAZ;AACAtL,MAAAA,CAAC,CAACoU,MAAF,GAAWA,MAAX;AACH,KAJW,CAAhB;AAOApU,IAAAA,CAAC,CAAC4yB,OAAF,GAAY;AACRvmB,MAAAA,MAAM,EAAEwmB,OADA;AAERjB,MAAAA,MAAM,EAAE;AACJ,aAAKW,cAAL,CAAoBjoC,GAApB,EAAyB,IAAzB;AACH;AAJO,KAAZ;;AAOA,QAAI4tB,aAAa,IAAI,KAAKjd,UAAL,CAAgBkc,YAAhB,CAArB,EAAoD;AAChD;AACA;AACA,WAAKkb,gBAAL,CAAsBlb,YAAtB;AACH;;AAED,WAAOnX,CAAC,CAAC4yB,OAAT;AACH;;AAED1X,EAAAA,YAAY,CACR/D,YADQ,EAERxD,OAFQ;AAIR,UAAMwH,SAAS,GAAG,EAAE,KAAKC,mBAAzB;AACA,UAAM0X,mBAAmB,GAAG,KAAKtB,eAAjC;;AAEA,QAAIsB,mBAAJ,EAAyB;AACrBA,MAAAA,mBAAmB,CAAClB,MAApB;AACH;;AAED,UAAMgB,OAAO,GAAG,KAAKna,WAAL,CACZtB,YADY,EAEZxD,OAFY,EAGZtqB,6BAAA,CAAoCpD,SAHxB,CAAhB;AAMA,SAAKurC,eAAL,GAAuBoB,OAAvB;AACA,SAAKlB,wBAAL,GAAgC93B,IAAI,CAACC,GAAL,EAAhC;AAEA+4B,IAAAA,OAAO,CAACvmB,MAAR,CAAemO,OAAf,CAAuB;AACnB,UAAI,KAAKgX,eAAL,KAAyBoB,OAA7B,EAAsC;AAClC,eAAO,KAAKpB,eAAZ;AACH;AACJ,KAJD;AAMA,WAAO;AACHnlB,MAAAA,MAAM,EAAEumB,OAAO,CAACvmB,MAAR,CAAegH,IAAf,CAAqBxqB,OAAD,IACxB,KAAKuyB,mBAAL,KAA6BD,SAA7B,IAA0CtyB,OAA1C,GACM,KAAKiS,QAAL,CAAcwL,cAAd,CAA6B8E,KAA7B,CAAmCviB,OAAnC,EAA4C,IAA5C,CADN,GAEM,KAHF,CADL;AAMH+oC,MAAAA,MAAM,EAAE;AACJgB,QAAAA,OAAO,CAAChB,MAAR;AACH;AARE,KAAP;AAUH;;AAqEOS,EAAAA,gBAAgB,CAAClb,YAAD;AACpB,UAAM4b,iBAAiB,GAAG,MAAM5b,YAAhC;AACA,UAAM6b,2BAA2B,GAAG,MAAM7b,YAA1C;AACA,UAAM8b,0BAA0B,GAAG,MAAM9b,YAAzC;AACA,UAAM+b,cAAc,GAAG,KAAKZ,QAAL,CAAcS,iBAAd,CAAvB;AACA,UAAMI,wBAAwB,GAC1B,KAAKb,QAAL,CAAcU,2BAAd,CADJ;AAEA,UAAMI,uBAAuB,GACzB,KAAKd,QAAL,CAAcW,0BAAd,CADJ;;AAEA,UAAM/+B,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,UAAM8K,OAAO,GAAG,CACZziB,OADY,EAEZyB,GAFY,EAGZ+oC,OAHY,EAIZnb,aAJY;;;AAMZ,YAAMtsB,QAAQ,GAAG,MAAAjD,mBAAmB,CAChC,KAAKmS,QAD2B,EAEhCjS,OAFgC,CAAnB,UAAA,iBAAA,SAAA,MAGd+C,QAHH;;AAKA,UAAI,CAACA,QAAD,IAAa,CAACA,QAAQ,CAACisB,KAAT,CAAeyb,QAAf,CAAwBnc,YAAxB,CAAlB,EAAyD;AACrD;AACH;;AAED,UAAIkc,OAAO,CAACjZ,KAAZ,EAAmB;AACflmB,QAAAA,GAAG,CAACa,YAAJ,CAAiBs+B,OAAO,CAACjZ,KAAzB;AACH;;AAED,aAAO,KAAKkY,QAAL,CAAchoC,GAAd,CAAP;;AAEA,UAAI+oC,OAAO,CAAC/nB,OAAZ,EAAqB;AACjB+nB,QAAAA,OAAO,CAAC/nB,OAAR,CAAgBziB,OAAhB;AACH;;AAED,WAAKspB,OAAL,CAAatpB,OAAb,EAAsB;AAClBgvB,QAAAA,KAAK,EAAE,CAACV,YAAD,CADW;AAElB1pB,QAAAA,OAAO,EAAE7B,QAAQ,CAAC6B,OAFA;AAGlByqB,QAAAA;AAHkB,OAAtB;AAKH,KA9BD;;AAgCA,QAAIgb,cAAJ,EAAoB;AAChB,YAAMrqC,OAAO,GAAG,KAAKoS,UAAL,CAAgBkc,YAAhB,CAAhB;;AAEA,UAAItuB,OAAO,IAAI8M,gBAAgB,CAAC9M,OAAO,CAACiJ,aAAT,EAAwBjJ,OAAxB,CAA/B,EAAiE;AAC7DyiB,QAAAA,OAAO,CACHziB,OADG,EAEHkqC,iBAFG,EAGHG,cAHG,EAIH7pC,6BAAA,CAAoCtD,GAJjC,CAAP;AAMH;AACJ;;AAED,QACIotC,wBAAwB,IACxB,CAACA,wBAAwB,CAACV,cAF9B,EAGE;AACE,YAAMc,iBAAiB,GAAG;AACtB,cAAM1qC,OAAO,GAAG,KAAKoS,UAAL,CAAgBkc,YAAhB,CAAhB;;AAEA,YACItuB,OAAO,IACP8M,gBAAgB,CAAC9M,OAAO,CAACiJ,aAAT,EAAwBjJ,OAAxB,CADhB,IAEA,KAAKiS,QAAL,CAAcvP,SAAd,CAAwBwwB,YAAxB,CAAqClzB,OAArC,CAHJ,EAIE;AACEyiB,UAAAA,OAAO,CACHziB,OADG,EAEHmqC,2BAFG,EAGHG,wBAHG,EAIH9pC,6BAAA,CAAoCrD,UAJjC,CAAP;AAMH,SAXD,MAWO;AACHmtC,UAAAA,wBAAwB,CAACV,cAAzB,GAA0Cv+B,GAAG,CAACqC,UAAJ,CACtCg9B,iBADsC,EAEtCjC,sBAFsC,CAA1C;AAIH;AACJ,OApBD;;AAsBAiC,MAAAA,iBAAiB;AACpB;;AAED,QACIH,uBAAuB,IACvB,CAACA,uBAAuB,CAACX,cAF7B,EAGE;AACE,YAAMe,gBAAgB,GAAG;AACrB,cAAM3qC,OAAO,GAAG,KAAKoS,UAAL,CAAgBkc,YAAhB,CAAhB;;AAEA,YACItuB,OAAO,IACP8M,gBAAgB,CAAC9M,OAAO,CAACiJ,aAAT,EAAwBjJ,OAAxB,CADhB,IAEA,KAAKiS,QAAL,CAAcvP,SAAd,CAAwB0T,WAAxB,CAAoCpW,OAApC,EAA6C,IAA7C,CAHJ,EAIE;AACEyiB,UAAAA,OAAO,CACHziB,OADG,EAEHoqC,0BAFG,EAGHG,uBAHG,EAIH/pC,6BAAA,CAAoCpD,SAJjC,CAAP;AAMH,SAXD,MAWO;AACHmtC,UAAAA,uBAAuB,CAACX,cAAxB,GAAyCv+B,GAAG,CAACqC,UAAJ,CACrCi9B,gBADqC,EAErClC,sBAFqC,CAAzC;AAIH;AACJ,OApBD;;AAsBAkC,MAAAA,gBAAgB;AACnB;AACJ;;;;AC3cL;;;;AAgBA,MAAMC,YAAY,GAAuB;AACrCC,EAAAA,SAAS,EAAE,4BAD0B;AAErCC,EAAAA,YAAY,EAAE,uBAFuB;AAGrCC,EAAAA,YAAY,EAAE,SAHuB;AAIrCC,EAAAA,YAAY,EAAE,CAJuB;AAKrCz3B,EAAAA,MAAM,EAAE;AAL6B,CAAzC;AAQA,IAAIpB,MAAM,GAAuBy4B,YAAjC;;AAEA,MAAMK,eAAN;AAMI3mC,EAAAA,YAAYoG,MAAcC,KAAaC,OAAeC;AAClD,SAAKH,IAAL,GAAYA,IAAZ;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,MAAL,GAAcA,MAAd;AACH;;AAEMqgC,EAAAA,QAAQ,CAACC,KAAD;AACX,WACI,KAAKzgC,IAAL,KAAcygC,KAAK,CAACzgC,IAApB,IACA,KAAKC,GAAL,KAAawgC,KAAK,CAACxgC,GADnB,IAEA,KAAKC,KAAL,KAAeugC,KAAK,CAACvgC,KAFrB,IAGA,KAAKC,MAAL,KAAgBsgC,KAAK,CAACtgC,MAJ1B;AAMH;;AAEMugC,EAAAA,KAAK;AACR,WAAO,IAAIH,eAAJ,CACH,KAAKvgC,IADF,EAEH,KAAKC,GAFF,EAGH,KAAKC,KAHF,EAIH,KAAKC,MAJF,CAAP;AAMH;;;;MAGQwgC;AAaT/mC,EAAAA,YAAYvE;AAPJ,mBAAA,GAAa,KAAb;AAEA,4BAAA,GAA+C,EAA/C;;AA4BA,cAAA,GAAQ;AACZ,WAAKkS,QAAL,CAAcsL,kBAAd,CAAiC4J,SAAjC,CACI,KAAKsL,iCADT;;AAGA,WAAKxgB,QAAL,CAAcwL,cAAd,CAA6B0J,SAA7B,CAAuC,KAAKnO,QAA5C;;AAEA,YAAM3N,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEAtM,MAAAA,GAAG,CAACuI,gBAAJ,CAAqB,QAArB,EAA+B,KAAK03B,SAApC,EAA+C,IAA/C;;AAEA,UAAI,KAAKC,oBAAT,EAA+B;AAC3BlgC,QAAAA,GAAG,CAACN,QAAJ,CAAa6I,gBAAb,CACI,KAAK23B,oBADT,EAEI,KAAKC,oBAFT;AAIH;AACJ,KAhBO;;AAuEA,6BAAA,GAAwBtqC,CAAD;AAC3B,UAAI,CAAC,KAAKuqC,sBAAN,IAAgC,CAACvqC,CAAC,CAACsL,MAAvC,EAA+C;AAC3C;AACH;;AAED,YAAMA,MAAM,GAAItL,CAAC,CAACsL,MAAF,CAAsBgF,IAAtB,IAA+BtQ,CAAC,CAACsL,MAAjD;;AACA,YAAMk/B,eAAe,GAAG,KAAKC,OAAL,CAAan/B,MAAb,CAAxB;;AAEA,UAAIA,MAAM,CAACvD,aAAP,IAAwByiC,eAA5B,EAA6C;AACzC;AACA,cAAME,SAAS,GAAwBp/B,MAAM,CAACvD,aAAP,CACnC,KAAKwiC,sBAD8B,CAAvC;;AAIA,YAAIG,SAAJ,EAAe;AACXA,UAAAA,SAAS,CAACjjC,WAAV,CAAsB+iC,eAAe,CAACv8B,SAAtC;AACA,eAAK08B,kBAAL,GAA0BD,SAA1B;AACH,SAHD,MAGO;AACHp/B,UAAAA,MAAM,CAACvD,aAAP,CAAqBuI,IAArB,CAA0B7I,WAA1B,CACI+iC,eAAe,CAACv8B,SADpB;AAGA,eAAK08B,kBAAL,GAA0BvrC,SAA1B;AACH;AACJ;AACJ,KAxBO;;AA0BA,0CAAA,GAAoC;AACxC,WAAK0Y,QAAL,CAAc,KAAK/G,QAAL,CAAcwL,cAAd,CAA6BkK,iBAA7B,EAAd;AACH,KAFO;;AAwBA,iBAAA,GAAYzmB,CAAD;AACf,UAAI,CAAC,KAAK4qC,cAAL,CAAoB5qC,CAApB,CAAD,IAA2B,KAAK6qC,UAApC,EAAgD;AAC5C,aAAKC,cAAL,CAAoB,KAApB;AACH;AACJ,KAJO;;AA+DA,kBAAA,GAAa9qC,CAAD;AAChB,UACI,CAAC,KAAK+qC,gBAAN,IACA,CAACZ,UAAU,CAACa,cAAX,CACGhrC,CAAC,CAACsL,MADL,EAEG,KAAKy/B,gBAFR,CAFL,EAME;AACE;AACH;;AAED,WAAKE,OAAL,GAAe7rC,SAAf;;AAEA,WAAK8rC,mBAAL;AACH,KAdO;;AA9MJ,SAAKn6B,QAAL,GAAgBlS,OAAhB;AACA,SAAK4X,IAAL,GAAY5X,OAAO,CAACqL,SAApB;AAEArL,IAAAA,OAAO,CAAC0f,SAAR,CAAkB,KAAKqT,KAAvB;;AAEA,QAAI,OAAO/nB,QAAP,KAAoB,WAAxB,EAAqC;AACjC,UAAI,wBAAwBA,QAA5B,EAAsC;AAClC,aAAKwgC,oBAAL,GAA4B,kBAA5B;AACA,aAAKE,sBAAL,GAA8B,mBAA9B;AACH,OAHD,MAGO,IAAI,8BAA8B1gC,QAAlC,EAA4C;AAC/C,aAAKwgC,oBAAL,GAA4B,wBAA5B;AACA,aAAKE,sBAAL,GAA8B,yBAA9B;AACH,OAHM,MAGA,IAAI,2BAA2B1gC,QAA/B,EAAyC;AAC5C,aAAKwgC,oBAAL,GAA4B,qBAA5B;AACA,aAAKE,sBAAL,GAA8B,sBAA9B;AACH,OAHM,MAGA,IAAI,0BAA0B1gC,QAA9B,EAAwC;AAC3C,aAAKwgC,oBAAL,GAA4B,oBAA5B;AACA,aAAKE,sBAAL,GAA8B,qBAA9B;AACH;AACJ;AACJ;;AAoBD3a,EAAAA,KAAK,CAAC9e,KAAD;AACDG,IAAAA,MAAM,GAAG,EAAE,GAAGA,MAAL;AAAa,SAAGH;AAAhB,KAAT;;AAEA,UAAM3G,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,QAAI,CAACtM,GAAG,CAACghC,gBAAT,EAA2B;AACvBhhC,MAAAA,GAAG,CAACghC,gBAAJ,GAAuB,EAAvB;AACH;;AAED,QAAI,CAAChhC,GAAG,CAACghC,gBAAJ,CAAqBj5B,KAA1B,EAAiC;AAC7B/H,MAAAA,GAAG,CAACghC,gBAAJ,CAAqBj5B,KAArB,GAA6Bk5B,YAAY,CAACjhC,GAAG,CAACN,QAAL,EAAeoH,MAAf,CAAzC;AACH;;AAED,QAAI,CAACH,KAAD,IAAU,CAACA,KAAK,CAAC64B,SAArB,EAAgC;AAC5Bx/B,MAAAA,GAAG,CAACN,QAAJ,CAAayG,IAAb,CAAkB+6B,SAAlB,CAA4B90B,GAA5B,CAAgCmzB,YAAY,CAACC,SAA7C;AACH,KAFD,MAEO;AACHx/B,MAAAA,GAAG,CAACN,QAAJ,CAAayG,IAAb,CAAkB+6B,SAAlB,CAA4Br0B,MAA5B,CAAmC0yB,YAAY,CAACC,SAAhD;AACH;AACJ;;AAED1qC,EAAAA,OAAO;AACH,UAAMkL,GAAG,GAAG,KAAKsM,IAAL,EAAZ;;AAEA,QAAI,KAAKS,YAAT,EAAuB;AACnB/M,MAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAKkM,YAAtB;AACA,WAAKA,YAAL,GAAoB9X,SAApB;AACH;;AAED,SAAK2R,QAAL,CAAcsL,kBAAd,CAAiCiK,WAAjC,CACI,KAAKiL,iCADT;;AAGA,SAAKxgB,QAAL,CAAcwL,cAAd,CAA6B+J,WAA7B,CAAyC,KAAKxO,QAA9C;;AAEA3N,IAAAA,GAAG,CAAC6I,mBAAJ,CAAwB,QAAxB,EAAkC,KAAKo3B,SAAvC,EAAkD,IAAlD;;AAEA,QAAI,KAAKC,oBAAT,EAA+B;AAC3BlgC,MAAAA,GAAG,CAACN,QAAJ,CAAamJ,mBAAb,CACI,KAAKq3B,oBADT,EAEI,KAAKC,oBAFT;AAIH;;AAED,SAAKgB,mBAAL,CAAyB9sB,OAAzB,CAAkCgsB,eAAD,IAC7B,KAAKe,UAAL,CAAgBf,eAAe,CAACv8B,SAAhC,CADJ;;AAGA,SAAKq9B,mBAAL,GAA2B,EAA3B;AAEA,WAAO,KAAKP,gBAAZ;AACA,WAAO,KAAKE,OAAZ;AACA,WAAO,KAAKO,mBAAZ;AACA,WAAO,KAAKb,kBAAZ;AACH;;AAgCOc,EAAAA,wBAAwB,CAAC3sC,OAAD;AAC5B,UAAMsB,gBAAgB,GAAGxB,mBAAmB,CAAC,KAAKmS,QAAN,EAAgBjS,OAAhB,CAA5C;;AAEA,QACIsB,gBAAgB,IAChBA,gBAAgB,CAAC2B,OADjB,IAEA3B,gBAAgB,CAAC2B,OAAjB,CAAyB2pC,SAH7B,EAIE;AACE,aAAO,KAAP;AACH;;AAED,SAAK,IAAIj8B,CAAC,GAAuB3Q,OAAjC,EAA0C2Q,CAA1C,EAA6CA,CAAC,GAAGA,CAAC,CAACpK,aAAnD,EAAkE;AAC9D,UAAIoK,CAAC,CAAC47B,SAAF,IAAe57B,CAAC,CAAC47B,SAAF,CAAY5lC,QAAZ,CAAqBwL,MAAM,CAAC04B,SAA5B,CAAnB,EAA2D;AACvD,eAAO,IAAP;AACH;AACJ;;AAED,WAAO,KAAP;AACH;;AAQOiB,EAAAA,cAAc,CAAC5qC,CAAD;AAClB,SAAK+qC,gBAAL,GAAwB3rC,SAAxB;;AAEA,QAAI,KAAK8X,YAAT,EAAuB;AACnB,WAAKT,IAAL,GAAYzL,YAAZ,CAAyB,KAAKkM,YAA9B;;AACA,WAAKA,YAAL,GAAoB9X,SAApB;AACH;;AAED,SAAK6rC,OAAL,GAAe7rC,SAAf;;AAEA,QAAI,CAAC,KAAK2R,QAAL,CAAcsL,kBAAd,CAAiCoJ,wBAAjC,EAAL,EAAkE;AAC9D,aAAO,KAAP;AACH;;AAED,QAAIzlB,CAAJ,EAAO;AACH;AACA;AACA;AACA,UAAIA,CAAC,CAACiV,OAAF,KAAc,OAAlB,EAA2B;AACvB,cAAM02B,SAAS,GAAI3rC,CAAsB,CAACqD,IAA1C;AACA,cAAMuoC,kBAAkB,GAAG;AACvBC,UAAAA,MAAM,EAAE,IADe;AAEvBC,UAAAA,QAAQ,EAAE,IAFa;AAGvBC,UAAAA,IAAI,EAAE,IAHiB;AAIvBC,UAAAA,KAAK,EAAE,IAJgB;AAKvBC,UAAAA,KAAK,EAAE,IALgB;AAMvBC,UAAAA,KAAK,EAAE,IANgB;AAOvB/iB,UAAAA,KAAK,EAAE,IAPgB;AAQvBgjB,UAAAA,MAAM,EAAE;AARe,SAA3B;;AAWA,YAAI,EAAER,SAAS,IAAIC,kBAAf,CAAJ,EAAwC;AACpC,iBAAO,KAAP;AACH;AACJ,OAhBD,MAgBO,IACH5rC,CAAC,CAACiV,OAAF,KAAc,UAAd,IACAjV,CAAC,CAAC61B,eAAF,KAAsB,MADtB,IAEA71B,CAAC,CAACiV,OAAF,KAAc,QAHX,EAIL;AACE,eAAO,KAAP;AACH;;AAED,UAAI,CAAC,KAAKw2B,wBAAL,CAA8BzrC,CAA9B,CAAL,EAAuC;AACnC,eAAO,KAAP;AACH;;AAED,UAAI,KAAK+Q,QAAL,CAAcsL,kBAAd,CAAiCoJ,wBAAjC,EAAJ,EAAiE;AAC7D,aAAKslB,gBAAL,GAAwB/qC,CAAxB;;AACA,aAAKosC,cAAL;AACH;;AAED,aAAO,IAAP;AACH;;AAED,WAAO,KAAP;AACH;;AAkBOA,EAAAA,cAAc;AAClB,SAAKlB,mBAAL;;AAEA,QAAI,KAAKh0B,YAAT,EAAuB;AACnB,WAAKT,IAAL,GAAYzL,YAAZ,CAAyB,KAAKkM,YAA9B;;AACA,WAAKA,YAAL,GAAoB9X,SAApB;AACH;;AAED,QAAI,CAAC,KAAK2rC,gBAAV,EAA4B;AACxB;AACH;;AAED,SAAK7zB,YAAL,GAAoB,KAAKT,IAAL,GAAYjK,UAAZ,CAAuB;AACvC,WAAK0K,YAAL,GAAoB9X,SAApB;;AACA,WAAKgtC,cAAL;AACH,KAHmB,EAGjB,EAHiB,CAApB;AAIH;;AAEOtB,EAAAA,cAAc,CAACuB,OAAD;AAClB,SAAKxB,UAAL,GAAkBwB,OAAlB;;AAEA,QAAI,KAAKb,mBAAT,EAA8B;AAC1B,UAAIa,OAAJ,EAAa;AACT,aAAKb,mBAAL,CAAyBv9B,SAAzB,CAAmCo9B,SAAnC,CAA6C90B,GAA7C,IACOtF,MAAM,CAAC24B,sBADd;AAGH,OAJD,MAIO;AACH,aAAK4B,mBAAL,CAAyBv9B,SAAzB,CAAmCo9B,SAAnC,CAA6Cr0B,MAA7C,IACO/F,MAAM,CAAC24B,sBADd;;AAGA,aAAKqB,OAAL,GAAe7rC,SAAf;AACH;AACJ;AACJ;;AAEO8rC,EAAAA,mBAAmB;AACvB,QAAI,CAAC,KAAKH,gBAAV,EAA4B;AACxB;AACH;;AAED,QAAIuB,YAAY,GAAGv/B,eAAe,CAAC,KAAK0J,IAAN,EAAY,KAAKs0B,gBAAjB,CAAlC;AAEA,UAAM54B,QAAQ,GAAG,IAAI43B,eAAJ,CACbuC,YAAY,CAAC9iC,IADA,EAEb8iC,YAAY,CAAC7iC,GAFA,EAGb6iC,YAAY,CAAC5iC,KAHA,EAIb4iC,YAAY,CAAC3iC,MAJA,CAAjB;;AAOA,QAAI,KAAKshC,OAAL,IAAgB94B,QAAQ,CAAC63B,QAAT,CAAkB,KAAKiB,OAAvB,CAApB,EAAqD;AACjD;AACH;;AAED,UAAMT,eAAe,GAAG,KAAKC,OAAL,CAAa,KAAKM,gBAAlB,CAAxB;;AACA,UAAM5gC,GAAG,GACL,KAAK4gC,gBAAL,CAAsBhjC,aAAtB,IACA,KAAKgjC,gBAAL,CAAsBhjC,aAAtB,CAAoCqT,WAFxC;;AAIA,QAAI,CAACovB,eAAD,IAAoB,CAACrgC,GAAzB,EAA8B;AAC1B;AACH;;AAED,QAAI,KAAKqhC,mBAAL,KAA6BhB,eAAjC,EAAkD;AAC9C,WAAKM,cAAL,CAAoB,KAApB;;AACA,WAAKU,mBAAL,GAA2BhB,eAA3B;AACH;;AAED,SAAKS,OAAL,GAAe94B,QAAf;AAEA,UAAMo6B,CAAC,GAAGp6B,QAAQ,CAAC+3B,KAAT,EAAV;AACA,QAAIsC,2BAA2B,GAAG,KAAlC;AACA,QAAIC,wBAAwB,GAAG,KAA/B;AAEA,UAAMx+B,SAAS,GAAGu8B,eAAe,CAACv8B,SAAlC;AACA,UAAMb,gBAAgB,GAClBa,SAAS,IACTA,SAAS,CAAClG,aADV,IAECkG,SAAS,CAAClG,aAAV,CAAwBqF,gBAH7B;;AAKA,QAAI,CAACA,gBAAL,EAAuB;AACnB;AACH;;AAED,SACI,IAAI7H,MAAM,GAAG,KAAKwlC,gBAAL,CAAsB1lC,aADvC,EAEIE,MAAM,IAAIA,MAAM,CAACqH,QAAP,KAAoBC,IAAI,CAACC,YAFvC,EAGIvH,MAAM,GAAGA,MAAM,CAACF,aAHpB,EAIE;AACE;AACA;AAEA,UAAIE,MAAM,KAAK,KAAKolC,kBAApB,EAAwC;AACpC;AACH;;AAED2B,MAAAA,YAAY,GAAGv/B,eAAe,CAAC,KAAK0J,IAAN,EAAYlR,MAAZ,CAA9B;AAEA,YAAM4E,GAAG,GACL5E,MAAM,CAACwC,aAAP,IAAwBxC,MAAM,CAACwC,aAAP,CAAqBqT,WADjD;;AAGA,UAAI,CAACjR,GAAL,EAAU;AACN;AACH;;AAED,YAAMgR,aAAa,GAAGhR,GAAG,CAACmP,gBAAJ,CAAqB/T,MAArB,CAAtB;AACA,YAAM4M,QAAQ,GAAGgJ,aAAa,CAAChJ,QAA/B;;AAEA,UAAIA,QAAQ,KAAK,UAAjB,EAA6B;AACzBq6B,QAAAA,2BAA2B,GAAG,IAA9B;AACH,OAFD,MAEO,IAAIr6B,QAAQ,KAAK,OAAb,IAAwBA,QAAQ,KAAK,QAAzC,EAAmD;AACtDs6B,QAAAA,wBAAwB,GAAG,IAA3B;AACH;;AAED,UAAItxB,aAAa,CAACuxB,QAAd,KAA2B,SAA/B,EAA0C;AACtC;AACH;;AAED,UACK,CAACF,2BAAD,IAAgC,CAACC,wBAAlC,IACAtxB,aAAa,CAACuxB,QAAd,KAA2B,QAF/B,EAGE;AACE,YAAIJ,YAAY,CAAC9iC,IAAb,GAAoB+iC,CAAC,CAAC/iC,IAA1B,EAAgC;AAC5B+iC,UAAAA,CAAC,CAAC/iC,IAAF,GAAS8iC,YAAY,CAAC9iC,IAAtB;AACH;;AACD,YAAI8iC,YAAY,CAAC7iC,GAAb,GAAmB8iC,CAAC,CAAC9iC,GAAzB,EAA8B;AAC1B8iC,UAAAA,CAAC,CAAC9iC,GAAF,GAAQ6iC,YAAY,CAAC7iC,GAArB;AACH;;AACD,YAAI6iC,YAAY,CAAC5iC,KAAb,GAAqB6iC,CAAC,CAAC7iC,KAA3B,EAAkC;AAC9B6iC,UAAAA,CAAC,CAAC7iC,KAAF,GAAU4iC,YAAY,CAAC5iC,KAAvB;AACH;;AACD,YAAI4iC,YAAY,CAAC3iC,MAAb,GAAsB4iC,CAAC,CAAC5iC,MAA5B,EAAoC;AAChC4iC,UAAAA,CAAC,CAAC5iC,MAAF,GAAW2iC,YAAY,CAAC3iC,MAAxB;AACH;AACJ;AACJ;;AAED,UAAMgjC,OAAO,GAAG5/B,eAAe,CAAC,KAAK0J,IAAN,EAAYrJ,gBAAZ,CAA/B;AACA,UAAMw/B,QAAQ,GAAGD,OAAO,CAACnjC,IAAR,GAAemjC,OAAO,CAACjjC,KAAxC;AACA,UAAMmjC,SAAS,GAAGF,OAAO,CAACljC,GAAR,GAAckjC,OAAO,CAAChjC,MAAxC;AACA,UAAMmjC,EAAE,GAAG77B,MAAM,CAAC64B,YAAlB;AAEAyC,IAAAA,CAAC,CAAC/iC,IAAF,GAAS+iC,CAAC,CAAC/iC,IAAF,GAASsjC,EAAT,GAAcP,CAAC,CAAC/iC,IAAF,GAASsjC,EAAvB,GAA4B,CAArC;AACAP,IAAAA,CAAC,CAAC9iC,GAAF,GAAQ8iC,CAAC,CAAC9iC,GAAF,GAAQqjC,EAAR,GAAaP,CAAC,CAAC9iC,GAAF,GAAQqjC,EAArB,GAA0B,CAAlC;AACAP,IAAAA,CAAC,CAAC7iC,KAAF,GAAU6iC,CAAC,CAAC7iC,KAAF,GAAUkjC,QAAQ,GAAGE,EAArB,GAA0BP,CAAC,CAAC7iC,KAAF,GAAUojC,EAApC,GAAyCF,QAAnD;AACAL,IAAAA,CAAC,CAAC5iC,MAAF,GAAW4iC,CAAC,CAAC5iC,MAAF,GAAWkjC,SAAS,GAAGC,EAAvB,GAA4BP,CAAC,CAAC5iC,MAAF,GAAWmjC,EAAvC,GAA4CD,SAAvD;AAEA,UAAMvjC,KAAK,GAAGijC,CAAC,CAAC7iC,KAAF,GAAU6iC,CAAC,CAAC/iC,IAA1B;AACA,UAAMD,MAAM,GAAGgjC,CAAC,CAAC5iC,MAAF,GAAW4iC,CAAC,CAAC9iC,GAA5B;;AAEA,QAAIH,KAAK,GAAGwjC,EAAE,GAAG,CAAb,IAAkBvjC,MAAM,GAAGujC,EAAE,GAAG,CAApC,EAAuC;AACnC,YAAMC,cAAc,GAAGvC,eAAe,CAAChhC,IAAvC;AACA,YAAMwjC,aAAa,GAAGxC,eAAe,CAAC/gC,GAAtC;AACA,YAAMwjC,eAAe,GAAGzC,eAAe,CAAC9gC,KAAxC;AACA,YAAMwjC,gBAAgB,GAAG1C,eAAe,CAAC7gC,MAAzC;AACA,YAAMwjC,EAAE,GACJ,KAAKxC,kBAAL,IAA2B8B,wBAA3B,GACM,CADN,GAEMtiC,GAAG,CAACijC,WAHd;AAIA,YAAMC,EAAE,GACJ,KAAK1C,kBAAL,IAA2B8B,wBAA3B,GACM,CADN,GAEMtiC,GAAG,CAACmjC,WAHd;AAKAr/B,MAAAA,SAAS,CAACiE,KAAV,CAAgBC,QAAhB,GAA2Bs6B,wBAAwB,GAC7C,OAD6C,GAE7C,UAFN;AAIAx+B,MAAAA,SAAS,CAACiE,KAAV,CAAgBq7B,UAAhB,GAA6Bt8B,MAAM,CAAC44B,YAApC;AAEAkD,MAAAA,cAAc,CAAC76B,KAAf,CAAqB5I,KAArB,GACI2jC,eAAe,CAAC/6B,KAAhB,CAAsB5I,KAAtB,GACA0jC,aAAa,CAAC96B,KAAd,CAAoB3I,MAApB,GACA2jC,gBAAgB,CAACh7B,KAAjB,CAAuB3I,MAAvB,GACI0H,MAAM,CAAC64B,YAAP,GAAsB,IAJ9B;AAMAiD,MAAAA,cAAc,CAAC76B,KAAf,CAAqB1I,IAArB,GACIwjC,aAAa,CAAC96B,KAAd,CAAoB1I,IAApB,GACA0jC,gBAAgB,CAACh7B,KAAjB,CAAuB1I,IAAvB,GACI+iC,CAAC,CAAC/iC,IAAF,GAAS2jC,EAAT,GAAc,IAHtB;AAIAF,MAAAA,eAAe,CAAC/6B,KAAhB,CAAsB1I,IAAtB,GAA6B+iC,CAAC,CAAC/iC,IAAF,GAAS2jC,EAAT,GAAc7jC,KAAd,GAAsBwjC,EAAtB,GAA2B,IAAxD;AAEAC,MAAAA,cAAc,CAAC76B,KAAf,CAAqBzI,GAArB,GACIwjC,eAAe,CAAC/6B,KAAhB,CAAsBzI,GAAtB,GACAujC,aAAa,CAAC96B,KAAd,CAAoBzI,GAApB,GACI8iC,CAAC,CAAC9iC,GAAF,GAAQ4jC,EAAR,GAAa,IAHrB;AAIAH,MAAAA,gBAAgB,CAACh7B,KAAjB,CAAuBzI,GAAvB,GAA6B8iC,CAAC,CAAC9iC,GAAF,GAAQ4jC,EAAR,GAAa9jC,MAAb,GAAsBujC,EAAtB,GAA2B,IAAxD;AAEAC,MAAAA,cAAc,CAAC76B,KAAf,CAAqB3I,MAArB,GAA8B0jC,eAAe,CAAC/6B,KAAhB,CAAsB3I,MAAtB,GAC1BA,MAAM,GAAG,IADb;AAGAyjC,MAAAA,aAAa,CAAC96B,KAAd,CAAoB5I,KAApB,GAA4B4jC,gBAAgB,CAACh7B,KAAjB,CAAuB5I,KAAvB,GACxBA,KAAK,GAAG,IADZ;;AAGA,WAAKwhC,cAAL,CAAoB,IAApB;AACH,KA7CD,MA6CO;AACH,WAAKA,cAAL,CAAoB,KAApB;AACH;AACJ;;AAEOL,EAAAA,OAAO,CACX+C,cADW;AAGX,UAAM3oC,GAAG,GAAG2oC,cAAc,CAACzlC,aAA3B;AACA,UAAMoC,GAAG,GAAItF,GAAG,IAAIA,GAAG,CAACuW,WAAxB;;AAEA,QAAI,CAACvW,GAAD,IAAQ,CAACsF,GAAT,IAAgB,CAACA,GAAG,CAACghC,gBAAzB,EAA2C;AACvC,aAAO/rC,SAAP;AACH;;AAED,QAAI,CAAC+K,GAAG,CAACghC,gBAAJ,CAAqBj5B,KAA1B,EAAiC;AAC7B/H,MAAAA,GAAG,CAACghC,gBAAJ,CAAqBj5B,KAArB,GAA6Bk5B,YAAY,CAACvmC,GAAD,EAAMoM,MAAN,CAAzC;AACH;;AAED,QAAI,CAAC9G,GAAG,CAACghC,gBAAJ,CAAqB/X,QAA1B,EAAoC;AAChC,YAAMoX,eAAe,GAA0B;AAC3Cv8B,QAAAA,SAAS,EAAEpJ,GAAG,CAACkN,aAAJ,CAAkB,KAAlB,CADgC;AAE3CvI,QAAAA,IAAI,EAAE3E,GAAG,CAACkN,aAAJ,CAAkB,KAAlB,CAFqC;AAG3CtI,QAAAA,GAAG,EAAE5E,GAAG,CAACkN,aAAJ,CAAkB,KAAlB,CAHsC;AAI3CrI,QAAAA,KAAK,EAAE7E,GAAG,CAACkN,aAAJ,CAAkB,KAAlB,CAJoC;AAK3CpI,QAAAA,MAAM,EAAE9E,GAAG,CAACkN,aAAJ,CAAkB,KAAlB;AALmC,OAA/C;AAQAy4B,MAAAA,eAAe,CAACv8B,SAAhB,CAA0BwV,SAA1B,GAAsCxS,MAAM,CAAC24B,YAA7C;AACAY,MAAAA,eAAe,CAAChhC,IAAhB,CAAqBia,SAArB,MAAoCxS,MAAM,CAAC24B,oBAA3C;AACAY,MAAAA,eAAe,CAAC/gC,GAAhB,CAAoBga,SAApB,MAAmCxS,MAAM,CAAC24B,mBAA1C;AACAY,MAAAA,eAAe,CAAC9gC,KAAhB,CAAsB+Z,SAAtB,MAAqCxS,MAAM,CAAC24B,qBAA5C;AACAY,MAAAA,eAAe,CAAC7gC,MAAhB,CAAuB8Z,SAAvB,MAAsCxS,MAAM,CAAC24B,sBAA7C;AAEAY,MAAAA,eAAe,CAACv8B,SAAhB,CAA0BxG,WAA1B,CAAsC+iC,eAAe,CAAChhC,IAAtD;AACAghC,MAAAA,eAAe,CAACv8B,SAAhB,CAA0BxG,WAA1B,CAAsC+iC,eAAe,CAAC/gC,GAAtD;AACA+gC,MAAAA,eAAe,CAACv8B,SAAhB,CAA0BxG,WAA1B,CAAsC+iC,eAAe,CAAC9gC,KAAtD;AACA8gC,MAAAA,eAAe,CAACv8B,SAAhB,CAA0BxG,WAA1B,CAAsC+iC,eAAe,CAAC7gC,MAAtD;AAEA9E,MAAAA,GAAG,CAACyL,IAAJ,CAAS7I,WAAT,CAAqB+iC,eAAe,CAACv8B,SAArC;AAEA9D,MAAAA,GAAG,CAACghC,gBAAJ,CAAqB/X,QAArB,GAAgCoX,eAAhC,CAtBgC;AAyBhC;;AACA,WAAKc,mBAAL,CAAyBt/B,IAAzB,CAA8Bw+B,eAA9B;AACH;;AAED,WAAOrgC,GAAG,CAACghC,gBAAJ,CAAqB/X,QAA5B;AACH;;AAEOmY,EAAAA,UAAU,CAACiC,cAAD;AACd,UAAMrjC,GAAG,GAAIqjC,cAAc,CAACzlC,aAAf,IACTylC,cAAc,CAACzlC,aAAf,CAA6BqT,WADjC;AAEA,UAAMrZ,OAAO,GAAGoI,GAAG,IAAIA,GAAG,CAACghC,gBAA3B;;AAEA,QAAI,CAACppC,OAAL,EAAc;AACV;AACH;;AAED,QAAIA,OAAO,CAACmQ,KAAR,IAAiBnQ,OAAO,CAACmQ,KAAR,CAAc/M,UAAnC,EAA+C;AAC3CpD,MAAAA,OAAO,CAACmQ,KAAR,CAAc/M,UAAd,CAAyB8N,WAAzB,CAAqClR,OAAO,CAACmQ,KAA7C;AAEA,aAAOnQ,OAAO,CAACmQ,KAAf;AACH;;AAED,UAAMs4B,eAAe,GAAGzoC,OAAO,IAAIA,OAAO,CAACqxB,QAA3C;;AAEA,QAAIoX,eAAJ,EAAqB;AACjB,UAAIA,eAAe,CAACv8B,SAAhB,CAA0B9I,UAA9B,EAA0C;AACtCqlC,QAAAA,eAAe,CAACv8B,SAAhB,CAA0B9I,UAA1B,CAAqC8N,WAArC,CACIu3B,eAAe,CAACv8B,SADpB;AAGH;;AAED,aAAOlM,OAAO,CAACqxB,QAAf;AACH;AACJ;;AAE4B,SAAd4X,cAAc,CACzBzlC,MADyB,EAEzBC,KAFyB;AAIzB,WACIA,KAAK,KAAKD,MAAV;AAEA,KAAC,EACGA,MAAM,CAAC+N,uBAAP,CAA+B9N,KAA/B,IACAqE,QAAQ,CAAC4jC,8BAFZ,CAHL;AAQH;;;;AAGL,SAASrC,YAAT,CACIvhC,QADJ,EAEIiH,KAFJ;AAII,QAAMoB,KAAK,GAAGrI,QAAQ,CAACkI,aAAT,CAAuB,OAAvB,CAAd;AACAG,EAAAA,KAAK,CAAC7O,IAAN,GAAa,UAAb;AACA6O,EAAAA,KAAK,CAACzK,WAAN,CAAkBoC,QAAQ,CAAC6jC,cAAT,CAAwBC,gBAAgB,CAAC78B,KAAD,CAAxC,CAAlB;AACAjH,EAAAA,QAAQ,CAAC+jC,IAAT,CAAcnmC,WAAd,CAA0ByK,KAA1B;AACA,SAAOA,KAAP;AACH;;AAED,SAASy7B,gBAAT,CAA0B78B,KAA1B;AACI;GACDA,KAAK,CAAC64B,iBAAiB74B,KAAK,CAAC64B;;;;GAI7B74B,KAAK,CAAC84B;;;;;;;WAOE94B,KAAK,CAACuB;;;GAGdvB,KAAK,CAAC84B,gBAAgB94B,KAAK,CAAC84B;;;;GAI5B94B,KAAK,CAAC84B;GACN94B,KAAK,CAAC84B;GACN94B,KAAK,CAAC84B;GACN94B,KAAK,CAAC84B;;;EAtBL;AA0BH;;AC5mBD;;;;;AAOA;;;;MAIaiE;AAMTzqC,EAAAA,YACIgyB;AAKA,SAAK0Y,yBAAL,GAAiC1Y,wBAAjC;AACH;;AAEDA,EAAAA,wBAAwB,CACpBt2B,OADoB,EAEpBu2B,UAFoB;;;AAIpB,UAAMD,wBAAwB,GAAG,MAAA,KAAK0Y,yBAAL,UAAA,iBAAA,SAAA,iBAC7BhvC,SACAu2B,WAFJ;AAKA;;AACA,WAAOD,wBAAwB,KAAKh2B,SAA7B,GACDi2B,UADC,GAEDD,wBAFN;AAGH;;;;ACvCL;;;;AAuBA,MAAM2Y,aAAa,GAAG,EAAtB;;AAEA,MAAMlyC,QAAN,SAAuBgV,WAAvB;AAGIzN,EAAAA,YACIvE,SACAC,SACAgS;;;AAEA,UAAMjS,OAAN,EAAeC,OAAf,EAAwBgS,KAAxB;AAPI,kBAAA,GAAY,KAAZ;;AAmCA,oBAAA,GAAe9Q,CAAD;;;AAClB,YAAMlB,OAAO,GAAG,MAAA,KAAKkS,QAAL,UAAA,iBAAA,SAAA,MAAe7E,KAA/B;;AACA,UAAIrN,OAAO,IAAIkB,CAAC,CAAC2R,aAAF,KAAoB,IAAnC,EAAyC;AACrC7S,QAAAA,OAAO,CAACuW,aAAR,CAAsB,IAAI/Q,yBAAJ,EAAtB;AACH;;AACD,UACIxF,OAAO,IACP,CAACmJ,GAAG,CAACI,YAAJ,CAAiBvJ,OAAjB,EAA0BkB,CAAC,CAAC2R,aAA5B,CAFL,EAGE;AACE,aAAKq8B,SAAL,GAAiB,KAAjB;AACH;AACJ,KAXO;;AAaA,mBAAA,GAAa;AACjB,WAAKA,SAAL,GAAiB,IAAjB;AACH,KAFO;;AAvCJ,QAAI,KAAK/8B,MAAL,CAAY5N,IAAZ,KAAqBrG,aAAa,CAACC,MAAvC,EAA+C;AAC3C,YAAM6B,OAAO,GAAG,MAAA,KAAKkS,QAAL,UAAA,iBAAA,SAAA,MAAe7E,KAA/B;AACArN,MAAAA,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAE4T,gBAAT,CAA0B,UAA1B,EAAsC,KAAK2B,WAA3C,CAAA;AACAvV,MAAAA,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAE4T,gBAAT,CAA0B,SAA1B,EAAqC,KAAK0B,UAA1C,CAAA,CAH2C;;AAM3C,WAAK45B,SAAL,GAAiB/lC,GAAG,CAACI,YAAJ,CACbvJ,OADa,EAEbA,OAAO,IAAImJ,GAAG,CAACK,gBAAJ,CAAqBxJ,OAAO,CAACiJ,aAA7B,CAFE,CAAjB;AAIH;AACJ;;AAED9I,EAAAA,OAAO;;;AACH,QAAI,KAAKgS,MAAL,CAAY5N,IAAZ,KAAqBrG,aAAa,CAACC,MAAvC,EAA+C;AAC3C,YAAM6B,OAAO,GAAG,MAAA,KAAKkS,QAAL,UAAA,iBAAA,SAAA,MAAe7E,KAA/B;AACArN,MAAAA,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAEkU,mBAAT,CAA6B,UAA7B,EAAyC,KAAKqB,WAA9C,CAAA;AACAvV,MAAAA,OAAO,SAAP,IAAAA,OAAO,WAAP,SAAA,GAAAA,OAAO,CAAEkU,mBAAT,CAA6B,SAA7B,EAAwC,KAAKoB,UAA7C,CAAA;;AAEA,UAAI,KAAK45B,SAAT,EAAoB;AAChB,cAAMnpC,GAAG,GAAG,KAAKkM,QAAL,CAAc7G,SAAd,GAA0BL,QAAtC;;AACAhF,QAAAA,GAAG,CAACyL,IAAJ,CAAS+E,aAAT,CAAuB,IAAI/Q,yBAAJ,EAAvB;AACH;AACJ;AACJ;;;;MAoBQ2pC;AAOT7qC,EAAAA,YAAYvE;AALJ,iBAAA,GAA2C,EAA3C;;AA+BA,wBAAA,GAAmBmB,CAAD;AACtB,WAAKkuC,oBAAL,CAA0B/W,gBAA1B,CAA2Cx7B,iBAAiB,CAACE,QAA7D;;;AAGA,YAAMyP,MAAM,GAAGtL,CAAC,CAACqd,YAAF,GAAiB,CAAjB,CAAf;;AAEA,UAAI/R,MAAJ,EAAY;AACR,aAAK4iC,oBAAL,CAA0BlX,iBAA1B,CACIr7B,iBAAiB,CAACE,QADtB,EAEI,MAAM,KAAKsyC,aAAL,CAAmB7iC,MAAnB,CAFV,EAGI,CAHJ;AAKH;AACJ,KAbO;;AAeA,mBAAA,GAAcxM,OAAD;;;AACjB,UAAI,CAACA,OAAL,EAAc;AACV;AACH;;AAED,YAAMsvC,gBAAgB,GAAGxvC,mBAAmB,CAAC,KAAKmS,QAAN,EAAgBjS,OAAhB,CAA5C;;AACA,UACI,CAAA,MAAAsvC,gBAAgB,SAAhB,IAAAA,gBAAgB,WAAhB,SAAA,GAAAA,gBAAgB,CAAE9sC,QAAlB,UAAA,iBAAA,SAAA,MAA4B6P,WAAW9N,IAAvC,MAAgDrG,aAAa,CAACE,MADlE,EAEE;AACE;AACH;;AAED,WAAKmxC,aAAL,CAAmBvvC,OAAnB;AACH,KAbO;;AA8BA,sBAAA,GAAiB2wB,MAAD;;;;AAEpB,YAAM5qB,GAAG,GAAG,KAAK8T,UAAL,GAAkB9O,QAA9B;;AACA,UAAI5B,GAAG,CAACK,gBAAJ,CAAqBzD,GAArB,MAA8BA,GAAG,CAACyL,IAAtC,EAA4C;AACxC;AACH;;AAED;AAEI,OAAC,KAAKg+B,iBAAL,CAAuB7oB,wBAAvB,EAAD;AAEAxd,MAAAA,GAAG,CAACI,YAAJ,CAAiBxD,GAAG,CAACyL,IAArB,EAA2Bmf,MAA3B,CAJJ,EAKE;AACE;AACH;;AAED,UAAIzT,WAAW,GAAG,KAAK2F,QAAL,CAAckD,GAAd,EAAlB;;AACA,aACI7I,WAAW,IACX,CAAC/T,GAAG,CAACI,YAAJ,CAAiBxD,GAAG,CAACyL,IAArB,EAA2BrI,GAAG,CAACG,gBAAJ,CAAqB4T,WAAW,CAAC7P,GAAZ,EAArB,CAA3B,CAFL,EAGE;AACE6P,QAAAA,WAAW,GAAG,KAAK2F,QAAL,CAAckD,GAAd,EAAd;AACH;;AAED,YAAA7I,WAAW,SAAX,IAAAA,WAAW,WAAX,SAAA,GAAAA,WAAW,CAAE7P,GAAb,EAAA,UAAA,iBAAA,SAAA,MAAoBkV,OAApB;AACH,KAzBO;;AAtEJ,SAAKtQ,QAAL,GAAgBlS,OAAhB;AACA,SAAK8Z,UAAL,GAAkB9Z,OAAO,CAACqL,SAA1B;;AACA,SAAKyO,UAAL,GAAkBjG,gBAAlB,CACI5P,6BADJ,EAEI,KAAKojB,eAFT;;AAKA,SAAKooB,iBAAL,GAAyBzvC,OAAO,CAACwd,kBAAjC;AACA,SAAK6xB,oBAAL,GAA4BrvC,OAAO,CAAC0d,cAApC;;AAEA,SAAK2xB,oBAAL,CAA0BjoB,SAA1B,CAAoC,KAAK7R,UAAzC;AACH;;AAEDnV,EAAAA,OAAO;AACH,UAAMkL,GAAG,GAAG,KAAKwO,UAAL,EAAZ;;AACA,SAAKu1B,oBAAL,CAA0B5nB,WAA1B,CAAsC,KAAKlS,UAA3C;;AAEA,SAAK85B,oBAAL,CAA0B/W,gBAA1B,CAA2Cx7B,iBAAiB,CAACE,QAA7D;;AAEAsO,IAAAA,GAAG,CAAC6I,mBAAJ,CACIlQ,6BADJ,EAEI,KAAKojB,eAFT;AAIH;;AAgCOmoB,EAAAA,aAAa,CAACvvC,OAAD;;;;AAEjB,QAAI,CAAA,MAAA,KAAK6iB,QAAL,CAAc,KAAKA,QAAL,CAAc3f,MAAd,GAAuB,CAArC,CAAA,UAAA,iBAAA,SAAA,MAAyCmK,KAAzC,MAAmDrN,OAAvD,EAAgE;AAC5D;AACH;;AAED,QAAI,KAAK6iB,QAAL,CAAc3f,MAAd,GAAuB+rC,aAA3B,EAA0C;AACtC,WAAKpsB,QAAL,CAAc4sB,KAAd;AACH;;AAED,SAAK5sB,QAAL,CAAc3V,IAAd,CACI,IAAIH,eAAJ,CAAiC,KAAK8M,UAAtC,EAAkD7Z,OAAlD,CADJ;AAGH;;AA6BMyC,EAAAA,cAAc,CAACzC,OAAD,EAAuBgS,KAAvB;AACjB,UAAMxP,QAAQ,GAAG,IAAIzF,QAAJ,CAAa,KAAKkV,QAAlB,EAA4BjS,OAA5B,EAAqCgS,KAArC,CAAjB;;AAEA,QACIA,KAAK,CAACzN,IAAN,KAAerG,aAAa,CAACE,MAA7B,IACA+K,GAAG,CAACK,gBAAJ,CAAqBxJ,OAAO,CAACiJ,aAA7B,MAAgDjJ,OAFpD,EAGE;AACE,WAAKuvC,aAAL,CAAmBvvC,OAAnB;AACH;;AAED,WAAOwC,QAAP;AACH;;;;ACnML;;;;SAKgBgH,iBAAiBzD;;;AAC7B,MAAIc,aAAa,GAAGd,GAAG,CAACc,aAAxB;;AAEA,SAAO,MAAAA,aAAa,SAAb,IAAAA,aAAa,WAAb,SAAA,GAAAA,aAAa,CAAE6oC,UAAf,UAAA,iBAAA,SAAA,MAA2B7oC,aAAlC,EAAiD;AAC7CA,IAAAA,aAAa,GAAGA,aAAa,CAAC6oC,UAAd,CAAyB7oC,aAAzC;AACH;;AAED,SAAOA,aAAP;AACH;SAEe0C,aACZnD,MACAupC;;;AAEA,MAAI,CAACvpC,IAAD,IAAS,CAACupC,SAAd,EAAyB;AACrB,WAAO,KAAP;AACH;;AAED,MAAIxa,WAAW,GAA0Cwa,SAAzD;;AAEA,SAAOxa,WAAP,EAAoB;AAChB,QAAIA,WAAW,KAAK/uB,IAApB,EAA0B;AACtB,aAAO,IAAP;AACH;;AAED,QACI,OAAQ+uB,WAA+B,CAACya,gBAAxC,KACI,UADJ,KAEA,MAACza,WAA2B,CAAC0a,YAA7B,UAAA,iBAAA,SAAA,MAA2CxpC,UAF3C,CADJ,EAIE;AACE;AACA8uB,MAAAA,WAAW,GAAG,MAACA,WAA2B,CAAC0a,YAA7B,UAAA,iBAAA,SAAA,MAA2CxpC,UAAzD;AACH,KAPD,MAOO,IAAI8uB,WAAW,CAACrnB,QAAZ,KAAyB/C,QAAQ,CAACka,sBAAtC,EAA8D;AACjE;AACAkQ,MAAAA,WAAW,GAAIA,WAA0B,CAAC2a,IAA1C;AACH,KAHM,MAGA;AACH3a,MAAAA,WAAW,GAAGA,WAAW,CAAC9uB,UAA1B;AACH;AACJ;;AAED,SAAO,KAAP;AACH;SAEegD,cACZjD;AAEA,MAAI,CAACA,IAAL,EAAW;AACP,WAAO,IAAP;AACH;;AAED,MACIA,IAAI,CAAC0H,QAAL,KAAkBC,IAAI,CAACkX,sBAAvB,IACC7e,IAAmB,CAAC0pC,IAFzB,EAGE;AACE,WAAQ1pC,IAAmB,CAAC0pC,IAA5B;AACH;;AAED,SAAO1pC,IAAI,CAACC,UAAZ;AACH;SAEeiD,iBACZtJ;AAEA,OACI,IAAIqG,UAAU,GAAGgD,aAAa,CAACrJ,OAAD,CADlC,EAEIqG,UAFJ,EAGIA,UAAU,GAAGgD,aAAa,CAAChD,UAAD,CAH9B,EAIE;AACE,QAAIA,UAAU,CAACyH,QAAX,KAAwBC,IAAI,CAACC,YAAjC,EAA+C;AAC3C,aAAO3H,UAAP;AACH;AACJ;;AAED,SAAO,IAAP;AACH;SAEeoD,cAAcrD;AAC1B,MAAI,CAACA,IAAL,EAAW;AACP,WAAO,IAAP;AACH;;AAED,MAAKA,IAAgB,CAACspC,UAAtB,EAAkC;AAC9B,UAAMhpC,KAAK,GAAG+C,aAAa,CAAErD,IAAgB,CAACspC,UAAnB,CAA3B;;AAEA,QAAIhpC,KAAJ,EAAW;AACP,aAAOA,KAAP;AACH,KAL6B;AAQ9B;;AACH;;AAED,SAAON,IAAI,CAACuB,UAAZ;AACH;SAEe+B,eAAatD;AACzB,MAAI,CAACA,IAAL,EAAW;AACP,WAAO,IAAP;AACH;;AAED,MAAI,CAACA,IAAI,CAACyB,SAAN,IAAoBzB,IAAgB,CAACspC,UAAzC,EAAqD;AACjD,WAAOhmC,cAAY,CAAEtD,IAAgB,CAACspC,UAAnB,CAAnB;AACH;;AAED,SAAOtpC,IAAI,CAACyB,SAAZ;AACH;SAEe8B,eACZvD;AAEA,SAAO,CAAAA,IAAI,SAAJ,IAAAA,IAAI,WAAJ,SAAA,GAAAA,IAAI,CAAE2B,WAAN,KAAqB,IAA5B;AACH;SAEe6B,mBACZxD;;;AAEA,MAAI,CAACA,IAAL,EAAW;AACP,WAAO,IAAP;AACH;;AAED,MAAI2pC,OAAO,GAAG3pC,IAAI,CAAC6B,eAAnB;;AAEA,MAAI,CAAC8nC,OAAD,KAAY,MAAA3pC,IAAI,CAACG,aAAL,UAAA,iBAAA,SAAA,MAAoBmpC,UAAhC,CAAJ,EAAgD;AAC5CK,IAAAA,OAAO,GAAGrmC,cAAY,CAACtD,IAAI,CAACG,aAAL,CAAmBmpC,UAApB,CAAtB;AACH;;AAED,SAAOK,OAAP;AACH;SAEelmC,qBACZ7J;AAEA,MAAI0G,KAAK,GAAG+C,aAAa,CAACzJ,OAAD,CAAzB;;AAEA,SAAO0G,KAAK,IAAIA,KAAK,CAACoH,QAAN,KAAmBC,IAAI,CAACC,YAAxC,EAAsD;AAClDtH,IAAAA,KAAK,GAAGiD,cAAc,CAACjD,KAAD,CAAtB;AACH;;AAED,SAAOA,KAAP;AACH;SAEeoD,oBACZ9J;AAEA,MAAI0G,KAAK,GAAGgD,cAAY,CAAC1J,OAAD,CAAxB;;AAEA,SAAO0G,KAAK,IAAIA,KAAK,CAACoH,QAAN,KAAmBC,IAAI,CAACC,YAAxC,EAAsD;AAClDtH,IAAAA,KAAK,GAAGkD,kBAAkB,CAAClD,KAAD,CAA1B;AACH;;AAED,SAAOA,KAAP;AACH;SAEeqD,sBACZ/J;AAEA,MAAI+vC,OAAO,GAAGpmC,cAAc,CAAC3J,OAAD,CAA5B;;AAEA,SAAO+vC,OAAO,IAAIA,OAAO,CAACjiC,QAAR,KAAqBC,IAAI,CAACC,YAA5C,EAA0D;AACtD+hC,IAAAA,OAAO,GAAGpmC,cAAc,CAAComC,OAAD,CAAxB;AACH;;AAED,SAAOA,OAAP;AACH;SAEe/lC,0BACZhK;AAEA,MAAI+vC,OAAO,GAAGnmC,kBAAkB,CAAC5J,OAAD,CAAhC;;AAEA,SAAO+vC,OAAO,IAAIA,OAAO,CAACjiC,QAAR,KAAqBC,IAAI,CAACC,YAA5C,EAA0D;AACtD+hC,IAAAA,OAAO,GAAGnmC,kBAAkB,CAACmmC,OAAD,CAA5B;AACH;;AAED,SAAOA,OAAP;AACH;SAEepnC,YAAYlC,QAAcC;AACtC,QAAMgpC,UAAU,GAAIjpC,MAAkB,CAACipC,UAAvC;AACA,SAAOA,UAAU,GACXA,UAAU,CAAC/mC,WAAX,CAAuBjC,KAAvB,CADW,GAEXD,MAAM,CAACkC,WAAP,CAAmBjC,KAAnB,CAFN;AAGH;SAEeoC,aACZrC,QACAC,OACAmC;AAEA,QAAM6mC,UAAU,GAAIjpC,MAAkB,CAACipC,UAAvC;AACA,SAAOA,UAAU,GACXA,UAAU,CAAC5mC,YAAX,CAAwBpC,KAAxB,EAA+BmC,cAA/B,CADW,GAEXpC,MAAM,CAACqC,YAAP,CAAoBpC,KAApB,EAA2BmC,cAA3B,CAFN;AAGH;SAMeK,aAAaF;;;AACzB,QAAMqC,GAAG,GAAG,MAAArC,GAAG,CAACC,aAAJ,UAAA,iBAAA,SAAA,MAAmBqT,WAA/B;;AAEA,MAAI,CAACjR,GAAL,EAAU;AACN,WAAO,IAAP;AACH;;AAED,OAAK,IAAIyE,EAAE,GAAgB9G,GAA3B,EAAgC8G,EAAhC,EAAoCA,EAAE,GAAGA,EAAE,CAACzJ,UAA5C,EAAwD;AACpD,QAAIyJ,EAAE,CAAChC,QAAH,KAAgBC,IAAI,CAACkX,sBAAzB,EAAiD;AAC7C,YAAM+qB,GAAG,GAAGlgC,EAAZ,CAD6C;;AAI7C,UAAIkgC,GAAG,CAAC9mC,YAAR,EAAsB;AAClB,eAAO8mC,GAAG,CAAC9mC,YAAJ,MAAsB,IAA7B;AACH;;AAED;AACH;AACJ;;AAED,SAAOmC,GAAG,CAACnC,YAAJ,MAAsB,IAA7B;AACH;;ACjOD;;;;;AAOA,SAASQ,YAAT,CAAsByF,SAAtB;AACI,MAAItH,SAAS,GAAuB,IAApC;;AAEA,OACI,IAAI8I,CAAC,GAAG7G,mBAAmB,CAACqF,SAAD,CAD/B,EAEIwB,CAFJ,EAGIA,CAAC,GAAG7G,mBAAmB,CAAC6G,CAAD,CAH3B,EAIE;AACE9I,IAAAA,SAAS,GAAG8I,CAAZ;AACH;;AAED,SAAO9I,SAAS,IAAIvH,SAApB;AACH;;MAEY2vC;AAUT3rC,EAAAA,YACIyB,KACAnE,MACAoE,YACAC;AARI,qBAAA,GAA6B,EAA7B;AAEA,uBAAA,GAAkC,IAAIoR,GAAJ,EAAlC;;AA+BA,oBAAA,GAAejR,IAAD;;;AAClB,UAAIA,IAAI,CAAC0H,QAAL,KAAkBC,IAAI,CAACC,YAA3B,EAAyC;AACrC,cAAM0hC,UAAU,GAAItpC,IAAgB,CAACspC,UAArC;;AAEA,YAAIA,UAAJ,EAAgB;AACZ,gBAAM/a,MAAM,GAAG,KAAKub,IAAL,CAAUhqC,gBAAV,CACXwpC,UADW,EAEX,KAAK1pC,UAFM,EAGX;AAAE6H,YAAAA,UAAU,EAAE,KAAKsiC;AAAnB,WAHW,CAAf;;AAMA,eAAKC,YAAL,CAAkBluB,OAAlB,CAA0ByS,MAA1B;;AAEA,iBAAO3pB,UAAU,CAACoqB,aAAlB;AACH,SAVD,MAUO;AACH,cAAI,OAAO,KAAKnvB,MAAZ,KAAuB,UAA3B,EAAuC;AACnC,mBAAO,KAAKA,MAAL,CAAYG,IAAZ,CAAP;AACH,WAFD,MAEO,IAAI,MAAA,KAAKH,MAAL,UAAA,iBAAA,SAAA,MAAa4H,UAAjB,EAA6B;AAChC,mBAAO,KAAK5H,MAAL,CAAY4H,UAAZ,CAAuBzH,IAAvB,CAAP;AACH;AACJ;AACJ;;AAED,aAAO4E,UAAU,CAACwqB,WAAlB;AACH,KAxBO;;AAvBJ,SAAK0a,IAAL,GAAYnqC,GAAZ;AACA,SAAKnE,IAAL,GAAYA,IAAZ;AACA,SAAKqE,MAAL,GAAcA,MAAM,SAAN,IAAAA,MAAM,WAAN,GAAAA,MAAA,GAAU,IAAxB;AACA,SAAKD,UAAL,GAAkBA,UAAU,SAAV,IAAAA,UAAU,WAAV,GAAAA,UAAA,GAAcgF,UAAU,CAACqlC,QAA3C;AACA,SAAKC,YAAL,GAAoB1uC,IAApB;;AAEA,SAAKwuC,YAAL,CAAkBluB,OAAlB,CACInc,GAAG,CAACG,gBAAJ,CAAqBtE,IAArB,EAA2BoE,UAA3B,EAAuC,KAAKmqC,WAA5C,CADJ;;AAIA,UAAMT,UAAU,GAAI9tC,IAAgB,CAAC8tC,UAArC;;AAEA,QAAIA,UAAJ,EAAgB;AACZ,YAAM/a,MAAM,GAAG,KAAKub,IAAL,CAAUhqC,gBAAV,CACXwpC,UADW,EAEX,KAAK1pC,UAFM,EAGX;AAAE6H,QAAAA,UAAU,EAAE,KAAKsiC;AAAnB,OAHW,CAAf;;AAMA,WAAKC,YAAL,CAAkBluB,OAAlB,CAA0ByS,MAA1B;AACH;AACJ;;AA4BqB,MAAXQ,WAAW;AAClB,WAAO,KAAKmb,YAAZ;AACH;;AAEqB,MAAXnb,WAAW,CAAC/uB,IAAD;AAClB,QAAI,CAACmD,YAAY,CAAC,KAAK3H,IAAN,EAAYwE,IAAZ,CAAjB,EAAoC;AAChC,YAAM,IAAIpF,KAAJ,CACF,0EADE,CAAN;AAGH;;AAED,UAAMuvC,OAAO,GAAiB,EAA9B;AACA,QAAIC,OAAO,GAA4BpqC,IAAvC;AACA,QAAIqqC,wBAAwB,GAAGrqC,IAA/B;AAEA,SAAKkqC,YAAL,GAAoBlqC,IAApB;;AAEA,WAAOoqC,OAAO,IAAIA,OAAO,KAAK,KAAK5uC,IAAnC,EAAyC;AACrC,UAAI4uC,OAAO,CAAC1iC,QAAR,KAAqBC,IAAI,CAACkX,sBAA9B,EAAsD;AAClD,cAAMyqB,UAAU,GAAGc,OAAnB;;AAEA,cAAM7b,MAAM,GAAG,KAAKub,IAAL,CAAUhqC,gBAAV,CACXwpC,UADW,EAEX,KAAK1pC,UAFM,EAGX;AAAE6H,UAAAA,UAAU,EAAE,KAAKsiC;AAAnB,SAHW,CAAf;;AAMAI,QAAAA,OAAO,CAACrjC,IAAR,CAAaynB,MAAb;AAEAA,QAAAA,MAAM,CAACQ,WAAP,GAAqBsb,wBAArB;;AAEA,aAAKC,cAAL,CAAoBj5B,GAApB,CAAwBkd,MAAxB;;AAEA6b,QAAAA,OAAO,GAAGC,wBAAwB,GAAGf,UAAU,CAACI,IAAhD;AACH,OAhBD,MAgBO;AACHU,QAAAA,OAAO,GAAGA,OAAO,CAACnqC,UAAlB;AACH;AACJ;;AAED,UAAMsuB,MAAM,GAAG,KAAKub,IAAL,CAAUhqC,gBAAV,CAA2B,KAAKtE,IAAhC,EAAsC,KAAKoE,UAA3C,EAAuD;AAClE6H,MAAAA,UAAU,EAAE,KAAKsiC;AADiD,KAAvD,CAAf;;AAIAI,IAAAA,OAAO,CAACrjC,IAAR,CAAaynB,MAAb;AAEAA,IAAAA,MAAM,CAACQ,WAAP,GAAqBsb,wBAArB;;AAEA,SAAKC,cAAL,CAAoBj5B,GAApB,CAAwBkd,MAAxB;;AAEA,SAAKyb,YAAL,GAAoBG,OAApB;AACH;;AAEM5oC,EAAAA,UAAU;AACb,QAAIxG,sCAAJ,EAAa;AACT,YAAM,IAAIH,KAAJ,CAAU,yBAAV,CAAN;AACH;;AAED,WAAO,IAAP;AACH;;AAEM6G,EAAAA,SAAS;AACZ,QAAI1G,sCAAJ,EAAa;AACT,YAAM,IAAIH,KAAJ,CAAU,yBAAV,CAAN;AACH;;AAED,WAAO,IAAP;AACH;;AAEMu0B,EAAAA,QAAQ;;;AACX,UAAMA,QAAQ,GAAG,KAAK6a,YAAL,CAAkB,CAAlB,EAAqB7a,QAArB,EAAjB;;AAEA,QAAIA,QAAJ,EAAc;AACV,YAAMma,UAAU,GAAIna,QAAoB,CAACma,UAAzC;;AAEA,UAAIA,UAAJ,EAAgB;AACZ,YAAIiB,UAAJ;;AAEA,YAAI,OAAO,KAAK1qC,MAAZ,KAAuB,UAA3B,EAAuC;AACnC0qC,UAAAA,UAAU,GAAG,KAAK1qC,MAAL,CAAYsvB,QAAZ,CAAb;AACH,SAFD,MAEO,IAAI,MAAA,KAAKtvB,MAAL,UAAA,iBAAA,SAAA,MAAa4H,UAAjB,EAA6B;AAChC8iC,UAAAA,UAAU,GAAG,KAAK1qC,MAAL,CAAY4H,UAAZ,CAAuB0nB,QAAvB,CAAb;AACH;;AAED,YAAIob,UAAU,KAAK3lC,UAAU,CAACoqB,aAA9B,EAA6C;AACzC,iBAAOG,QAAP;AACH,SAXW;AAcZ;;;AACA,eAAO,KAAKA,QAAL,EAAP;AACH;;AAED,aAAOA,QAAP;AACH,KAtBD,MAsBO;AACH,UAAI,KAAK6a,YAAL,CAAkBltC,MAAlB,GAA2B,CAA/B,EAAkC;AAC9B,aAAKktC,YAAL,CAAkBX,KAAlB;;AAEA,eAAO,KAAKla,QAAL,EAAP;AACH,OAJD,MAIO;AACH,eAAO,IAAP;AACH;AACJ;AACJ;;AAEMD,EAAAA,YAAY;;;AACf,UAAMsb,aAAa,GAAG,KAAKR,YAAL,CAAkB,CAAlB,CAAtB;;AAEA,QAAIQ,aAAa,CAACzb,WAAd,KAA8Byb,aAAa,CAAChvC,IAAhD,EAAsD;AAClD,UAAI,KAAK8uC,cAAL,CAAoBl5B,GAApB,CAAwBo5B,aAAxB,CAAJ,EAA4C;AACxC,aAAKF,cAAL,CAAoBv4B,MAApB,CAA2By4B,aAA3B;;AAEA,YAAI,KAAKR,YAAL,CAAkBltC,MAAlB,GAA2B,CAA/B,EAAkC;AAC9B,eAAKktC,YAAL,CAAkBX,KAAlB;;AACA,iBAAO,KAAKna,YAAL,EAAP;AACH,SAHD,MAGO;AACH,iBAAO,IAAP;AACH;AACJ;;AAED,YAAMztB,SAAS,GAAG6B,YAAY,CAACknC,aAAa,CAAChvC,IAAf,CAA9B;;AAEA,UAAIiG,SAAJ,EAAe;AACX+oC,QAAAA,aAAa,CAACzb,WAAd,GAA4BttB,SAA5B;AAEA,YAAI8oC,UAAJ;;AAEA,YAAI,OAAO,KAAK1qC,MAAZ,KAAuB,UAA3B,EAAuC;AACnC0qC,UAAAA,UAAU,GAAG,KAAK1qC,MAAL,CAAY4B,SAAZ,CAAb;AACH,SAFD,MAEO,IAAI,MAAA,KAAK5B,MAAL,UAAA,iBAAA,SAAA,MAAa4H,UAAjB,EAA6B;AAChC8iC,UAAAA,UAAU,GAAG,KAAK1qC,MAAL,CAAY4H,UAAZ,CAAuBhG,SAAvB,CAAb;AACH;;AAED,YAAI8oC,UAAU,KAAK3lC,UAAU,CAACoqB,aAA9B,EAA6C;AACzC,iBAAOvtB,SAAP;AACH;AACJ;AACJ;;AAED,UAAMytB,YAAY,GAAGsb,aAAa,CAACtb,YAAd,EAArB;;AAEA,QAAIA,YAAJ,EAAkB;AACd,YAAMoa,UAAU,GAAIpa,YAAwB,CAACoa,UAA7C;;AAEA,UAAIA,UAAJ,EAAgB;AACZ,YAAIiB,UAAJ;;AAEA,YAAI,OAAO,KAAK1qC,MAAZ,KAAuB,UAA3B,EAAuC;AACnC0qC,UAAAA,UAAU,GAAG,KAAK1qC,MAAL,CAAYqvB,YAAZ,CAAb;AACH,SAFD,MAEO,IAAI,MAAA,KAAKrvB,MAAL,UAAA,iBAAA,SAAA,MAAa4H,UAAjB,EAA6B;AAChC8iC,UAAAA,UAAU,GAAG,KAAK1qC,MAAL,CAAY4H,UAAZ,CAAuBynB,YAAvB,CAAb;AACH;;AAED,YAAIqb,UAAU,KAAK3lC,UAAU,CAACoqB,aAA9B,EAA6C;AACzC,iBAAOE,YAAP;AACH,SAXW;AAcZ;;;AACA,eAAO,KAAKA,YAAL,EAAP;AACH;;AAED,aAAOA,YAAP;AACH,KAtBD,MAsBO;AACH,UAAI,KAAK8a,YAAL,CAAkBltC,MAAlB,GAA2B,CAA/B,EAAkC;AAC9B,aAAKktC,YAAL,CAAkBX,KAAlB;;AAEA,eAAO,KAAKna,YAAL,EAAP;AACH,OAJD,MAIO;AACH,eAAO,IAAP;AACH;AACJ;AACJ;;AAEMvtB,EAAAA,WAAW;AACd,QAAI5G,sCAAJ,EAAa;AACT,YAAM,IAAIH,KAAJ,CAAU,yBAAV,CAAN;AACH;;AAED,WAAO,IAAP;AACH;;AAEMiH,EAAAA,eAAe;AAClB,QAAI9G,sCAAJ,EAAa;AACT,YAAM,IAAIH,KAAJ,CAAU,yBAAV,CAAN;AACH;;AAED,WAAO,IAAP;AACH;;AAEMqF,EAAAA,UAAU;AACb,QAAIlF,sCAAJ,EAAa;AACT,YAAM,IAAIH,KAAJ,CAAU,yBAAV,CAAN;AACH;;AAED,WAAO,IAAP;AACH;;;SAGW6vC,uBACZ9qC,KACAnE,MACAoE,YACAC;AAEA,SAAO,IAAIgqC,gBAAJ,CAAqBlqC,GAArB,EAA0BnE,IAA1B,EAAgCoE,UAAhC,EAA4CC,MAA5C,CAAP;AACH;;ACnSD;;;;MAWa6qC;AAU2B,SAArBC,qBAAqB,CAChC1lC,GADgC;AAGhC,UAAM2lC,gBAAgB,GAAG3lC,GAAG,CAAC4lC,OAAJ,CAAY9pC,SAAZ,CAAsB+pC,YAA/C;;AAEA,QAAKF,gBAA0C,CAACG,kBAAhD,EAAoE;AAChE;AACH;;AAEDF,IAAAA,OAAO,CAAC9pC,SAAR,CAAkB+pC,YAAlB,GAAiC,UAE7B9wB,OAF6B;AAI7B,YAAMsvB,UAAU,GAAGsB,gBAAgB,CAAC3pC,IAAjB,CAAsB,IAAtB,EAA4B+Y,OAA5B,CAAnB;;AAEA,WAAK,MAAMgxB,cAAX,IAA6BN,sBAAsB,CAACO,gBAApD,EAAsE;AAClED,QAAAA,cAAc,CAACE,eAAf,CAA+B5B,UAA/B;AACH;;AAED,aAAOA,UAAP;AACH,KAXD;;AAcIuB,IAAAA,OAAO,CAAC9pC,SAAR,CAAkB+pC,YAAlB,CACFC,kBADE,GACmBH,gBADnB;AAEP;;AAED1sC,EAAAA,YAAYsB;AA7BJ,qBAAA,GAAe,KAAf;;AAmCA,yBAAA,GAAmB,CACvBy8B,SADuB,EAEvBD,QAFuB;AAIvB,WAAK,MAAME,QAAX,IAAuBD,SAAvB,EAAkC;AAC9B,YAAIC,QAAQ,CAAC/9B,IAAT,KAAkB,WAAtB,EAAmC;AAC/B,gBAAMqd,OAAO,GAAG0gB,QAAQ,CAACC,YAAzB;AACA,gBAAMC,KAAK,GAAGF,QAAQ,CAACG,UAAvB;;AAEA,eAAK,IAAI9xB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiR,OAAO,CAAC1e,MAA5B,EAAoCyN,CAAC,EAArC,EAAyC;AACrC,iBAAK4gC,YAAL,CAAkB3vB,OAAO,CAACjR,CAAD,CAAzB,EAA8B,IAA9B;AACH;;AAED,eAAK,IAAIA,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6xB,KAAK,CAACt/B,MAA1B,EAAkCyN,CAAC,EAAnC,EAAuC;AACnC,iBAAK4gC,YAAL,CAAkB/O,KAAK,CAAC7xB,CAAD,CAAvB;AACH;AACJ;AACJ;;AAED,WAAK6gC,SAAL,CAAenP,SAAf,EAA0BD,QAA1B;AACH,KApBO;;AALJ,SAAKoP,SAAL,GAAiB5rC,QAAjB;AACA,SAAK6rC,SAAL,GAAiB,IAAI5rC,gBAAJ,CAAqB,KAAK6rC,gBAA1B,CAAjB;AACA,SAAKC,aAAL,GAAqB,IAAI/4B,GAAJ,EAArB;AACH;;AAwBO04B,EAAAA,eAAe,CAAC5B,UAAD;AACnB,QACI,CAAC,KAAKkC,QAAN,IACA,CAAC,KAAKJ,SADN,IAEA,KAAKG,aAAL,CAAmBn6B,GAAnB,CAAuBk4B,UAAvB,CAHJ,EAIE;AACE;AACH;;AAED,QAAI,KAAKkC,QAAL,CAAcvO,OAAd,IAAyB95B,YAAY,CAAC,KAAKsoC,KAAN,EAAanC,UAAb,CAAzC,EAAmE;AAC/D,YAAMoC,WAAW,GAAG,IAAIjsC,gBAAJ,CAAqB,KAAK6rC,gBAA1B,CAApB;;AAEA,WAAKC,aAAL,CAAmB55B,GAAnB,CAAuB23B,UAAvB,EAAmCoC,WAAnC;;AAEA,UAAI,KAAKC,YAAT,EAAuB;AACnBD,QAAAA,WAAW,CAAChP,OAAZ,CAAoB4M,UAApB,EAAgC,KAAKkC,QAArC;AACH;;AAED,WAAKL,YAAL,CAAkB7B,UAAlB;AACH;AACJ;;AAEMlO,EAAAA,UAAU;AACb,SAAKuQ,YAAL,GAAoB,KAApB;AAEA,WAAO,KAAKH,QAAZ;;AAEAd,IAAAA,sBAAsB,CAACO,gBAAvB,CAAwCl5B,MAAxC,CAA+C,IAA/C;;AAEA,SAAK,MAAM25B,WAAX,IAA0B,KAAKH,aAAL,CAAmBK,MAAnB,EAA1B,EAAuD;AACnDF,MAAAA,WAAW,CAACtQ,UAAZ;AACH;;AAED,SAAKmQ,aAAL,CAAmBr5B,KAAnB;;AAEA,SAAKm5B,SAAL,CAAejQ,UAAf;AACH;;AAEMsB,EAAAA,OAAO,CAACt2B,MAAD,EAAe4T,OAAf;AACV,UAAMra,GAAG,GACLyG,MAAM,CAACsB,QAAP,KAAoBC,IAAI,CAACkkC,aAAzB,GACOzlC,MADP,GAEMA,MAAM,CAACvD,aAHjB;AAIA,UAAMoC,GAAG,GAAGtF,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEuW,WAAjB;;AAEA,QAAI,CAACvW,GAAD,IAAQ,CAACsF,GAAb,EAAkB;AACd;AACH;;AAEDylC,IAAAA,sBAAsB,CAACC,qBAAvB,CAA6C1lC,GAA7C;;AACAylC,IAAAA,sBAAsB,CAACO,gBAAvB,CAAwC55B,GAAxC,CAA4C,IAA5C;;AAEA,SAAKo6B,KAAL,GAAarlC,MAAb;AACA,SAAKolC,QAAL,GAAgBxxB,OAAhB;AAEA,SAAK2xB,YAAL,GAAoB,IAApB;;AAEA,SAAKN,SAAL,CAAe3O,OAAf,CAAuBt2B,MAAvB,EAA+B4T,OAA/B;;AAEA,SAAKmxB,YAAL,CAAkB/kC,MAAlB;AACH;;AAEO+kC,EAAAA,YAAY,CAAC/kC,MAAD,EAAe0L,MAAf;AAChB,UAAMnS,GAAG,GACLyG,MAAM,CAACsB,QAAP,KAAoBC,IAAI,CAACkkC,aAAzB,GACOzlC,MADP,GAEMA,MAAM,CAACvD,aAHjB;;AAKA,QAAI,CAAClD,GAAL,EAAU;AACN;AACH;;AAED,QAAIyG,MAAM,KAAKzG,GAAf,EAAoB;AAChByG,MAAAA,MAAM,GAAGzG,GAAG,CAACyL,IAAb;AACH,KAFD,MAEO;AACH,YAAMk+B,UAAU,GAAIljC,MAAkB,CAACkjC,UAAvC;;AAEA,UAAIA,UAAJ,EAAgB;AACZ,aAAK4B,eAAL,CAAqB5B,UAArB;;AACA;AACH;AACJ;;AAED,UAAM/a,MAAM,GAAG5uB,GAAG,CAACG,gBAAJ,CAAqBsG,MAArB,EAA6BxB,UAAU,CAACC,YAAxC,EAAsD;AACjE4C,MAAAA,UAAU,EAAGzH,IAAD;AACR,YAAIA,IAAI,CAAC0H,QAAL,KAAkBC,IAAI,CAACC,YAA3B,EAAyC;AACrC,cAAIkK,MAAJ,EAAY;AACR,kBAAM45B,WAAW,GAAG,KAAKH,aAAL,CAAmBtkC,GAAnB,CAAuBjH,IAAvB,CAApB;;AAEA,gBAAI0rC,WAAJ,EAAiB;AACbA,cAAAA,WAAW,CAACtQ,UAAZ;;AACA,mBAAKmQ,aAAL,CAAmBx5B,MAAnB,CAA0B/R,IAA1B;AACH;AACJ,WAPD,MAOO;AACH,kBAAMspC,UAAU,GAAItpC,IAAgB,CAACspC,UAArC;;AAEA,gBAAIA,UAAJ,EAAgB;AACZ,mBAAK4B,eAAL,CAAqB5B,UAArB;AACH;AACJ;AACJ;;AAED,eAAO1kC,UAAU,CAACwqB,WAAlB;AACH;AApBgE,KAAtD,CAAf;AAuBAb,IAAAA,MAAM,CAACY,QAAP;AACH;;AAEM2c,EAAAA,WAAW;AACd,UAAMC,OAAO,GAAG,KAAKV,SAAL,CAAeS,WAAf,EAAhB;;AAEA,SAAK,MAAMJ,WAAX,IAA0B,KAAKH,aAAL,CAAmBK,MAAnB,EAA1B,EAAuD;AACnDG,MAAAA,OAAO,CAACjlC,IAAR,CAAa,GAAG4kC,WAAW,CAACI,WAAZ,EAAhB;AACH;;AAED,WAAOC,OAAP;AACH;;;AArLcrB,uCAAA,gBAAgD,IAAIz5B,GAAJ,EAAhD;SAwLH+6B,6BACZxsC;AAEA,SAAO,IAAIkrC,sBAAJ,CAA2BlrC,QAA3B,CAAP;AACH;;ACxMD;;;;AAKA,SAASysC,mBAAT,CACIjsC,IADJ,EAEIW,QAFJ,EAGI8qB,GAHJ;AAKI;AACA;AAEA,QAAMyC,QAAQ,GAAc,EAA5B;AAEAmL,EAAAA,IAAI,CAACr5B,IAAD,EAAOW,QAAP,CAAJ;AAEA,SAAOutB,QAAP;;AAEA,WAASmL,IAAT,CAAcxlB,IAAd,EAA0BlT,QAA1B;AACI,QAAI+I,EAAE,GAAmB,IAAzB;AAEA,UAAM6kB,MAAM,GAAG5pB,QAAQ,CAAC7E,gBAAT,CACX+T,IADW,EAEXjP,UAAU,CAACC,YAFA,EAGX;AACI4C,MAAAA,UAAU,EAAGykC,CAAD;AACR,YAAIA,CAAC,CAACxkC,QAAF,KAAeC,IAAI,CAACC,YAAxB,EAAsC;AAClC,cAAKskC,CAAa,CAAC5gC,OAAd,CAAsB3K,QAAtB,CAAL,EAAsC;AAClC+I,YAAAA,EAAE,GAAGwiC,CAAL;AACAhe,YAAAA,QAAQ,CAACpnB,IAAT,CAAc4C,EAAd;AACA,mBAAO+hB,GAAG,GACJ7mB,UAAU,CAACwqB,WADP,GAEJxqB,UAAU,CAACoqB,aAFjB;AAGH;;AAED,gBAAMsa,UAAU,GAAI4C,CAAa,CAAC5C,UAAlC;;AAEA,cAAIA,UAAJ,EAAgB;AACZjQ,YAAAA,IAAI,CAACiQ,UAAD,EAAa3oC,QAAb,CAAJ;AACA,mBAAO,CAAC8qB,GAAD,IAAQyC,QAAQ,CAACpxB,MAAjB,GACD8H,UAAU,CAACoqB,aADV,GAEDpqB,UAAU,CAACwqB,WAFjB;AAGH;AACJ;;AACD,eAAOxqB,UAAU,CAACwqB,WAAlB;AACH;AArBL,KAHW,CAAf;AA4BAb,IAAAA,MAAM,CAACY,QAAP;AACH;AACJ;;SAEejuB,iBACZlB,MACAW;AAEA,SAAOsrC,mBAAmB,CAACjsC,IAAD,EAAOW,QAAP,EAAiB,IAAjB,CAA1B;AACH;SAEeC,cACZZ,MACAW;AAEA,SAAOsrC,mBAAmB,CAACjsC,IAAD,EAAOW,QAAP,EAAiB,KAAjB,CAAnB,CAA2C,CAA3C,KAAiD,IAAxD;AACH;SAEeU,eAAe1B,KAAeyB;AAC1C,SAAOR,aAAa,CAACjB,GAAD,EAAM,MAAMyB,EAAZ,CAApB;AACH;;ACtED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;;;;;AAuCA,MAAM+qC,OAAN;AAQIjuC,EAAAA,YAAYvE;AACR,SAAKwd,kBAAL,GAA0Bxd,OAAO,CAACwd,kBAAlC;AACA,SAAKE,cAAL,GAAsB1d,OAAO,CAAC0d,cAA9B;AACA,SAAK/a,SAAL,GAAiB3C,OAAO,CAAC2C,SAAzB;AACA,SAAKd,IAAL,GAAY7B,OAAO,CAAC6B,IAApB;AACA,SAAKoB,YAAL,GAAoBjD,OAAO,CAACiD,YAA5B;AACA,SAAKwvC,IAAL,GAAYzyC,OAAZ;AACH;;;AAGL;;;;;AAGA,MAAM0yC,WAAN;AAmCInuC,EAAAA,YAAY+G,KAAa2G;;;AA9BjB,iCAAA,GAA0C,EAA1C;AACA,kBAAA,GAA0B,IAAIqF,GAAJ,EAA1B;AAEA,mBAAA,GAA6B,EAA7B;AAER,iBAAA,GAAmBq7B,OAAnB;AACA,cAAA,GAAQ,KAAR;;AAwLA,kBAAA,GAAY;AACR,UAAI,CAAC,KAAK/6B,IAAV,EAAgB;AACZ,cAAM,IAAI3W,KAAJ,CAAU,yBAAV,CAAN;AACH;;AAED,aAAO,KAAK2W,IAAZ;AACH,KAND;;AA/JI,SAAKg7B,QAAL,GAAgBvmC,aAAa,CAACf,GAAD,CAA7B;AACA,SAAKsM,IAAL,GAAYtM,GAAZ;AAEA,UAAMD,SAAS,GAAG,KAAKA,SAAvB;;AAEA,QAAI4G,KAAK,SAAL,IAAAA,KAAK,WAAL,SAAA,GAAAA,KAAK,CAAE4gC,MAAX,EAAmB;AACf3oC,MAAAA,SAAS,CAAC,EAAE,GAAG+H,KAAK,CAAC4gC;AAAX,OAAD,CAAT;AACH;;AAED,SAAKr1B,kBAAL,GAA0B,IAAIqe,uBAAJ,CAA4BxwB,SAA5B,CAA1B;AACA,SAAKqS,cAAL,GAAsB,IAAIgZ,mBAAJ,CAAwB,IAAxB,EAA8BrrB,SAA9B,CAAtB;AACA,SAAK1I,SAAL,GAAiB,IAAIqwB,YAAJ,CAAiB,IAAjB,CAAjB;AACA,SAAKnxB,IAAL,GAAY,IAAIsd,OAAJ,CAAY,IAAZ,EAAkBlN,KAAK,SAAL,IAAAA,KAAK,WAAL,SAAA,GAAAA,KAAK,CAAEmN,QAAzB,CAAZ;AACA,SAAKnc,YAAL,GAAoB,IAAI+rC,eAAJ;AAEhB,KAAA/8B,KAAK,SAAL,IAAAA,KAAK,WAAL,SAAA,GAAAA,KAAK,CAAE6gC,2BAAP,MACI7gC,KAAK,SAAL,IAAAA,KAAK,WAAL,SAAA,GAAAA,KAAK,CAAE8gC,8BADX,CAFgB,CAApB;AAKA,SAAKp0B,UAAL,GAAkB,MAAA1M,KAAK,SAAL,IAAAA,KAAK,WAAL,SAAA,GAAAA,KAAK,CAAE0M,UAAP,UAAA,iBAAA,KAAA,GAAqB,IAAvC;AACA,SAAKC,eAAL,GAAuB,CAAC,EAAC3M,KAAK,SAAL,IAAAA,KAAK,WAAL,SAAA,GAAAA,KAAK,CAAE2M,eAAR,CAAxB;AAEA,SAAK5E,cAAL,GAAsB,IAAI3C,kBAAJ,CAAuBhM,SAAvB,CAAtB;AAEA,SAAKgT,SAAL,GAAiB,MAAApM,KAAK,SAAL,IAAAA,KAAK,WAAL,SAAA,GAAAA,KAAK,CAAEoM,SAAP,UAAA,iBAAA,KAAA,GAAoBjV,GAAG,CAACE,aAAzC;AAEA,SAAK0pC,QAAL,GAAgB;AACZC,MAAAA,YAAY,EAAE;AACV,YAAI,KAAKtR,UAAT,EAAqB;AACjB,eAAKA,UAAL;;AACA,iBAAO,KAAKA,UAAZ;AACH;AACJ,OANW;AAQZuR,MAAAA,cAAc,EAAG7K,SAAD;AACZ,YAAI,CAAC,KAAK1G,UAAV,EAAsB;AAClB,gBAAM37B,GAAG,GAAGqF,SAAS,GAAGL,QAAxB;AACA,eAAK22B,UAAL,GAAkByG,gBAAgB,CAC9BpiC,GAD8B,EAE9B,IAF8B,EAG9B7F,wBAH8B,EAI9BkoC,SAJ8B,CAAlC;AAMH;AACJ;AAlBW,KAAhB;AAqBA56B,IAAAA,wBAAwB,CAACpC,SAAD,CAAxB;AAGA;;AACA,SAAKqU,SAAL,CAAe;AACX,WAAKszB,QAAL,CAAcE,cAAd,CAA6B,IAA7B;AACH,KAFD;AAGH;AAED;;;;;;;AAKQC,EAAAA,WAAW,CAAClhC,KAAD;;;AACf,QAAI,CAACA,KAAL,EAAY;AACR;AACH;;AAED,SAAKoM,SAAL,GAAiB,MAAApM,KAAK,CAACoM,SAAN,UAAA,iBAAA,KAAA,GAAmB,KAAKA,SAAzC;AACH;;AAED+0B,EAAAA,aAAa,CACTC,UADS,EAETphC,KAFS;AAIT,UAAM0H,OAAO,GAAG,IAAI64B,OAAJ,CAAY,IAAZ,CAAhB;;AAEA,QAAI,CAACa,UAAL,EAAiB;AACb,WAAK35B,SAAL,CAAehC,GAAf,CAAmBiC,OAAnB;AACH;;AAED,SAAKw5B,WAAL,CAAiBlhC,KAAjB;;AAEA,WAAO0H,OAAP;AACH;;AAED25B,EAAAA,cAAc,CAAC35B,OAAD,EAAyB45B,YAAzB;AACV,QAAIA,YAAJ,EAAkB;AACd,WAAK75B,SAAL,CAAenB,KAAf;AACH,KAFD,MAEO;AACH,WAAKmB,SAAL,CAAetB,MAAf,CAAsBuB,OAAtB;AACH;;AAED,QAAI,KAAKD,SAAL,CAAe85B,IAAf,KAAwB,CAA5B,EAA+B;AAC3B,WAAKpzC,OAAL;AACH;AACJ;;AAEDA,EAAAA,OAAO;;;AACH,SAAK4yC,QAAL,CAAcC,YAAd;AAEA,UAAM3nC,GAAG,GAAG,KAAKsM,IAAjB;AAEAtM,IAAAA,GAAG,SAAH,IAAAA,GAAG,WAAH,SAAA,GAAAA,GAAG,CAAEa,YAAL,CAAkB,KAAKsnC,UAAvB,CAAA;AACA,WAAO,KAAKA,UAAZ;AACA,SAAKC,UAAL,GAAkB,EAAlB;AAEA,SAAKC,wBAAL,GAAgC,EAAhC;;AAEA,QAAIroC,GAAG,IAAI,KAAKsoC,qBAAhB,EAAuC;AACnCtoC,MAAAA,GAAG,CAACa,YAAJ,CAAiB,KAAKynC,qBAAtB;AACA,aAAO,KAAKA,qBAAZ;AACH;;AAED,UAAA,KAAK1wC,OAAL,UAAA,iBAAA,SAAA,MAAc9C,SAAd;AACA,UAAA,KAAK0uB,WAAL,UAAA,iBAAA,SAAA,MAAkB1uB,SAAlB;AACA,UAAA,KAAK+B,OAAL,UAAA,iBAAA,SAAA,MAAc/B,SAAd;AACA,UAAA,KAAKwC,QAAL,UAAA,iBAAA,SAAA,MAAexC,SAAf;AACA,UAAA,KAAK0C,KAAL,UAAA,iBAAA,SAAA,MAAY1C,SAAZ;AACA,UAAA,KAAKmC,SAAL,UAAA,iBAAA,SAAA,MAAgBnC,SAAhB;AACA,UAAA,KAAK4B,eAAL,UAAA,iBAAA,SAAA,MAAsB5B,SAAtB;AACA,UAAA,KAAKqC,QAAL,UAAA,iBAAA,SAAA,MAAerC,SAAf;AAEA,SAAKod,kBAAL,CAAwBpd,OAAxB;AACA,SAAKuC,SAAL,CAAevC,OAAf;AACA,SAAKsd,cAAL,CAAoBtd,OAApB;AACA,SAAKyB,IAAL,CAAUzB,OAAV;;AAEA,SAAK4Z,cAAL,CAAoB5Z,OAApB;;AAEAwN,IAAAA,sCAAsC,CAAC,KAAKvC,SAAN,CAAtC;AACAkG,IAAAA,iBAAiB,CAAC,KAAKlG,SAAN,CAAjB;AAEA,SAAKunC,QAAL,GAAgB,IAAItmC,OAAJ,EAAhB;;AACA,SAAKoN,SAAL,CAAenB,KAAf;;AAEA,QAAIjN,GAAJ,EAAS;AACLW,MAAAA,sBAAsB,CAACX,GAAD,CAAtB;AACA,aAAOA,GAAG,CAAC6U,iBAAX;AACA,aAAO,KAAKvI,IAAZ;AACH;AACJ;;AAED1X,EAAAA,YAAY,CACRD,OADQ,EAER4zC,SAFQ;AAIR,UAAMC,OAAO,GAAG,KAAKlB,QAArB;AACA,QAAIlyC,KAAK,GAAGozC,OAAO,CAACxmC,GAAR,CAAYrN,OAAZ,CAAZ;;AAEA,QAAIS,KAAJ,EAAW;AACP,UAAImzC,SAAS,KAAK,KAAd,IAAuBlyC,MAAM,CAACC,IAAP,CAAYlB,KAAZ,EAAmByC,MAAnB,KAA8B,CAAzD,EAA4D;AACxD2wC,QAAAA,OAAO,CAAC17B,MAAR,CAAenY,OAAf;AACH;AACJ,KAJD,MAIO,IAAI4zC,SAAS,KAAK,IAAlB,EAAwB;AAC3BnzC,MAAAA,KAAK,GAAG,EAAR;AACAozC,MAAAA,OAAO,CAAC97B,GAAR,CAAY/X,OAAZ,EAAqBS,KAArB;AACH;;AAED,WAAOA,KAAP;AACH;;AAUDqzC,EAAAA,YAAY;AACR,QAAI,CAAC,KAAKn8B,IAAV,EAAgB;AACZ;AACH;;AAED,SAAK+7B,wBAAL,CAA8BxmC,IAA9B,CAAmC,KAAKyK,IAAL,CAAU5M,QAAV,CAAmByG,IAAtD;;AAEA,QAAI,KAAKmiC,qBAAT,EAAgC;AAC5B;AACH;;AAED,SAAKA,qBAAL,GAA6B,KAAKh8B,IAAL,CAAUjK,UAAV,CAAqB;AAC9C,aAAO,KAAKimC,qBAAZ;;AAEA,WACI,IAAI7jC,EAAE,GACF,KAAK4jC,wBAAL,CAA8BjE,KAA9B,EAFR,EAGI3/B,EAHJ,EAIIA,EAAE,GAAG,KAAK4jC,wBAAL,CAA8BjE,KAA9B,EAJT,EAKE;AACEn+B,QAAAA,iBAAiB,CAAC,KAAKlG,SAAN,EAAiB0E,EAAjB,CAAjB;AACA2mB,QAAAA,mBAAmB,CAACmB,eAApB,CAAoC,KAAKna,cAAzC,EAAyD3N,EAAzD;AACH;AACJ,KAZ4B,EAY1B,CAZ0B,CAA7B;AAcAvC,IAAAA,mBAAmB,CAAC,KAAKnC,SAAN,EAAiB,IAAjB,CAAnB;AACH;;AAEDqU,EAAAA,SAAS,CAAC7Z,QAAD;;;AACL,QAAI,CAAC,KAAK+R,IAAV,EAAgB;AACZ;AACH;;AAED,SAAK87B,UAAL,CAAgBvmC,IAAhB,CAAqBtH,QAArB;;AAEA,QAAI,CAAC,KAAK4tC,UAAV,EAAsB;AAClB,WAAKA,UAAL,GAAkB,MAAA,KAAK77B,IAAL,UAAA,iBAAA,SAAA,MAAWjK,WAAW;AACpC,eAAO,KAAK8lC,UAAZ;AACA,aAAKjzB,cAAL;AACH,SAAE,EAHH;AAIH;AACJ;;AAEDA,EAAAA,cAAc;AACV,QAAI,CAAC,KAAK5I,IAAV,EAAgB;AACZ;AACH;;AAED,UAAMo8B,KAAK,GAAG,KAAKN,UAAnB;;AAEA,SAAKA,UAAL,GAAkB,EAAlB;AACAM,IAAAA,KAAK,CAACr0B,OAAN,CAAe9Z,QAAD,IAAcA,QAAQ,EAApC;AACH;;;;SAGWkuC,aAAa/zC;AACzB;AACA;AACA,QAAMi0C,WAAW,GAAGj0C,OAAO,CAACyyC,IAA5B;AACAwB,EAAAA,WAAW,CAACF,YAAZ;AACH;AAED;;;;SAGgBX,cACZ9nC,KACA2G;AAEA,MAAIjS,OAAO,GAAGk0C,iBAAiB,CAAC5oC,GAAD,CAA/B;;AAEA,MAAItL,OAAJ,EAAa;AACT,WAAOA,OAAO,CAACozC,aAAR,CAAsB,KAAtB,EAA6BnhC,KAA7B,CAAP;AACH;;AAEDjS,EAAAA,OAAO,GAAG,IAAI0yC,WAAJ,CAAgBpnC,GAAhB,EAAqB2G,KAArB,CAAV;AAEC3G,EAAAA,GAAiC,CAAC6U,iBAAlC,GAAsDngB,OAAtD;AAED,SAAOA,OAAO,CAACozC,aAAR,EAAP;AACH;AAED;;;;SAGgBe,WAAW7oC;AACvB,QAAMtL,OAAO,GAAGk0C,iBAAiB,CAAC5oC,GAAD,CAAjC;AAEA,SAAOtL,OAAO,GAAGA,OAAO,CAACozC,aAAR,CAAsB,IAAtB,CAAH,GAAiC,IAA/C;AACH;SAEegB;AACZ,SAAOC,YAAP;AACH;AAED;;;;;SAIgBC,YAAYt0C;AACxB,QAAMi0C,WAAW,GAAGj0C,OAAO,CAACyyC,IAA5B;;AAEA,MAAI,CAACwB,WAAW,CAACrxC,QAAjB,EAA2B;AACvBqxC,IAAAA,WAAW,CAACrxC,QAAZ,GAAuB,IAAIy3B,WAAJ,CACnB4Z,WADmB,EAEnBA,WAAW,CAAC5oC,SAFO,CAAvB;AAIH;;AAED,SAAO4oC,WAAW,CAACrxC,QAAnB;AACH;AAED;;;;;SAIgB2xC,SAASv0C;AACrB,QAAMi0C,WAAW,GAAGj0C,OAAO,CAACyyC,IAA5B;;AAEA,MAAI,CAACwB,WAAW,CAACnxC,KAAjB,EAAwB;AACpBmxC,IAAAA,WAAW,CAACnxC,KAAZ,GAAoB,IAAIwhC,QAAJ,CAAa2P,WAAb,EAA0BA,WAAW,CAAC5oC,SAAtC,CAApB;AACH;;AAED,SAAO4oC,WAAW,CAACnxC,KAAnB;AACH;SAEe0xC,WAAWx0C;AACvB,QAAMi0C,WAAW,GAAGj0C,OAAO,CAACyyC,IAA5B;;AAEA,MAAI,CAACwB,WAAW,CAAC/wC,OAAjB,EAA0B;AACtB+wC,IAAAA,WAAW,CAAC/wC,OAAZ,GAAsB,IAAIooC,UAAJ,CAAe2I,WAAf,CAAtB;AACH;;AAED,SAAOA,WAAW,CAAC/wC,OAAnB;AACH;AAED;;;;;;SAKgB4gB,WACZ9jB,SACAiS;AAEA,QAAMgiC,WAAW,GAAGj0C,OAAO,CAACyyC,IAA5B;;AAEA,MAAI,CAACwB,WAAW,CAAC9xC,OAAjB,EAA0B;AACtB8xC,IAAAA,WAAW,CAAC9xC,OAAZ,GAAsB,IAAI0hB,UAAJ,CAAeowB,WAAf,EAA4BhiC,KAA5B,CAAtB;AACH;;AAED,SAAOgiC,WAAW,CAAC9xC,OAAnB;AACH;AAED;;;;;;;;;;;;;;;SAcgBsyC,aACZz0C;AAEAm9B,0BACAC;AAEA,QAAM6W,WAAW,GAAGj0C,OAAO,CAACyyC,IAA5B;;AAEA,MAAI,CAACwB,WAAW,CAAC1xC,SAAjB,EAA4B;AACxB0xC,IAAAA,WAAW,CAAC1xC,SAAZ,GAAwB,IAAI26B,YAAJ,CACpB+W,WADoB,EAEpB9W,wBAFoB,EAGpBC,eAHoB,CAAxB;AAKH;;AAED,SAAO6W,WAAW,CAAC1xC,SAAnB;AACH;SAEemyC,mBACZ10C;AAEA,QAAMi0C,WAAW,GAAGj0C,OAAO,CAACyyC,IAA5B;;AAEA,MAAI,CAACwB,WAAW,CAACjyC,eAAjB,EAAkC;AAC9BiyC,IAAAA,WAAW,CAACjyC,eAAZ,GAA8B,IAAI2mC,kBAAJ,CAAuBsL,WAAvB,CAA9B;AACH;;AAED,SAAOA,WAAW,CAACjyC,eAAnB;AACH;SAEe2yC,eAAe30C;AAC3B,QAAMi0C,WAAW,GAAGj0C,OAAO,CAACyyC,IAA5B;;AACA,MAAI,CAACwB,WAAW,CAACnlB,WAAjB,EAA8B;AAC1BhL,IAAAA,UAAU,CAAC9jB,OAAD,CAAV;AACAy0C,IAAAA,YAAY,CAACz0C,OAAD,CAAZ;AACAu0C,IAAAA,QAAQ,CAACv0C,OAAD,CAAR;AACAs0C,IAAAA,WAAW,CAACt0C,OAAD,CAAX;AACAw0C,IAAAA,UAAU,CAACx0C,OAAD,CAAV;AACA00C,IAAAA,kBAAkB,CAAC10C,OAAD,CAAlB;AACAi0C,IAAAA,WAAW,CAACnlB,WAAZ,GAA0B,IAAI2D,cAAJ,CAAmBwhB,WAAnB,CAA1B;AACH;;AAED,SAAOA,WAAW,CAACnlB,WAAnB;AACH;SAEe8lB,YAAY50C;AACxB,QAAMi0C,WAAW,GAAGj0C,OAAO,CAACyyC,IAA5B;AACA,SAAOwB,WAAW,CAACjB,QAAnB;AACH;SAEe6B,YAAY70C;AACxB,QAAMi0C,WAAW,GAAGj0C,OAAO,CAACyyC,IAA5B;;AACA,MAAI,CAACwB,WAAW,CAACxxC,QAAjB,EAA2B;AACvBwxC,IAAAA,WAAW,CAACxxC,QAAZ,GAAuB,IAAI2sC,WAAJ,CAAgB6E,WAAhB,CAAvB;AACH;;AAED,SAAOA,WAAW,CAACxxC,QAAnB;AACH;SAEe6wC,eACZtzC,SACAuzC;AAEAvzC,EAAAA,OAAO,CAACyyC,IAAR,CAAaa,cAAb,CAA4BtzC,OAA5B,EAAqCuzC,YAArC;AACH;AAED;;;;;SAIgBW,kBAAkB5oC;AAC9B,SAAQA,GAAiC,CAAC6U,iBAA1C;AACH;AAED;;;;;;;;SAOgB20B,SAAS90C,SAAwB+0C;AAC7C,QAAMtC,IAAI,GAAGzyC,OAAO,CAACyyC,IAArB;;AAEA,MAAIA,IAAI,CAACnyC,KAAL,KAAey0C,IAAnB,EAAyB;AACrBtC,IAAAA,IAAI,CAACnyC,KAAL,GAAay0C,IAAb;;AAEA,UAAMtM,WAAW,GAAIxoC,OAAD;AAChB,UAAI,CAACA,OAAO,CAACO,YAAb,EAA2B;AACvB,eAAOyK,UAAU,CAACwqB,WAAlB;AACH;;AAED,UACI11B,mBAAmB,CAAC0yC,IAAD,EAAOxyC,OAAP,CAAnB,IACAA,OAAO,CAACuzB,YAAR,CAAqB/yB,oBAArB,CAFJ,EAGE;AACEN,QAAAA,wBAAwB,CAACsyC,IAAD,EAAOxyC,OAAP,CAAxB;AACH;;AAED,aAAOgL,UAAU,CAACwqB,WAAlB;AACH,KAbD;;AAeA,UAAMzvB,GAAG,GAAGysC,IAAI,CAACpnC,SAAL,GAAiBL,QAA7B;AACA,UAAMyG,IAAI,GAAGzL,GAAG,CAACyL,IAAjB;AAEAg3B,IAAAA,WAAW,CAACh3B,IAAD,CAAX;AAEA,UAAMmjB,MAAM,GAAG/mB,uBAAuB,CAAC7H,GAAD,EAAMyL,IAAN,EAAYg3B,WAAZ,CAAtC;;AAEA,QAAI7T,MAAJ,EAAY;AACR,aAAOA,MAAM,CAACY,QAAP,EAAP,EAA0B;AACtB;AACH;AACJ;AACJ;AACJ;SAEewf,OAAOh1C;AACnB,SAAQA,OAAuB,CAACM,KAAhC;AACH;;ACviBD;;;;AAYA;;SACgB20C,+BACZxoC,QACAouB;AAEA,SAAOpuB,MAAM,CAAC+J,aAAP,CAAqB,IAAIpR,sBAAJ,CAA2B;AAAEy1B,IAAAA;AAAF,GAA3B,CAArB,CAAP;AACH;AAED;;SACgBqa,4BACZzoC,QACA/K;AAEA,SAAO+K,MAAM,CAAC+J,aAAP,CAAqB,IAAItR,mBAAJ,CAAwB;AAAExD,IAAAA;AAAF,GAAxB,CAArB,CAAP;AACH;AAED;;SACgByzC,mCACZ1oC,QACAu4B;AAEA,SAAOv4B,MAAM,CAAC+J,aAAP,CACH,IAAIrR,0BAAJ,CAA+B;AAAE6/B,IAAAA;AAAF,GAA/B,CADG,CAAP;AAGH;;;;;;;;;;;;;;;;;;;;;;;;;;;"}